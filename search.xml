<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MyBatis-Puls学习</title>
      <link href="/2022/12/01/MyBatis-Puls/"/>
      <url>/2022/12/01/MyBatis-Puls/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-Puls"><a href="#MyBatis-Puls" class="headerlink" title="MyBatis-Puls"></a>MyBatis-Puls</h1><h2 id="1、MyBatisPlus概述"><a href="#1、MyBatisPlus概述" class="headerlink" title="1、MyBatisPlus概述"></a>1、MyBatisPlus概述</h2><p>需要的基础：学完MyBatis、Spring、SpringMVC就可以学习这个了！</p><p>为什么学习它呢？MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码他都可以自动化完成！</p><p>JPA、tk-mapper、MyBatisPlus</p><blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2></blockquote><p>是什么？MyBatis本来就是简化JDBC操作的！</p><p>官网：<a href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a>，简化Mybaits！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/01.png" alt="1669374703084"></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/02.png" alt="1669375014235"></p><blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></blockquote><ul><li><p><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p></li><li><p><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</p></li><li><p><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</p></li><li><p><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p></li><li><p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</p></li><li><p><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</p></li><li><p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p></li><li><p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p></li><li><p><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</p></li><li><p><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</p></li><li><p><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</p></li><li><p><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</p></li></ul><blockquote><h3 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a>支持数据库</h3></blockquote><blockquote><p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></blockquote><ul><li><p>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</p></li><li><p>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</p></li></ul><blockquote><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/03.png" alt="1669375402243"></p><h2 id="2、快速开始"><a href="#2、快速开始" class="headerlink" title="2、快速开始"></a>2、快速开始</h2><p>地址：<a href="https://mp.baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">快速开始</a>  </p><p>使用第三方组件：</p><p>1、导入对应的依赖  </p><p>2、研究依赖如何配置</p><p>3、代码如何编写</p><p>4、提高扩展技术能力！</p><blockquote><p>步骤</p></blockquote><p>1、创建数据库 <code>mybatis_plus</code></p><p>2、创建<code>user</code>表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--其对应的数据库 Schema 脚本如下：</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--其对应的数据库 Data 脚本如下</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--真实的开发中，version（乐观锁）、delete（逻辑删除）、gmt_create、gmt_modified</span></span><br></pre></td></tr></table></figure><p>3、编写项目，初始化项目！使用<code>SpringBoot</code>初始化</p><p>4、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：我们使用Mybatis-plus可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis-plus！版本的差异！</p><p>5、连接数据库！这一步和mybatis相同！</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动不同 com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置 serverTimezone=GMT%2B8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p><strong>6、传统方式pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller</strong> </p><p>6、使用了mybatis-plus 之后</p><ul><li><p>pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: User实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/25 20:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.yang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代表了持久层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/25 20:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在对应的mapper上面继承基本的接口BaseMapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">//所有的CRUD操作都已经编写完成了</span></span><br><span class="line">    <span class="comment">//你不需要像以前的配置一大堆文件了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点，我们需要再主启动类上去扫描我们的mapper包下的所有接口 <code>@MapperScan(&quot;com.kuang.mapper&quot;)</code></p></li><li><p>测试类中测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlusApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//继承了BaseMapper，所有的方法都来自父类</span></span><br><span class="line">    <span class="comment">//我们也可以编写自己的扩展方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//参数是一个Wrapper，条件构造器，这里我们先不用 null</span></span><br><span class="line">        <span class="comment">//查询全部用户</span></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/04.png" alt="1669381395273"></p><blockquote><p>思考问题？</p></blockquote><p>1、SQL谁帮我们写的？MyBatis-Plus 都写好了</p><p>2、方法哪里来的？MyBatis-Plus 都写好了</p><h2 id="3、配置日志"><a href="#3、配置日志" class="headerlink" title="3、配置日志"></a>3、配置日志</h2><p>我们所有的sql现在是不可见的，我们希望知道他是怎么执行的，所以我们必须要看日志！</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/05.png" alt="1669381687617"></p><h2 id="4、CRUD扩展"><a href="#4、CRUD扩展" class="headerlink" title="4、CRUD扩展"></a>4、CRUD扩展</h2><h3 id="4-1、插入操作"><a href="#4-1、插入操作" class="headerlink" title="4.1、插入操作"></a>4.1、插入操作</h3><blockquote><p>Insert插入</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;冰冰&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">3</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);   <span class="comment">//帮我们自动生成id</span></span><br><span class="line">    System.out.println(result); <span class="comment">//返回受影响的行数</span></span><br><span class="line">    System.out.println(user);   <span class="comment">//发现 id会自动回填</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/06.png" alt="1669382707305"></p><blockquote><p>数据库插入的id默认值为：全局的唯一id</p></blockquote><h3 id="4-2、主键生成策略"><a href="#4-2、主键生成策略" class="headerlink" title="4.2、主键生成策略"></a>4.2、主键生成策略</h3><blockquote><p>默认：ID_WORKER全局唯一id</p></blockquote><p>分布式系统唯一id生成方案：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><p><strong>雪花算法：</strong></p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！</p><blockquote><p>主键自增</p></blockquote><p>我们需要配置主键自增：</p><p>1、实体类字段上<code>@TableId(type = IdType.AUTO)</code></p><p>2、数据库字段一定要是自增的！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/07.png" alt="1669383550080"></p><p>3、再次测试插入即可！</p><blockquote><p>其他源码解释</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdType</span> &#123;</span><br><span class="line">    AUTO(<span class="number">0</span>),<span class="comment">//数据库id自增</span></span><br><span class="line">    NONE(<span class="number">1</span>),<span class="comment">//未设置主键</span></span><br><span class="line">    INPUT(<span class="number">2</span>),<span class="comment">//手动输入</span></span><br><span class="line">    ASSIGN_ID(<span class="number">3</span>),<span class="comment">//默认的全局唯一id</span></span><br><span class="line">    ASSIGN_UUID(<span class="number">4</span>),<span class="comment">//全局唯一id UUID</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>); <span class="comment">//ID_WORKER 字符串表示法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、更新操作"><a href="#4-3、更新操作" class="headerlink" title="4.3、更新操作"></a>4.3、更新操作</h3><blockquote><p>update 操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id更新数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;爱吃花椒的喵酱&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/08.png" alt="1669391752852"></p><p>所有的SQL都是自动帮你动态配置的！</p><h3 id="4-4、自动填充"><a href="#4-4、自动填充" class="headerlink" title="4.4、自动填充"></a>4.4、自动填充</h3><p>创建时间、修改时间！这些个操作都是自动化完成的，我们不希望手动更新！</p><p>阿里巴巴开发手册：所有的数据库表：gmt_create、gmr_modified、几乎所有的表都要配置上！而且需要自动化！</p><blockquote><h4 id="方式一：数据库级别（工作中不允许修改数据库）"><a href="#方式一：数据库级别（工作中不允许修改数据库）" class="headerlink" title="方式一：数据库级别（工作中不允许修改数据库）"></a>方式一：数据库级别（工作中不允许修改数据库）</h4></blockquote><p>1、在表中新增字段 <strong>create_time, update_time</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/09.png" alt="1669446686055"></p><blockquote><p><font color=red>若直接在表中添加字段报错，可使用sql语句添加：</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `<span class="keyword">user</span>` <span class="keyword">add</span> `create_time` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;创建时间&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `<span class="keyword">user</span>` <span class="keyword">add</span> `update_time` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">on</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>;</span><br></pre></td></tr></table></figure><p>2、再次测试插入方法，我们需要先把实体类同步！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure><p>3、再次更新查看结果即可</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/10.png" alt="1669448126288"></p><blockquote><h4 id="方式二：代码级别"><a href="#方式二：代码级别" class="headerlink" title="方式二：代码级别"></a>方式二：代码级别</h4></blockquote><p>1、删除数据库的默认值，更新操作！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/11.png" alt="1669448335373"></p><p>2、实体类的字段属性上需要增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字段添加填充内容</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure><p>3、编写处理器处理注解即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//一定不要忘记把处理器加到IOC容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ...&quot;</span>);</span><br><span class="line">        <span class="comment">//default MetaObjectHandler setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject)</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试插入</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/12.png" alt="1669450253368"></p><p>5、测试更新</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/13.png" alt="1669450439720"></p><h3 id="4-5、乐观锁"><a href="#4-5、乐观锁" class="headerlink" title="4.5、乐观锁"></a>4.5、乐观锁</h3><p>在面试过程中，我们经常会被问到乐观锁，悲观 锁！这个其实非常简单！</p><blockquote><p>乐观锁：顾名思义十分乐观，他总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试！</p><p>悲观锁：顾名思义十分悲观，他总是任务总是出现问题，无论干什么都会上锁！再去操作！</p></blockquote><p>我们这里主要讲解，乐观锁机制！</p><p>乐观锁实现方式：</p><ul><li>取出记录，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时，set version &#x3D; new version where version &#x3D; oldversion</li><li>如果version不对，就更新失败</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--乐观锁：1、先查询，获得版本号：version = 1 </span></span><br><span class="line"><span class="comment">-- A --</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;bingbing&quot;,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;bingbing&quot;,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>测试一下Mybatis-Plus的乐观锁插件</p></blockquote><p>1、给数据库中增加version字段！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/14.png" alt="1669452668358"></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/15.png" alt="1669452704864"></p><p>2、我们实体类加对应的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span>    <span class="comment">//乐观锁Version注解</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><p>3、注册组件</p><p><strong>旧方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">//旧插件版本</span></span><br><span class="line">    <span class="comment">//乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;   </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试一下！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁失败</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testVersion2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//线程一</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;喵酱&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;112233@qq.com&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程二：插队操作</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">6L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;喵酱22&quot;</span>);</span><br><span class="line">    user2.setEmail(<span class="string">&quot;112233@qq.com&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">3</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋值多次尝试提交</span></span><br><span class="line">    userMapper.updateById(user);    <span class="comment">//若果没有乐观锁就会覆盖插队现成的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/16.png" alt="1669459690045"></p><h3 id="4-6、查询操作"><a href="#4-6、查询操作" class="headerlink" title="4.6、查询操作"></a>4.6、查询操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">6L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试批量查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按条件查询之————map操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//自定义要查询的条件--可设置多个条件</span></span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yang&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7、分页查询"><a href="#4-7、分页查询" class="headerlink" title="4.7、分页查询"></a>4.7、分页查询</h3><p>分页在网站使用的十分之多！</p><p>1、原始的 limit 进行分页</p><p>2、pageHelper 第三方插件</p><p>3、MyBatis-Plus其实也内置了分页插件</p><blockquote><p>如何使用？</p></blockquote><p>1、配置拦截器组件即可</p><p><strong>旧方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">//乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分页插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PaginationInterceptor</span> <span class="variable">paginationInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;   </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、直接使用Page对象即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//参数一：当前页</span></span><br><span class="line">    <span class="comment">//参数二：页面大小</span></span><br><span class="line">    <span class="comment">//使用了分页插件之后，所有的分页操作也变得简单了！</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;数据总数：&quot;</span> + page.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/17.png" alt="1669466730146"></p><h3 id="4-8、删除操作"><a href="#4-8、删除操作" class="headerlink" title="4.8、删除操作"></a>4.8、删除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.deleteById(<span class="number">1596132421525368839L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByBatchId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.deleteBatchIds(Arrays.asList(<span class="number">7L</span>, <span class="number">1596132421525368838L</span>, <span class="number">1596132421525368837L</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除数据条数为：&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过map按条件删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//自定义要删除的条件--可设置多个条件</span></span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除数据条数为：&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果（map条件删除）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/18.png" alt="1669469599394"></p><p>我们在工作中会遇到一些问题：逻辑删除！</p><h3 id="4-9、逻辑删除"><a href="#4-9、逻辑删除" class="headerlink" title="4.9、逻辑删除"></a>4.9、逻辑删除</h3><blockquote><p>物理删除：从数据库中直接移除</p><p>逻辑删除：在数据库中没有被移除，而是通过一个变量来让他失效！deleted &#x3D; 0 &#x3D;&gt; deleted &#x3D; 1</p></blockquote><p>管理员可以查看被删除的记录！防止数据的丢失，类似于回收站!</p><p>测试一下：</p><p>1、在数据表中增加一个deleted字段</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/19.png" alt="1669475688162"></p><p>2、实体类中增加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure><p>3、配置！</p><blockquote><p>旧方法：在application.properties配置文件中添加逻辑删除配置</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置逻辑删除</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑删除组件！</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新方法：在配置类中添加逻辑删除插件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新插件版本为 MyBatis-Plus 3.5.2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑删除插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试一下删除！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/20.png" alt="1669477199547"></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/21.png" alt="1669477291045"></p><p>以上的所有CRUD操作及其扩展操作，我们都必须精通掌握！会大大提高你的工作和写项目的效率！</p><h3 id="4-10、性能分析插件"><a href="#4-10、性能分析插件" class="headerlink" title="4.10、性能分析插件"></a>4.10、性能分析插件</h3><p>我们在平时的开发中，会遇到一些满Sql。测试、druid···</p><p>MybatisPlus也提供了性能分析插件，如果超过这个时间就停止运行！</p><p><strong>性能分析拦截器作用：用于输出每条sql语句及其执行时间</strong></p><p><strong>旧方法：</strong></p><p>1、导入插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//性能分析插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="comment">//设置dev开发、test测试 环境开启  保证我们的效率</span></span><br><span class="line"><span class="keyword">public</span> PerformanceInterceptor <span class="title function_">performanceInterceptor</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="type">PerformanceInterceptor</span> <span class="variable">performanceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PerformanceInterceptor</span>();       performanceInterceptor.setMaxTime(<span class="number">100</span>);<span class="comment">//设置sql最大执行时间*ms，如果超过了则不执行</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="literal">true</span>);<span class="comment">//开启sql格式化    </span></span><br><span class="line"><span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 要在SpringBoot中配置环境为dev或test环境！</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置开发环境</span></span><br><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><p>2、测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Testvoid</span> contextLoads() &#123;    </span><br><span class="line">    <span class="comment">//参数是一个wrapper ，条件构造器，这里我们先不用 null    </span></span><br><span class="line">    <span class="comment">//查询全部的用户    </span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>); </span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/22.png" alt="img"></p><p>使用性能分析插件，可以帮助我们提高效率！</p><blockquote><p><font color=red>(新版本不提供这个插件了)</font></p></blockquote><p><strong>! ! ! 新版本使用方法：</strong><a href="https://baomidou.com/pages/833fab/">执行SQL分析打印 </a></p><p><strong>mybatis-plus 执行SQL分析打印，及其SQL美化插件</strong></p><p>该功能依赖 <code>p6spy</code> 组件，完美的输出打印 SQL 及执行时长， MP<code>3.1.0</code> 以上版本</p><p>1、在pom.xml中引入<code>p6spy</code> ：sql性能分析依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p6spy sql性能分析插件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/p6spy/p6spy --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、application.yml 配置：更改数据库驱动</p><blockquote><p>若使用此配置则应该将原来的application.properties配置文件删除或注释其内容</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.p6spy.engine.spy.P6SpyDriver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:p6spy:mysql://127.0.0.1:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p>3、spy.properties 配置（添加这个配置文件）:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#3.2.1以上使用</span></span><br><span class="line"><span class="attr">modulelist</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"><span class="comment">#3.2.1以下使用或者不配置</span></span><br><span class="line"><span class="comment">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"><span class="comment"># 自定义日志打印</span></span><br><span class="line"><span class="attr">logMessageFormat</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span></span><br><span class="line"><span class="comment">#日志输出到控制台</span></span><br><span class="line"><span class="attr">appender</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span></span><br><span class="line"><span class="comment"># 使用日志系统记录 sql</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span></span><br><span class="line"><span class="comment"># 设置 p6spy driver 代理</span></span><br><span class="line"><span class="attr">deregisterdrivers</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 取消JDBC URL前缀</span></span><br><span class="line"><span class="attr">useprefix</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span></span><br><span class="line"><span class="attr">excludecategories</span>=<span class="string">info,debug,result,commit,resultset</span></span><br><span class="line"><span class="comment"># 日期格式</span></span><br><span class="line"><span class="attr">dateformat</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment"># 实际驱动可多个</span></span><br><span class="line"><span class="comment">#driverlist=org.h2.Driver</span></span><br><span class="line"><span class="comment"># 是否开启慢SQL记录</span></span><br><span class="line"><span class="attr">outagedetection</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 慢SQL记录标准 2 秒</span></span><br><span class="line"><span class="attr">outagedetectioninterval</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><blockquote><p>测试：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试批量查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/23.png" alt="1669551682881"></p><p><strong>注意！</strong></p><blockquote><ul><li>driver-class-name 为 p6spy 提供的驱动类</li><li>url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址</li><li>打印出 sql 为 null,在 excludecategories 增加 commit</li><li>批量操作不打印 sql,去除 excludecategories 中的 batch</li><li>批量操作打印重复的问题请使用 MybatisPlusLogFactory (3.2.1 新增）</li><li>该插件有性能损耗，不建议生产环境使用。</li></ul></blockquote><h3 id="4-11、条件构造器"><a href="#4-11、条件构造器" class="headerlink" title="4.11、条件构造器"></a>4.11、条件构造器</h3><p><strong>十分重要：Wrapper</strong> </p><p>我们写一些复杂的SQL就可以使用他来替代！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/24.png" alt="1669553674673"></p><p>1、测试1，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询name不为空的用户，并且邮箱不为空的用户，年龄大于12</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.isNotNull(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>) <span class="comment">//字段 IS NULL</span></span><br><span class="line">            .ge(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>);  <span class="comment">// 大于等于 &gt;=</span></span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/25.png" alt="1669556166417"></p><p>2、测试2，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//查询名字等于 wang 的用户</span></span><br><span class="line">    wrapper.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/26.png" alt="1669557423547"></p><p>3、测试3，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//查询年龄在19到30岁之间的用户</span></span><br><span class="line">    wrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">//区间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(wrapper);   <span class="comment">//查询结果数</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/27.png" alt="1669557369997"></p><p>4、测试4，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模糊查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//左和右%e%</span></span><br><span class="line">    wrapper.notLike(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;e&quot;</span>) <span class="comment">//NOT LIKE &#x27;%值%&#x27;</span></span><br><span class="line">            .likeRight(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;t&quot;</span>);    <span class="comment">//LIKE &#x27;值%&#x27;</span></span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/28.png" alt="1669557865876"></p><p>5、测试5，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//字段 IN ( sql语句 )</span></span><br><span class="line">    <span class="comment">//例: inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)---&gt;age in (1,2,3,4,5,6)</span></span><br><span class="line">    <span class="comment">//例: inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3)</span></span><br><span class="line">    <span class="comment">//id 在子查询中查出来</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where age&lt;10&quot;</span>);</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/29.png" alt="1669559310217"></p><p>6、测试6，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询并排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//排序：ORDER BY 字段, ... DESC</span></span><br><span class="line">    <span class="comment">//例: orderByDesc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id DESC,name DESC</span></span><br><span class="line">    <span class="comment">//通过id进行排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);  <span class="comment">//倒序</span></span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/30.png" alt="1669559594544"></p><h3 id="4-12、代码自动生成器"><a href="#4-12、代码自动生成器" class="headerlink" title="4.12、代码自动生成器"></a>4.12、代码自动生成器</h3><p>dao、pojo、service、controller都给我自己去编写完成！</p><p>AutoGenerator 是MyBatis-Plus的代码生成器，通过AutoGenerator可以快速的生成Entity、Mapper、Mapper.xml、Service、Controllerr 等各个模块的代码,极大的提高了开发效率。</p><p>测试：</p><p><strong>代码生成器（旧）：</strong>适用版本：&#x3D;&#x3D;mybatis-plus-generator 3.5.1&#x3D;&#x3D; 以下版本，3.5.1 及以上的请参考 <a href="https://baomidou.com/pages/779a6e/">代码生成器新</a></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--generator:代码生成器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--velocity:模板引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动不同 com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置 serverTimezone=GMT%2B8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p>搭建代码自动生成器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自动生成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/28 15:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//全局策略 globalConfig 配置</span></span><br><span class="line">        <span class="comment">//1、全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        <span class="comment">//生成项目目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        <span class="comment">//开发人员</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;yang&quot;</span>);</span><br><span class="line">        <span class="comment">//是否打开输出目录</span></span><br><span class="line">        gc.setOpen(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//是否覆盖</span></span><br><span class="line">        gc.setFileOverride(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//service 命名方式 : 默认值：null 例如：%sBusiness 生成 UserBusiness</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);</span><br><span class="line">        gc.setIdType(IdType.ASSIGN_ID);</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        <span class="comment">//开启swagger2模式</span></span><br><span class="line">        gc.setSwagger2(<span class="literal">true</span>);</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、数据源 dataSourceConfig 配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、包名配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        <span class="comment">//父包模块名</span></span><br><span class="line">        pc.setModuleName(<span class="string">&quot;blog&quot;</span>);</span><br><span class="line">        <span class="comment">//父包名。如果为空，将下面子包名必须写全部，否则就只需写子包名</span></span><br><span class="line">        pc.setParent(<span class="string">&quot;com.yang&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        <span class="comment">//要映射的表名</span></span><br><span class="line">        strategy.setInclude(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//数据库表映射到实体的命名策略:underline_to_camel下划线转驼峰命名</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        <span class="comment">//数据库字段映射到实体的命名策略</span></span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        <span class="comment">//自动Lombok</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//自动填充配置</span></span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">createTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;create_time&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">updateTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;update_time&quot;</span>, FieldFill.UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        tableFills.add(createTime);</span><br><span class="line">        tableFills.add(updateTime);</span><br><span class="line">        <span class="comment">//表填充字段</span></span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">//乐观锁--乐观锁属性名称&quot;version&quot;</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line">        <span class="comment">//逻辑删除属性名称:&quot;deleted&quot;</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        <span class="comment">//生成 @RestController 控制器</span></span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//驼峰转连字符  eg://localhost:8080/hello_id_2</span></span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行代码构造器</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/31.png" alt="1669809361739"></p><ol><li><p>编写自动填充处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自动填充处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/29 23:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//一定不要忘记把处理器加到IOC容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>乐观锁、逻辑删除、分页等插件配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.BlockAttackInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/29 23:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.blog.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册逻辑删除插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Swagger配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.oas.annotations.EnableOpenApi;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Swagger配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/30 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableOpenApi</span>  <span class="comment">//开启Swagger2自动配置</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类 @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">//配置API分组</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Swagger的Docket的bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="comment">//设置swagger显示的环境</span></span><br><span class="line"><span class="comment">//        Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;test&quot;);</span></span><br><span class="line"><span class="comment">//        //通过 environment.acceptsProfiles判断是否处于自己设定的环境当中</span></span><br><span class="line"><span class="comment">//        boolean flag = environment.acceptsProfiles(profiles);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;yang&quot;</span>)</span><br><span class="line">                .enable(<span class="literal">true</span>)   <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.yang.blog.controller&quot;</span>))</span><br><span class="line">                <span class="comment">//过滤什么路径</span></span><br><span class="line">                <span class="comment">//.paths(PathSelectors.ant(&quot;/yang/**&quot;))</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Swagger信息--apiInfo</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//作者信息</span></span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;yl&quot;</span>, <span class="string">&quot;https://y-orangecat.github.io/&quot;</span>, <span class="string">&quot;1249650491@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfo</span>(</span><br><span class="line">                <span class="string">&quot;yang的Swagger Api文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;以梦为马，不负韶华！&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://y-orangecat.github.io/&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件下载</title>
      <link href="/2022/10/31/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/10/31/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>软件下载</p><p>阿里云盘：<a href="https://www.aliyundrive.com/s/5Cr4EsigJUh">https://www.aliyundrive.com/s/5Cr4EsigJUh</a><br>提取码：8l5d</p>]]></content>
      
      
      <categories>
          
          <category> 资料 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity新版2.7+用法</title>
      <link href="/2022/10/30/SpringSecurity%20%E6%96%B0%E7%89%882.7+%E7%94%A8%E6%B3%95/"/>
      <url>/2022/10/30/SpringSecurity%20%E6%96%B0%E7%89%882.7+%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><strong>1、导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、测试三种权限</strong></p><p>2.7以前的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mhy.security.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//请求的规则</span></span><br><span class="line">        http.authorizeHttpRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有权限跳到login页</span></span><br><span class="line">        http.formLogin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication().passwordEncoder(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>())</span><br><span class="line">                .withUser(<span class="string">&quot;shuisanya&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;root&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;haha&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.7以后的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.factory.PasswordEncoderFactories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.provisioning.InMemoryUserDetailsManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringSecurity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Yang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        <span class="comment">// 首页所有人都可以访问，功能也只有对应有权限的人才能访问到</span></span><br><span class="line">        <span class="comment">// 请求授权的规则</span></span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">//首页所有人可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">//特定权限访问页</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//无权限默认跳转登录页</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//注销，开启注销功能，跳转到首页</span></span><br><span class="line">                .logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//密码加密</span></span><br><span class="line">        PasswordEncoder encoder= PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">        <span class="comment">//设置用户</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user1</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .username(<span class="string">&quot;lailai&quot;</span>)</span><br><span class="line">                .password(encoder.encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                <span class="comment">//用户权限</span></span><br><span class="line">                .roles(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        UserDetails user2=User.builder()</span><br><span class="line">                .username(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                .password(encoder.encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user1,user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、测试自己设置加密</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user1</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;shuisanya&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user2</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user3</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(userDetails,user1,user2,user3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接数据库使用"><a href="#连接数据库使用" class="headerlink" title="连接数据库使用"></a>连接数据库使用</h2><p><strong>导入依赖，这里使用mybatisPlus</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>编写配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"><span class="comment"># 开启逻辑删除</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-field</span>=<span class="string">deleted</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><p><strong>实现UserDetailsService接口的编写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userDetailsServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserMapper</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        QueryWrapper&lt;com.mhy.security.pojo.User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        com.mhy.security.pojo.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;该用户不存在!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;GrantedAuthority&gt; vip2 = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;vip2&quot;</span>); <span class="comment">//权限 一般是从数据库来实现</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,PasswordEncoderUtils.encode(user.getPassword()),vip2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种授权的配置"><a href="#三种授权的配置" class="headerlink" title="三种授权的配置"></a>三种授权的配置</h2><h2 id="三种授权的配置-1"><a href="#三种授权的配置-1" class="headerlink" title="三种授权的配置"></a>三种授权的配置</h2><p><strong>首页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/img/security01.png" alt="首页"></p><p><strong>第一种 hasAuthority</strong></p><p>这个参数只能配置一种授权</p><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有只能是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有只能是vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有只能是vip3才可以访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasAuthority(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasAuthority(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasAuthority(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line"></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种 hasRole</strong></p><p>这个参数只能配置一种授权，但它会默认给你配置的授权名称前加一个<strong>ROLE_</strong></p><p><strong>AuthorityAuthorizationManager</strong>类中的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROLE_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;ROLE_&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; AuthorityAuthorizationManager&lt;T&gt; <span class="title function_">hasRole</span><span class="params">(String role)</span> &#123;</span><br><span class="line">    Assert.notNull(role, <span class="string">&quot;role cannot be null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> hasAuthority(ROLE_PREFIX + role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有只能是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有只能是vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有只能是vip3才可以访问</li></ul><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>) <span class="comment">// 这里实际上是ROLE_vip1</span></span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>) <span class="comment">// 这里实际上是ROLE_vip1</span></span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);<span class="comment">// 这里实际上是ROLE_vip3</span></span><br><span class="line">        &#125;);</span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line"></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用在编写实现UserDetailsService时候需要注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">QueryWrapper&lt;com.mhy.security.pojo.User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">com.mhy.security.pojo.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;该用户不存在!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;GrantedAuthority&gt; vip2 = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;ROLE_vip2&quot;</span>);  <span class="comment">//注意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,PasswordEncoderUtils.encode(user.getPassword()),vip2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种 hasAnyAuthority</strong></p><p>配置多个参数</p><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有是vip1，vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有是vip1，vip2，vip3才可以访问</li></ul><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasAnyAuthority(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasAnyAuthority(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasAnyAuthority(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四种 hasAnyAuthority</strong></p><p>配置多个参数</p><p>这个参数只能配置一种授权，但它会默认给你配置的授权名称前加一个<strong>ROLE_</strong></p><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有是vip1，vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有是vip1，vip2，vip3才可以访问</li></ul><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasAnyRole(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasAnyRole(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasAnyRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line"></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题设置</title>
      <link href="/2022/10/19/hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"/>
      <url>/2022/10/19/hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p><strong>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</strong></p><ul><li>Page Front-matter 用于页面配置</li><li>Post Front-matter 用于文章页配置</li></ul><hr><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line"><span class="attr">updated:</span></span><br><span class="line"><span class="attr">type:</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">highlight_shrink:</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="center">写法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">【必需】页面标题</td></tr><tr><td align="center">date</td><td align="center">【必需】页面创建日期</td></tr><tr><td align="center">type</td><td align="center">【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td align="center">updated</td><td align="center">【可选】页面更新日期</td></tr><tr><td align="center">description</td><td align="center">【可选】页面描述</td></tr><tr><td align="center">keywords</td><td align="center">【可选】页面关键字</td></tr><tr><td align="center">comments</td><td align="center">【可选】显示页面评论模块(默认 true)</td></tr><tr><td align="center">top_img</td><td align="center">【可选】页面顶部图片</td></tr><tr><td align="center">mathjax</td><td align="center">【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="center">katex</td><td align="center">【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="center">aside</td><td align="center">【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="center">aplayer</td><td align="center">【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td align="center">highlight_shrink</td><td align="center">【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><hr><h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line"><span class="attr">updated:</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line"><span class="attr">toc_number:</span></span><br><span class="line"><span class="attr">toc_style_simple:</span></span><br><span class="line"><span class="attr">copyright:</span></span><br><span class="line"><span class="attr">copyright_author:</span></span><br><span class="line"><span class="attr">copyright_author_href:</span></span><br><span class="line"><span class="attr">copyright_url:</span></span><br><span class="line"><span class="attr">copyright_info:</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">highlight_shrink:</span></span><br><span class="line"><span class="attr">aside:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated【可选】文章更新日期</td><td></td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/19/hello-world/"/>
      <url>/2022/10/19/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>9.Spring Boot面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/9.%20Spring%20Boot/"/>
      <url>/2022/06/01/javaInterviewQuestions/9.%20Spring%20Boot/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Boot面试题（2022版）"><a href="#Spring-Boot面试题（2022版）" class="headerlink" title="Spring Boot面试题（2022版）"></a>Spring Boot面试题（2022版）</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-什么是Spring-boot"><a href="#1-1-什么是Spring-boot" class="headerlink" title="1.1 什么是Spring boot"></a>1.1 什么是Spring boot</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h2 id="1-2-Spring-Boot-有哪些优点？"><a href="#1-2-Spring-Boot-有哪些优点？" class="headerlink" title="1.2 Spring Boot 有哪些优点？"></a>1.2 Spring Boot 有哪些优点？</h2><p>Spring Boot 主要有如下优点：</p><ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>没有代码生成，也不需要XML配置。</li><li>避免大量的 Maven 导入和各种版本冲突。</li></ol><h2 id="1-3-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的"><a href="#1-3-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的" class="headerlink" title="1.3 Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的?"></a>1.3 Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的?</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h1><h2 id="2-1-什么是-JavaConfig？"><a href="#2-1-什么是-JavaConfig？" class="headerlink" title="2.1 什么是 JavaConfig？"></a>2.1 什么是 JavaConfig？</h2><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><p>（1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</p><p>（2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p><p>（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><h2 id="2-2-Spring-Boot-自动配置原理是什么？"><a href="#2-2-Spring-Boot-自动配置原理是什么？" class="headerlink" title="2.2 Spring Boot 自动配置原理是什么？"></a>2.2 Spring Boot 自动配置原理是什么？</h2><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，</p><p>@EnableAutoConfiguration 给容器导入META-INF&#x2F;spring.factories 里定义的自动配置类。</p><p>筛选有效的自动配置类。</p><p>每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能</p><h2 id="2-3-如何理解-Spring-Boot-配置加载顺序？"><a href="#2-3-如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="2.3 如何理解 Spring Boot 配置加载顺序？"></a>2.3 如何理解 Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）properties文件；</p><p>2）YAML文件；</p><p>3）系统环境变量；</p><p>4）命令行参数；</p><p>等等……</p><h2 id="2-4-什么是-YAML？"><a href="#2-4-什么是-YAML？" class="headerlink" title="2.4 什么是 YAML？"></a>2.4 什么是 YAML？</h2><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h2 id="2-5-YAML-配置的优势在哪里"><a href="#2-5-YAML-配置的优势在哪里" class="headerlink" title="2.5 YAML 配置的优势在哪里 ?"></a>2.5 YAML 配置的优势在哪里 ?</h2><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>简洁</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h2 id="2-6-Spring-Boot-是否可以使用-XML-配置"><a href="#2-6-Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="2.6 Spring Boot 是否可以使用 XML 配置 ?"></a>2.6 Spring Boot 是否可以使用 XML 配置 ?</h2><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><h2 id="2-7-spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别"><a href="#2-7-spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别" class="headerlink" title="2.7 spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?"></a>2.7 spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h2><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>spring boot 核心的两个配置文件：</p><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</li></ul><h2 id="2-8-什么是-Spring-Profiles？"><a href="#2-8-什么是-Spring-Profiles？" class="headerlink" title="2.8 什么是 Spring Profiles？"></a>2.8 什么是 Spring Profiles？</h2><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p><h2 id="2-9-如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#2-9-如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="2.9 如何在自定义端口上运行 Spring Boot 应用程序？"></a>2.9 如何在自定义端口上运行 Spring Boot 应用程序？</h2><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在application.properties 中指定端口。server.port &#x3D; 8090</p><h1 id="3-安全"><a href="#3-安全" class="headerlink" title="3 安全"></a>3 安全</h1><h2 id="3-1-如何实现-Spring-Boot-应用程序的安全性？"><a href="#3-1-如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="3.1 如何实现 Spring Boot 应用程序的安全性？"></a>3.1 如何实现 Spring Boot 应用程序的安全性？</h2><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p><h2 id="3-2-比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#3-2-比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="3.2 比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>3.2 比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h2><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p><ul><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ul><h2 id="3-3-Spring-Boot-中如何解决跨域问题"><a href="#3-3-Spring-Boot-中如何解决跨域问题" class="headerlink" title="3.3 Spring Boot 中如何解决跨域问题 ?"></a>3.3 Spring Boot 中如何解决跨域问题 ?</h2><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。<br>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。<br>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。<br>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">urlBasedCorsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-什么是-CSRF-攻击？"><a href="#3-4-什么是-CSRF-攻击？" class="headerlink" title="3.4 什么是 CSRF 攻击？"></a>3.4 什么是 CSRF 攻击？</h2><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><h1 id="4-监视器"><a href="#4-监视器" class="headerlink" title="4 监视器"></a>4 监视器</h1><h2 id="4-1-Spring-Boot-中的监视器是什么？"><a href="#4-1-Spring-Boot-中的监视器是什么？" class="headerlink" title="4.1 Spring Boot 中的监视器是什么？"></a>4.1 Spring Boot 中的监视器是什么？</h2><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p><h2 id="4-2-如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#4-2-如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="4.2 如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>4.2 如何在 Spring Boot 中禁用 Actuator 端点安全性？</h2><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h2 id="4-3-如何监视所有-Spring-Boot-微服务？"><a href="#4-3-如何监视所有-Spring-Boot-微服务？" class="headerlink" title="4.3 如何监视所有 Spring Boot 微服务？"></a>4.3 如何监视所有 Spring Boot 微服务？</h2><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p><h1 id="5-整合第三方"><a href="#5-整合第三方" class="headerlink" title="5 整合第三方"></a>5 整合第三方</h1><h2 id="5-1-什么是-WebSockets？"><a href="#5-1-什么是-WebSockets？" class="headerlink" title="5.1 什么是 WebSockets？"></a>5.1 什么是 WebSockets？</h2><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p><ol><li>WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</li><li>WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</li><li>单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</li><li>Light -与 http 相比，WebSocket 消息数据交换要轻得多。</li></ol><h2 id="5-2-什么是-Spring-Data"><a href="#5-2-什么是-Spring-Data" class="headerlink" title="5.2 什么是 Spring Data ?"></a>5.2 什么是 Spring Data ?</h2><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><p><strong>SpringData 项目支持 NoSQL 存储：</strong></p><ol><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键&#x2F;值存储）</li><li>Hbase（列族数据库）</li></ol><p><strong>SpringData 项目所支持的关系数据存储技术：</strong></p><ol><li>JDBC</li><li>JPA<br>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</li></ol><h2 id="5-3-什么是-Spring-Batch？"><a href="#5-3-什么是-Spring-Batch？" class="headerlink" title="5.3 什么是 Spring Batch？"></a>5.3 什么是 Spring Batch？</h2><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h2 id="5-4-什么是-FreeMarker-模板？"><a href="#5-4-什么是-FreeMarker-模板？" class="headerlink" title="5.4 什么是 FreeMarker 模板？"></a>5.4 什么是 FreeMarker 模板？</h2><p>FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用freemarker 可以将这些结合起来，给出最终的输出页面。</p><h2 id="5-5-如何集成-Spring-Boot-和-ActiveMQ？"><a href="#5-5-如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="5.5 如何集成 Spring Boot 和 ActiveMQ？"></a>5.5 如何集成 Spring Boot 和 ActiveMQ？</h2><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p><h2 id="5-6-什么是-Apache-Kafka？"><a href="#5-6-什么是-Apache-Kafka？" class="headerlink" title="5.6 什么是 Apache Kafka？"></a>5.6 什么是 Apache Kafka？</h2><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p><h2 id="5-7-什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#5-7-什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="5.7 什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>5.7 什么是 Swagger？你用 Spring Boot 实现了它吗？</h2><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p><h2 id="5-8-前后端分离，如何维护接口文档"><a href="#5-8-前后端分离，如何维护接口文档" class="headerlink" title="5.8 前后端分离，如何维护接口文档 ?"></a>5.8 前后端分离，如何维护接口文档 ?</h2><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。</p><h1 id="6-整合第三方"><a href="#6-整合第三方" class="headerlink" title="6 整合第三方"></a>6 整合第三方</h1><h2 id="6-1-如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#6-1-如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="6.1 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>6.1 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源<br>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="6-2-您使用了哪些-starter-maven-依赖项？"><a href="#6-2-您使用了哪些-starter-maven-依赖项？" class="headerlink" title="6.2 您使用了哪些 starter maven 依赖项？"></a>6.2 您使用了哪些 starter maven 依赖项？</h2><p>使用了下面的一些依赖项</p><p>spring-boot-starter-activemq<br>spring-boot-starter-security<br>这有助于增加更少的依赖关系，并减少版本的冲突。</p><h2 id="6-3-Spring-Boot-中的-starter-到底是什么"><a href="#6-3-Spring-Boot-中的-starter-到底是什么" class="headerlink" title="6.3 Spring Boot 中的 starter 到底是什么 ?"></a>6.3 Spring Boot 中的 starter 到底是什么 ?</h2><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p><h2 id="6-4-spring-boot-starter-parent-有什么用"><a href="#6-4-spring-boot-starter-parent-有什么用" class="headerlink" title="6.4 spring-boot-starter-parent 有什么用 ?"></a>6.4 spring-boot-starter-parent 有什么用 ?</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是<br>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li><li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li></ol><h2 id="6-5-Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#6-5-Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="6.5 Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>6.5 Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h2><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h2 id="6-6-运行-Spring-Boot-有哪几种方式？"><a href="#6-6-运行-Spring-Boot-有哪几种方式？" class="headerlink" title="6.6 运行 Spring Boot 有哪几种方式？"></a>6.6 运行 Spring Boot 有哪几种方式？</h2><p>1）打包用命令或者放到容器中运行<br>2）用 Maven&#x2F; Gradle 插件运行<br>3）直接执行 main 方法运行</p><h2 id="6-7-Spring-Boot-需要独立的容器运行吗？"><a href="#6-7-Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="6.7 Spring Boot 需要独立的容器运行吗？"></a>6.7 Spring Boot 需要独立的容器运行吗？</h2><p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p><h2 id="6-8-开启-Spring-Boot-特性有哪几种方式？"><a href="#6-8-开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="6.8 开启 Spring Boot 特性有哪几种方式？"></a>6.8 开启 Spring Boot 特性有哪几种方式？</h2><p>1）继承spring-boot-starter-parent项目<br>2）导入spring-boot-dependencies项目依赖</p><h2 id="6-9-如何使用-Spring-Boot-实现异常处理？"><a href="#6-9-如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="6.9 如何使用 Spring Boot 实现异常处理？"></a>6.9 如何使用 Spring Boot 实现异常处理？</h2><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h2 id="6-10-如何使用-Spring-Boot-实现分页和排序？"><a href="#6-10-如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="6.10 如何使用 Spring Boot 实现分页和排序？"></a>6.10 如何使用 Spring Boot 实现分页和排序？</h2><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p><h2 id="6-11-微服务中如何实现-session-共享"><a href="#6-11-微服务中如何实现-session-共享" class="headerlink" title="6.11 微服务中如何实现 session 共享 ?"></a>6.11 微服务中如何实现 session 共享 ?</h2><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h2 id="6-12-Spring-Boot-中如何实现定时任务"><a href="#6-12-Spring-Boot-中如何实现定时任务" class="headerlink" title="6.12 Spring Boot 中如何实现定时任务 ?"></a>6.12 Spring Boot 中如何实现定时任务 ?</h2><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。<br>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.MyBatis面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/8.%20MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/06/01/javaInterviewQuestions/8.%20MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis面试题（2022版）"><a href="#MyBatis面试题（2022版）" class="headerlink" title="MyBatis面试题（2022版）"></a>MyBatis面试题（2022版）</h1><h1 id="1-Mybatis概述"><a href="#1-Mybatis概述" class="headerlink" title="1 Mybatis概述"></a>1 Mybatis概述</h1><h2 id="1-1-MyBatis是什么？"><a href="#1-1-MyBatis是什么？" class="headerlink" title="1.1 MyBatis是什么？"></a>1.1 MyBatis是什么？</h2><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的<br>JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain<br>Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="1-2-ORM是什么"><a href="#1-2-ORM是什么" class="headerlink" title="1.2 ORM是什么"></a>1.2 ORM是什么</h2><p>ORM（Object Relational<br>Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h2 id="1-3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#1-3-为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="1.3 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>1.3 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。<br>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h2 id="1-4-传统JDBC开发存在的问题"><a href="#1-4-传统JDBC开发存在的问题" class="headerlink" title="1.4 传统JDBC开发存在的问题"></a>1.4 传统JDBC开发存在的问题</h2><ul><li>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</li><li>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</li><li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li><li>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</li></ul><h2 id="1-5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#1-5-JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="1.5 JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>1.5 JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p><p><strong>解决</strong>：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</p><p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p><p><strong>解决</strong>：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p><p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p><strong>解决</strong>： Mybatis自动将java对象映射至sql语句。</p><p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p><strong>解决：Mybatis自动将sql执行结果映射至java对象。</strong></p><h2 id="1-6-Mybatis优缺点"><a href="#1-6-Mybatis优缺点" class="headerlink" title="1.6 Mybatis优缺点"></a>1.6 Mybatis优缺点</h2><p><strong>优点</strong></p><p>与传统的数据库访问技术相比，ORM有以下优点：</p><ul><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li><li>能够与Spring很好的集成</li></ul><p><strong>缺点</strong></p><ul><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul><h2 id="1-7-MyBatis框架适用场景"><a href="#1-7-MyBatis框架适用场景" class="headerlink" title="1.7 MyBatis框架适用场景"></a>1.7 MyBatis框架适用场景</h2><ul><li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li><li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li></ul><h2 id="1-8-Hibernate-和-MyBatis-的区别"><a href="#1-8-Hibernate-和-MyBatis-的区别" class="headerlink" title="1.8 Hibernate 和 MyBatis 的区别"></a>1.8 Hibernate 和 MyBatis 的区别</h2><p><strong>相同点</strong></p><p>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p><p><strong>不同点</strong></p><p><strong>映射关系</strong></p><ul><li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li><li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li></ul><p><strong>SQL优化和移植性</strong></p><ul><li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query<br>Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li><li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li></ul><p><strong>开发难易程度和学习成本</strong></p><ul><li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li><li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li></ul><p><strong>总结</strong><br>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，<br>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p><h1 id="2-MyBatis的解析和运行原理"><a href="#2-MyBatis的解析和运行原理" class="headerlink" title="2 MyBatis的解析和运行原理"></a>2 MyBatis的解析和运行原理</h1><h2 id="2-1-MyBatis编程步骤是什么样的？"><a href="#2-1-MyBatis编程步骤是什么样的？" class="headerlink" title="2.1 MyBatis编程步骤是什么样的？"></a>2.1 MyBatis编程步骤是什么样的？</h2><ol><li>创建SqlSessionFactory</li><li>通过SqlSessionFactory创建SqlSession</li><li>通过sqlsession执行数据库操作</li><li>调用session.commit()提交事务</li><li>调用session.close()关闭会话</li></ol><h2 id="2-2-请说说MyBatis的工作原理"><a href="#2-2-请说说MyBatis的工作原理" class="headerlink" title="2.2 请说说MyBatis的工作原理"></a>2.2 请说说MyBatis的工作原理</h2><p>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作原理如下图</p><p>![在这里插入图片描述](8. MyBatis面试题.assets&#x2F;d61d2562d8114d34bcec69616b8430b7.png)</p><p>1）<strong>读取 MyBatis 配置文件</strong>：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p><p>2）<strong>加载映射文件</strong>:映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件<br>mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p><p>3）<strong>构造会话工厂</strong>：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p><p>4）<strong>创建会话对象</strong>：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p><p>5）<strong>Executor 执行器</strong>：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的<br>SQL 语句，同时负责查询缓存的维护。</p><p>6）<strong>MappedStatement 对象</strong>：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的<br>SQL 语句的 id、参数等信息。</p><p>7）<strong>输入参数映射</strong>：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对<br>preparedStatement 对象设置参数的过程。</p><p>8）<strong>输出结果映射</strong>：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC<br>对结果集的解析过程。</p><h2 id="2-3-MyBatis的功能架构是怎样的"><a href="#2-3-MyBatis的功能架构是怎样的" class="headerlink" title="2.3 MyBatis的功能架构是怎样的"></a>2.3 MyBatis的功能架构是怎样的</h2><p>![在这里插入图片描述](8. MyBatis面试题.assets&#x2F;ea0991de70224a8ab1650485ee3afc5c.png)</p><p>我们把Mybatis的功能架构分为三层：</p><ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul><h2 id="2-4-MyBatis的框架架构设计是怎么样的"><a href="#2-4-MyBatis的框架架构设计是怎么样的" class="headerlink" title="2.4 MyBatis的框架架构设计是怎么样的"></a>2.4 MyBatis的框架架构设计是怎么样的</h2><p>![在这里插入图片描述](8. MyBatis面试题.assets&#x2F;9ca0f4cd51a24be583065bbf31504a4f.png)</p><p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。</p><p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</p><p>(2)<br>SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</p><p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p><p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</p><h2 id="2-5-为什么需要预编译"><a href="#2-5-为什么需要预编译" class="headerlink" title="2.5 为什么需要预编译"></a>2.5 为什么需要预编译</h2><ol><li><strong>定义：</strong><br>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</li><li><strong>为什么需要预编译</strong><br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL<br>多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个<br>SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState<br>对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</li></ol><h2 id="2-6-Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#2-6-Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="2.6 Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>2.6 Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p><strong>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</strong></p><p><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p><strong>ReuseExecutor</strong><br>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;<br>String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()<br>），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()<br>完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</span><br></pre></td></tr></table></figure><h2 id="2-7-Mybatis中如何指定使用哪一种Executor执行器？"><a href="#2-7-Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="2.7 Mybatis中如何指定使用哪一种Executor执行器？"></a>2.7 Mybatis中如何指定使用哪一种Executor执行器？</h2><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession<br>openSession(ExecutorType execType)。</p><p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p><h2 id="2-8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#2-8-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="2.8 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>2.8 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()<br>方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)<br>，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h1 id="3-映射器"><a href="#3-映射器" class="headerlink" title="3 映射器"></a>3 映射器</h1><h2 id="3-1-和-的区别"><a href="#3-1-和-的区别" class="headerlink" title="3.1 #{}和${}的区别"></a>3.1 #{}和${}的区别</h2><ul><li>{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li>Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</li><li>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</li><li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li><li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li></ul><h2 id="3-2-模糊查询like语句该怎么写"><a href="#3-2-模糊查询like语句该怎么写" class="headerlink" title="3.2 模糊查询like语句该怎么写"></a>3.2 模糊查询like语句该怎么写</h2><p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p><p>（2）“%”#{question}“%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需要使用双引号” “，不能使用单引号<br>’ ‘，不然会查不到任何结果。</p><p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p><p>（4）使用bind标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;listUserLikeUsername&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span><br><span class="line">　　&lt;bind name=<span class="string">&quot;pattern&quot;</span> value=<span class="string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span><br><span class="line">　　select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h2 id="3-3-在mapper中如何传递多个参数"><a href="#3-3-在mapper中如何传递多个参数" class="headerlink" title="3.3 在mapper中如何传递多个参数"></a>3.3 在mapper中如何传递多个参数</h2><p><strong>方法1：顺序传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(String name, <span class="type">int</span> deptId)</span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;<span class="number">0</span>&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;<span class="number">1</span>&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>#{}里面的数字代表传入参数的顺序。<br>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p><p><strong>方法2：@Param注解传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String name, <span class="type">int</span> <span class="meta">@Param(&quot;deptId&quot;)</span> deptId)</span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt; </span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。<br>这种方法在参数不多的情况还是比较直观的，推荐使用。</p><p><strong>方法3：Map传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;java.util.Map&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是Map里面的key名称。<br>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p><p><strong>方法4：Java Bean传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(User user)</span>;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>#{}里面的名称对应的是User类里面的成员属性。<br>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。</p><h2 id="3-4-Mybatis如何执行批量操作"><a href="#3-4-Mybatis如何执行批量操作" class="headerlink" title="3.4 Mybatis如何执行批量操作"></a>3.4 Mybatis如何执行批量操作</h2><p><strong>使用foreach标签</strong></p><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有<code>item，index，collection，open，separator，close</code><br>。</p><p><strong>item</strong>表示集合中每一个元素进行迭代时的别名，随便起的变量名；<br><strong>index</strong>指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；<br><strong>open</strong>表示该语句以什么开始，常用“(”；<br><strong>separator</strong>表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；<br><strong>close</strong>表示以什么结束，常用“)”。</p><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p><ol><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，</li></ol><p>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key<br>具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span><br><span class="line">       <span class="type">int</span> <span class="title function_">addEmpsBatch</span><span class="params">(<span class="meta">@Param(&quot;emps&quot;)</span> List&lt;Employee&gt; emps)</span>; --&gt;</span><br><span class="line">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt; <span class="comment">//推荐使用</span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    INSERT INTO <span class="title function_">emp</span><span class="params">(ename,gender,email,did)</span></span><br><span class="line">    VALUES</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=<span class="literal">true</span>的支持</span><br><span class="line"> 如jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/mybatis?allowMultiQueries=true --&gt;  </span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;;&quot;</span>&gt;                                 </span><br><span class="line">        INSERT INTO <span class="title function_">emp</span><span class="params">(ename,gender,email,did)</span></span><br><span class="line">        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p><strong>使用ExecutorType.BATCH</strong></p><p>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优；<br>但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</p><p>具体用法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量保存方法测试</span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//可以执行批量操作的sqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">openSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量保存执行前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> <span class="title class_">Employee</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">&quot;b&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量保存执行后的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长&quot;</span> + (end - start));</span><br><span class="line">        <span class="comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span></span><br><span class="line">        <span class="comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mapper和mapper.xml如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;   </span><br><span class="line">    <span class="comment">//批量保存员工</span></span><br><span class="line">    Long <span class="title function_">addEmp</span><span class="params">(Employee employee)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span></span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;addEmp&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">employee</span><span class="params">(lastName,email,gender)</span></span><br><span class="line">        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="3-5-如何获取生成的主键"><a href="#3-5-如何获取生成的主键" class="headerlink" title="3.5 如何获取生成的主键"></a>3.5 如何获取生成的主键</h2><p><strong>对于支持主键自增的数据库（MySQL）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;insertUser&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;userId&quot;</span> &gt;</span><br><span class="line">    insert into <span class="title function_">user</span><span class="params">( </span></span><br><span class="line"><span class="params">    user_name, user_password, create_time)</span> </span><br><span class="line">    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>parameterType 可以不写，Mybatis可以推断出传入的数据类型。如果想要访问主键，那么应当parameterType 应当是java实体或者Map。这样数据在插入之后<br>可以通过ava实体或者Map 来获取主键值。通过 getUserId获取主键</p><p><strong>不支持主键自增的数据库（Oracle）</strong></p><p>对于像Oracle这样的数据，没有提供主键自增的功能，而是使用序列的方式获取自增主键。<br>可以使用＜selectKey＞标签来获取主键的值，这种方式不仅适用于不提供主键自增功能的数据库，也适用于提供主键自增功能的数据库<br>＜selectKey＞一般的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;selectKey keyColumn=<span class="string">&quot;id&quot;</span> resultType=<span class="string">&quot;long&quot;</span> keyProperty=<span class="string">&quot;id&quot;</span> order=<span class="string">&quot;BEFORE&quot;</span>&gt;</span><br><span class="line">&lt;/selectKey&gt;</span><br></pre></td></tr></table></figure><p>![在这里插入图片描述](8. MyBatis面试题.assets&#x2F;6af71ba1883d49c3890d7df1754b677e.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;insertUser&quot;</span> &gt;</span><br><span class="line">&lt;selectKey keyColumn=<span class="string">&quot;id&quot;</span> resultType=<span class="string">&quot;long&quot;</span> keyProperty=<span class="string">&quot;userId&quot;</span> order=<span class="string">&quot;BEFORE&quot;</span>&gt;</span><br><span class="line">SELECT USER_ID.nextval as id from dual </span><br><span class="line">&lt;/selectKey&gt; </span><br><span class="line">insert into <span class="title function_">user</span><span class="params">( </span></span><br><span class="line"><span class="params">user_id,user_name, user_password, create_time)</span> </span><br><span class="line">values(#&#123;userId&#125;,#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>此时会将Oracle生成的主键值赋予userId变量。这个userId<br>就是USER对象的属性，这样就可以将生成的主键值返回了。如果仅仅是在insert语句中使用但是不返回，此时keyProperty&#x3D;“任意自定义变量名”，resultType<br>可以不写。<br>Oracle 数据库中的值要设置为 BEFORE ，这是因为 Oracle中需要先从序列获取值，然后将值作为主键插入到数据库中。</p><p><strong>扩展</strong></p><p>如果Mysql 使用selectKey的方式获取主键，需要注意下面两点：</p><p>order ： AFTER</p><p>获取递增主键值 ：SELECT LAST_INSERT_ID()</p><h2 id="3-5-当实体类中的属性名和表中的字段名不一样-，怎么办"><a href="#3-5-当实体类中的属性名和表中的字段名不一样-，怎么办" class="headerlink" title="3.5 当实体类中的属性名和表中的字段名不一样 ，怎么办"></a>3.5 当实体类中的属性名和表中的字段名不一样 ，怎么办</h2><p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span><br><span class="line">       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>第2种： 通过来映射字段名和实体类属性名的一一对应的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultMap=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap type=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span> id=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">    &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;order_id&quot;</span>&gt;</span><br><span class="line">    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;</span><br><span class="line">    &lt;<span class="type">result</span> <span class="variable">property</span> <span class="operator">=</span><span class="string">&quot;orderno&quot;</span> column =<span class="string">&quot;order_no&quot;</span>/&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;price&quot;</span> column=<span class="string">&quot;order_price&quot;</span> /&gt;</span><br><span class="line">&lt;/reslutMap&gt;</span><br></pre></td></tr></table></figure><h2 id="3-6-Mapper-编写有哪几种方式？"><a href="#3-6-Mapper-编写有哪几种方式？" class="headerlink" title="3.6 Mapper 编写有哪几种方式？"></a>3.6 Mapper 编写有哪几种方式？</h2><p><strong>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</strong><br>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><p>（2）定义 mapper 接口<br>（3）实现类集成 SqlSessionDaoSupport<br>mapper 方法中可以 this.getSqlSession()进行数据增删改查。<br>（4）spring 配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot; &quot;</span> class=<span class="string">&quot;mapper 接口的实现&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;sqlSessionFactory&quot;</span></span><br><span class="line">    ref=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</strong><br>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><p>（2）定义 mapper 接口：<br>（3）mapper.xml 中的 namespace 为 mapper 接口的地址<br>（4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致<br>（5）Spring 中定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;&quot;</span> class=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;mapperInterface&quot;</span> value=<span class="string">&quot;mapper 接口地址&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;sqlSessionFactory&quot;</span> ref=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>第三种：使用 mapper 扫描器：</strong></p><p>（1）mapper.xml 文件编写：</p><p>mapper.xml 中的 namespace 为 mapper 接口的地址；</p><p>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p><p>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p><p>（2）定义 mapper 接口：</p><p>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p><p>（3）配置 mapper 扫描器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;basePackage&quot;</span> value=<span class="string">&quot;mapper 接口包地址</span></span><br><span class="line"><span class="string">    &quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span></span><br><span class="line">    value=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>（4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p><h2 id="3-7-什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#3-7-什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="3.7 什么是MyBatis的接口绑定？有哪些实现方式？"></a>3.7 什么是MyBatis的接口绑定？有哪些实现方式？</h2><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p><strong>接口绑定有两种实现方式</strong></p><ul><li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</li><li>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定，<br>当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</li></ul><h2 id="3-8-使用MyBatis的mapper接口调用时有哪些要求？"><a href="#3-8-使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="3.8 使用MyBatis的mapper接口调用时有哪些要求？"></a>3.8 使用MyBatis的mapper接口调用时有哪些要求？</h2><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p><p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p><p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p><p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p><h2 id="3-9-最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#3-9-最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="3.9 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>3.9 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h2><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：</p><p>com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id &#x3D;<br>findStudentById的MappedStatement。在Mybatis中，每一个、、、标签，都会被解析为一个MappedStatement对象。</p><p><strong>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</strong></p><p><strong>Dao接口的工作原理</strong><br>是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><h2 id="3-10-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#3-10-Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="3.10 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>3.10 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p><p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;<br>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><h2 id="3-11-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#3-11-简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="3.11 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>3.11 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h2><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个、、、标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p><h2 id="3-12-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#3-12-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="3.12 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>3.12 Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h2><p>第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。</p><p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS<br>NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME<br>AS NaMe，Mybatis一样可以正常工作。</p><p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><h2 id="3-13-Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#3-13-Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="3.13 Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>3.13 Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h2><p>还有很多其他的标签，、、、、，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过标签引入sql片段，为不支持自增的主键生成策略标签。</p><h2 id="3-14-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"><a href="#3-14-Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="3.14 Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？"></a>3.14 Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h2><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p><p>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p><h1 id="4-高级查询"><a href="#4-高级查询" class="headerlink" title="4 高级查询"></a>4 高级查询</h1><h2 id="4-1-MyBatis实现一对一，一对多有几种方式，怎么操作的？"><a href="#4-1-MyBatis实现一对一，一对多有几种方式，怎么操作的？" class="headerlink" title="4.1 MyBatis实现一对一，一对多有几种方式，怎么操作的？"></a>4.1 MyBatis实现一对一，一对多有几种方式，怎么操作的？</h2><p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p><p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p><h2 id="4-2-Mybatis是否可以映射Enum枚举类？"><a href="#4-2-Mybatis是否可以映射Enum枚举类？" class="headerlink" title="4.2 Mybatis是否可以映射Enum枚举类？"></a>4.2 Mybatis是否可以映射Enum枚举类？</h2><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()<br>和getResult()接口方法。</p><p>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()<br>和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p><h1 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5 动态SQL"></a>5 动态SQL</h1><h2 id="5-1-Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#5-1-Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="5.1 Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>5.1 Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h2><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h1 id="6-插件模块"><a href="#6-插件模块" class="headerlink" title="6 插件模块"></a>6 插件模块</h1><h2 id="6-1-Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#6-1-Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="6.1 Mybatis是如何进行分页的？分页插件的原理是什么？"></a>6.1 Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p><h2 id="6-2-简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#6-2-简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="6.2 简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>6.2 简述Mybatis的插件运行原理，以及如何编写一个插件。</h2><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()<br>方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h1 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7 缓存"></a>7 缓存</h1><h2 id="7-1-Mybatis的一级、二级缓存"><a href="#7-1-Mybatis的一级、二级缓存" class="headerlink" title="7.1 Mybatis的一级、二级缓存"></a>7.1 Mybatis的一级、二级缓存</h2><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session<br>中的所有 Cache 就将清空，默认打开一级缓存。</p><p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)<br>，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(<br>可用来保存对象的状态),可在它的映射文件中配置 ；</p><p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select<br>中的缓存将被 clear。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.Spring MVC面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/7.%20Spring%20MVC/"/>
      <url>/2022/06/01/javaInterviewQuestions/7.%20Spring%20MVC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-MVC面试题（2022版）"><a href="#Spring-MVC面试题（2022版）" class="headerlink" title="Spring MVC面试题（2022版）"></a>Spring MVC面试题（2022版）</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？"><a href="#1-1-什么是Spring-MVC？简单介绍下你对Spring-MVC的理解？" class="headerlink" title="1.1 什么是Spring MVC？简单介绍下你对Spring MVC的理解？"></a>1.1 什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h2 id="1-2-Spring-MVC的优点-集合的特点主要有如下两点："><a href="#1-2-Spring-MVC的优点-集合的特点主要有如下两点：" class="headerlink" title="1.2 Spring MVC的优点 集合的特点主要有如下两点："></a>1.2 Spring MVC的优点 集合的特点主要有如下两点：</h2><ol><li>可以支持各种视图技术,而不仅仅局限于JSP；</li><li>与Spring框架集成（如IoC容器、AOP等）；</li><li>清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。</li><li>支持各种请求资源的映射策略。</li></ol><h1 id="2-核心组件"><a href="#2-核心组件" class="headerlink" title="2 核心组件"></a>2 核心组件</h1><h2 id="2-1-Spring-MVC的主要组件？"><a href="#2-1-Spring-MVC的主要组件？" class="headerlink" title="2.1 Spring MVC的主要组件？"></a>2.1 Spring MVC的主要组件？</h2><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p><p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p><p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p><p>作用：根据请求的URL来查找Handler</p><p>（3）处理器适配器HandlerAdapter</p><p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p><p>（4）处理器Handler（需要程序员开发）</p><p>（5）视图解析器 ViewResolver（不需要程序员开发）</p><p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p><p>（6）视图View（需要程序员开发jsp）</p><p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p><h2 id="2-2-什么是DispatcherServlet"><a href="#2-2-什么是DispatcherServlet" class="headerlink" title="2.2 什么是DispatcherServlet"></a>2.2 什么是DispatcherServlet</h2><p>Spring的MVC框架是围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p><h2 id="2-3-什么是Spring-MVC框架的控制器？"><a href="#2-3-什么是Spring-MVC框架的控制器？" class="headerlink" title="2.3 什么是Spring MVC框架的控制器？"></a>2.3 什么是Spring MVC框架的控制器？</h2><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p><h2 id="2-4-Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#2-4-Spring-MVC的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="2.4 Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？"></a>2.4 Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h2><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p><h1 id="3-工作原理"><a href="#3-工作原理" class="headerlink" title="3 工作原理"></a>3 工作原理</h1><h2 id="3-1-描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？"><a href="#3-1-描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="3.1 描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？"></a>3.1 描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h2><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p><p>![在这里插入图片描述](7. Spring MVC.assets&#x2F;227c781245104db884f02472c354b464.png)</p><h1 id="4-MVC框架"><a href="#4-MVC框架" class="headerlink" title="4 MVC框架"></a>4 MVC框架</h1><h2 id="4-1-MVC是什么？MVC设计模式的好处有哪些"><a href="#4-1-MVC是什么？MVC设计模式的好处有哪些" class="headerlink" title="4.1 MVC是什么？MVC设计模式的好处有哪些"></a>4.1 MVC是什么？MVC设计模式的好处有哪些</h2><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p><p>mvc设计模式的好处</p><ol><li>分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</li><li>有利于系统的并行开发，提升开发效率。</li></ol><h1 id="5-常用注解"><a href="#5-常用注解" class="headerlink" title="5 常用注解"></a>5 常用注解</h1><h2 id="5-1-注解原理是什么"><a href="#5-1-注解原理是什么" class="headerlink" title="5.1 注解原理是什么"></a>5.1 注解原理是什么</h2><p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h2 id="5-2-Spring-MVC常用的注解有哪些？"><a href="#5-2-Spring-MVC常用的注解有哪些？" class="headerlink" title="5.2 Spring MVC常用的注解有哪些？"></a>5.2 Spring MVC常用的注解有哪些？</h2><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p><p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><h2 id="5-3-SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？"><a href="#5-3-SpingMvc中的控制器的注解一般用哪个-有没有别的注解可以替代？" class="headerlink" title="5.3 SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？"></a>5.3 SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？</h2><p>答：一般用@Controller注解,也可以使用@RestController,@RestController注解相当于@ResponseBody ＋ @Controller,表示是表现层,除此之外，一般不用别的注解代替。</p><h2 id="5-4-Controller注解的作用"><a href="#5-4-Controller注解的作用" class="headerlink" title="5.4 @Controller注解的作用"></a>5.4 @Controller注解的作用</h2><p>在Spring MVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在Spring MVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p><p>@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是Spring MVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式：</p><ul><li>在Spring MVC 的配置文件中定义MyController 的bean 对象。</li><li>在Spring MVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。</li></ul><h2 id="5-5-RequestMapping注解的作用"><a href="#5-5-RequestMapping注解的作用" class="headerlink" title="5.5 @RequestMapping注解的作用"></a>5.5 @RequestMapping注解的作用</h2><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。</p><p><strong>value， method</strong></p><ol><li>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</li><li>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</li></ol><p><strong>consumes，produces</strong></p><ol><li>consumes： 指定处理请求的提交内容类型（Content-Type），例如application&#x2F;json, text&#x2F;html;</li><li>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li></ol><p><strong>params，headers</strong></p><ol><li>params： 指定request中必须包含某些参数值是，才让该方法处理。</li><li>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</li></ol><h2 id="5-6-ResponseBody注解的作用"><a href="#5-6-ResponseBody注解的作用" class="headerlink" title="5.6 @ResponseBody注解的作用"></a>5.6 @ResponseBody注解的作用</h2><p>作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。<br>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；</p><h2 id="5-7-PathVariable和-RequestParam的区别"><a href="#5-7-PathVariable和-RequestParam的区别" class="headerlink" title="5.7 @PathVariable和@RequestParam的区别"></a>5.7 @PathVariable和@RequestParam的区别</h2><p>请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value &#x3D; “&#x2F;page&#x2F;{id}”, method &#x3D; RequestMethod.GET)</p><p>@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。</p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h1><h2 id="6-1-Spring-MVC与Struts2区别"><a href="#6-1-Spring-MVC与Struts2区别" class="headerlink" title="6.1 Spring MVC与Struts2区别"></a>6.1 Spring MVC与Struts2区别</h2><p><strong>相同点</strong></p><p>都是基于mvc的表现层框架，都用于web项目的开发。</p><p><strong>不同点</strong></p><ol><li>前端控制器不一样。Spring MVC的前端控制器是servlet：DispatcherServlet。struts2的前端控制器是filter：StrutsPreparedAndExcutorFilter。</li><li>请求参数的接收方式不一样。Spring MVC是使用方法的形参接收请求的参数，基于方法的开发，线程安全，可以设计为单例或者多例的开发，推荐使用单例模式的开发（执行效率更高），默认就是单例开发模式。struts2是通过类的成员变量接收请求的参数，是基于类的开发，线程不安全，只能设计为多例的开发。</li><li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，Spring MVC通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</li><li>与spring整合不一样。Spring MVC是spring框架的一部分，不需要整合。在企业项目中，Spring MVC使用更多一些。</li></ol><h2 id="6-2-Spring-MVC怎么样设定重定向和转发的？"><a href="#6-2-Spring-MVC怎么样设定重定向和转发的？" class="headerlink" title="6.2 Spring MVC怎么样设定重定向和转发的？"></a>6.2 Spring MVC怎么样设定重定向和转发的？</h2><p>答：<br>（1）转发：在返回值前面加”forward:“，譬如”forward:user.do?name&#x3D;method4”</p><p>（2）重定向：在返回值前面加”redirect:“，譬如”redirect:<a href="http://www.baidu.com”/">http://www.baidu.com”</a></p><h2 id="6-3-Spring-MVC怎么和AJAX相互调用的？"><a href="#6-3-Spring-MVC怎么和AJAX相互调用的？" class="headerlink" title="6.3 Spring MVC怎么和AJAX相互调用的？"></a>6.3 Spring MVC怎么和AJAX相互调用的？</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p><p>（1）加入Jackson.jar</p><p>（2）在配置文件中配置json的映射</p><p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p><h2 id="6-4-如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#6-4-如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="6.4 如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>6.4 如何解决POST请求中文乱码问题，GET的又如何处理呢？</h2><p><strong>（1）解决post请求乱码问题：</strong><br>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line"></span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-<span class="number">8</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）get请求中文参数出现乱码解决方法有两个：</strong></p><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ConnectorURIEncoding=<span class="string">&quot;utf-8&quot;</span> connectionTimeout=<span class="string">&quot;20000&quot;</span> port=<span class="string">&quot;8080&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span> redirectPort=<span class="string">&quot;8443&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>②另外一种方法对参数进行重新编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request.getParamter(“userName”).getBytes(“ISO8859-<span class="number">1</span>”),“utf-<span class="number">8</span>”)</span><br></pre></td></tr></table></figure><p>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p><h2 id="6-5-Spring-MVC的异常处理？"><a href="#6-5-Spring-MVC的异常处理？" class="headerlink" title="6.5 Spring MVC的异常处理？"></a>6.5 Spring MVC的异常处理？</h2><p>答：可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p><h2 id="6-6-如果在拦截请求中，我想拦截get方式提交的方法-怎么配置"><a href="#6-6-如果在拦截请求中，我想拦截get方式提交的方法-怎么配置" class="headerlink" title="6.6 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置"></a>6.6 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置</h2><p>答：可以在@RequestMapping注解里面加上method&#x3D;RequestMethod.GET。</p><h2 id="6-7-怎样在方法里面得到Request-或者Session？"><a href="#6-7-怎样在方法里面得到Request-或者Session？" class="headerlink" title="6.7 怎样在方法里面得到Request,或者Session？"></a>6.7 怎样在方法里面得到Request,或者Session？</h2><p>答：直接在方法的形参中声明request,Spring MVC就自动把request对象传入。</p><h2 id="6-8-如果想在拦截的方法里面得到从前台传入的参数-怎么得到？"><a href="#6-8-如果想在拦截的方法里面得到从前台传入的参数-怎么得到？" class="headerlink" title="6.8 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？"></a>6.8 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？</h2><p>答：直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。</p><h2 id="6-9-如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？"><a href="#6-9-如果前台有很多个参数传入-并且这些参数都是一个对象的-那么怎么样快速得到这个对象？" class="headerlink" title="6.9 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？"></a>6.9 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？</h2><p>答：直接在方法中声明这个对象,Spring MVC就自动会把属性赋值到这个对象里面。</p><h2 id="6-10-Spring-MVC中函数的返回值是什么？"><a href="#6-10-Spring-MVC中函数的返回值是什么？" class="headerlink" title="6.10 Spring MVC中函数的返回值是什么？"></a>6.10 Spring MVC中函数的返回值是什么？</h2><p>答：返回值可以有很多类型,有String, ModelAndView。ModelAndView类把视图和数据都合并的一起的，但一般用String比较好。</p><h2 id="6-11-Spring-MVC用什么对象从后台向前台传递数据的？"><a href="#6-11-Spring-MVC用什么对象从后台向前台传递数据的？" class="headerlink" title="6.11 Spring MVC用什么对象从后台向前台传递数据的？"></a>6.11 Spring MVC用什么对象从后台向前台传递数据的？</h2><p>答：通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。</p><h2 id="6-12-怎么样把ModelMap里面的数据放入Session里面？"><a href="#6-12-怎么样把ModelMap里面的数据放入Session里面？" class="headerlink" title="6.12 怎么样把ModelMap里面的数据放入Session里面？"></a>6.12 怎么样把ModelMap里面的数据放入Session里面？</h2><p>答：可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。</p><h2 id="6-13-Spring-MVC里面拦截器是怎么写的"><a href="#6-13-Spring-MVC里面拦截器是怎么写的" class="headerlink" title="6.13 Spring MVC里面拦截器是怎么写的"></a>6.13 Spring MVC里面拦截器是怎么写的</h2><p>有两种写法,一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在Spring MVC的配置文件中配置拦截器即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring MVC的拦截器 --&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;myInterceptor&quot;</span> class=<span class="string">&quot;com.zwp.action.MyHandlerInterceptor&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;!-- 只针对部分请求拦截 --&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:mapping path=<span class="string">&quot;/modelMap.do&quot;</span> /&gt;</span><br><span class="line">       &lt;bean class=<span class="string">&quot;com.zwp.action.MyHandlerInterceptorAdapter&quot;</span> /&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h2 id="6-14-介绍一下-WebApplicationContext"><a href="#6-14-介绍一下-WebApplicationContext" class="headerlink" title="6.14 介绍一下 WebApplicationContext"></a>6.14 介绍一下 WebApplicationContext</h2><p>WebApplicationContext 继承了ApplicationContext 并增加了一些WEB应用必备的特有功能，它不同于一般的ApplicationContext ，因为它能处理主题，并找到被关联的servlet。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.Spring面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/6.%20spring/"/>
      <url>/2022/06/01/javaInterviewQuestions/6.%20spring/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring面试题（2022版）"><a href="#Spring面试题（2022版）" class="headerlink" title="Spring面试题（2022版）"></a>Spring面试题（2022版）</h1><table><thead><tr><th>序列号</th><th>内容</th><th>链接</th></tr></thead><tbody><tr><td>1</td><td>Java基础知识面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124023797">https://blog.csdn.net/qq_43061290/article/details/124023797</a></td></tr><tr><td>2</td><td>Java集合容器面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124043363">https://blog.csdn.net/qq_43061290/article/details/124043363</a></td></tr><tr><td>3</td><td>Java异常面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124078378">https://blog.csdn.net/qq_43061290/article/details/124078378</a></td></tr><tr><td>4</td><td>并发编程面试题 （2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104563">https://blog.csdn.net/qq_43061290/article/details/124104563</a></td></tr><tr><td>5</td><td>JVM面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104514">https://blog.csdn.net/qq_43061290/article/details/124104514</a></td></tr><tr><td>6</td><td>Spring面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124227864">https://blog.csdn.net/qq_43061290/article/details/124227864</a></td></tr><tr><td>7</td><td>Spring MVC面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124337927">https://blog.csdn.net/qq_43061290/article/details/124337927</a></td></tr><tr><td>8</td><td>Spring Boot面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124339493">https://blog.csdn.net/qq_43061290/article/details/124339493</a></td></tr><tr><td>9</td><td>Spring Cloud面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124341152">https://blog.csdn.net/qq_43061290/article/details/124341152</a></td></tr><tr><td>10</td><td>MyBatis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124468306">https://blog.csdn.net/qq_43061290/article/details/124468306</a></td></tr><tr><td>11</td><td>Redis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124473691">https://blog.csdn.net/qq_43061290/article/details/124473691</a></td></tr><tr><td>12</td><td>MySQL数据库面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124427311">https://blog.csdn.net/qq_43061290/article/details/124427311</a></td></tr><tr><td>13</td><td>消息中间件MQ知识点（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124542376">https://blog.csdn.net/qq_43061290/article/details/124542376</a></td></tr><tr><td>14</td><td>ZooKeeper面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124548428">https://blog.csdn.net/qq_43061290/article/details/124548428</a></td></tr><tr><td>15</td><td>架构设计&amp;分布式&amp;数据结构与算法面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124624540">https://blog.csdn.net/qq_43061290/article/details/124624540</a></td></tr><tr><td>16</td><td>计算机网络编程面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124041420">https://blog.csdn.net/qq_43061290/article/details/124041420</a></td></tr></tbody></table><h1 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1 Spring概述"></a>1 Spring概述</h1><h2 id="1-1-什么是Spring"><a href="#1-1-什么是Spring" class="headerlink" title="1.1 什么是Spring"></a>1.1 什么是Spring</h2><p>Spring是一个轻量级Java开发框架，最早有Rod Johnson创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的JavaSE&#x2F;JavaEE full-stack（一站式）轻量级开源框架，为开发Java应用程序提供全面的基础架构支持。Spring负责基础架构，因此Java开发者可以专注于应用程序的开发。</p><p><strong>Spring最根本的使命是解决企业级应用开发的复杂性，即简化Java开发。</strong></p><p>Spring可以做很多事情，它为企业级开发提供给了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是<strong>依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）</strong>。</p><p>为了降低Java开发的复杂性，Spring采取了以下4种关键策略</p><ol><li>基于POJO的轻量级和最小侵入性编程；</li><li>通过依赖注入和面向接口实现松耦合；</li><li>基于切面和惯例进行声明式编程；</li><li>通过切面和模板减少样板式代码。</li></ol><h2 id="1-2-spring框架得设计目标、设计理念和核心"><a href="#1-2-spring框架得设计目标、设计理念和核心" class="headerlink" title="1.2 spring框架得设计目标、设计理念和核心"></a>1.2 spring框架得设计目标、设计理念和核心</h2><p><strong>Spring设计目标</strong>：Spring为开发者提供一个一站式轻量级应用开发平台；</p><p><strong>Spring设计理念</strong>：在JavaEE开发中，支持POJO和JavaBean开发方式，使应用面向接口开发，充分支持OO（面向对象）设计方法；Spring通过IoC容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给IoC容器，实现解耦；</p><p><strong>Spring框架的核心</strong>：IoC容器和AOP模块。通过IoC容器管理POJO对象以及他们之间的耦合关系；通过AOP以动态非侵入的方式增强服务。</p><p>IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</p><h2 id="1-3-Spring的优缺点"><a href="#1-3-Spring的优缺点" class="headerlink" title="1.3 Spring的优缺点"></a>1.3 Spring的优缺点</h2><p><strong>优点</strong></p><ul><li>方便解耦，简化开发<br>Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给Spring管理。</li><li>AOP编程的支持<br>Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</li><li>声明式事务的支持<br>只需要通过配置就可以完成对事务的管理，而无需手动编程。</li><li>方便程序的测试<br>Spring对Junit4支持，可以通过注解方便的测试Spring程序。</li><li>方便集成各种优秀框架<br>Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis等）。</li><li>降低JavaEE API的使用难度<br>Spring对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低。</li></ul><p><strong>缺点</strong></p><ul><li>Spring明明一个很轻量级的框架，却给人感觉大而全</li><li>Spring依赖反射，反射影响性能</li><li>使用门槛升高，入门Spring需要较长时间</li></ul><h2 id="1-4-Spring的应用场景"><a href="#1-4-Spring的应用场景" class="headerlink" title="1.4 Spring的应用场景"></a>1.4 Spring的应用场景</h2><p><strong>应用场景</strong>：JavaEE企业应用开发，包括SSH、SSM等</p><p>Spring价值：</p><ul><li>Spring是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；</li><li>Spring提供一个一致的编程模型，使应用直接使用POJO开发，与运行环境隔离开来；</li><li>Spring推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</li></ul><h2 id="1-5-Spring的组成模块"><a href="#1-5-Spring的组成模块" class="headerlink" title="1.5 Spring的组成模块"></a>1.5 Spring的组成模块</h2><p>Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在<code>核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中</code>。 以下是 Spring 5 的模块结构图：</p><p>![在这里插入图片描述](6. spring.assets&#x2F;101a0fd398334435abf84f301da42f5e.png)</p><ul><li>spring core：提供了框架的基本组成部分，包括控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）功能。</li><li>spring beans：提供了BeanFactory，是工厂模式的一个经典实现，Spring将管理对象称为Bean。</li><li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li><li>spring jdbc：提供了一个JDBC的抽象层，消除了烦琐的JDBC编码和数据库厂商特有的错误代码解析， 用于简化JDBC。</li><li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li><li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li><li>spring test：主要为测试提供支持的，支持使用JUnit或TestNG对Spring组件进行单元测试和集成测试。</li></ul><h2 id="1-6-Spring中应用的设计模式"><a href="#1-6-Spring中应用的设计模式" class="headerlink" title="1.6 Spring中应用的设计模式"></a>1.6 Spring中应用的设计模式</h2><ul><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</li><li>单例模式：Bean默认为单例模式。</li><li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li></ul><h2 id="1-7-详细讲解一下核心容器（spring-context应用上下文-模块"><a href="#1-7-详细讲解一下核心容器（spring-context应用上下文-模块" class="headerlink" title="1.7 详细讲解一下核心容器（spring context应用上下文) 模块"></a>1.7 详细讲解一下核心容器（spring context应用上下文) 模块</h2><p>这是基本的Spring模块，提供spring 框架的基础功能，BeanFactory 是 任何以spring为基础的应用的核心。Spring 框架建立在此模块之上，它使Spring成为一个容器。</p><p>Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从真正的应用代码中分离。最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory ，它根据XML文件中的定义加载beans。该容器从XML 文件读取配置元数据并用它去创建一个完全配置的系统或应用。</p><h2 id="1-8-Spring框架中有哪些不同类型的事件"><a href="#1-8-Spring框架中有哪些不同类型的事件" class="headerlink" title="1.8 Spring框架中有哪些不同类型的事件"></a>1.8 Spring框架中有哪些不同类型的事件</h2><p>Spring 提供了以下5种标准的事件：</p><ol><li>上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。</li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始&#x2F;重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</li></ol><h2 id="1-9-Spring-应用程序有哪些不同组件？"><a href="#1-9-Spring-应用程序有哪些不同组件？" class="headerlink" title="1.9 Spring 应用程序有哪些不同组件？"></a>1.9 Spring 应用程序有哪些不同组件？</h2><p>Spring 应用一般有以下组件：</p><ul><li>接口 - 定义功能。</li><li>Bean 类 - 它包含属性，setter 和 getter 方法，函数等。</li><li>Bean 配置文件 - 包含类的信息以及如何配置它们。</li><li>Spring 面向切面编程（AOP） - 提供面向切面编程的功能。</li><li>用户程序 - 它使用接口。</li></ul><h2 id="1-10-使用-Spring-有哪些方式？"><a href="#1-10-使用-Spring-有哪些方式？" class="headerlink" title="1.10 使用 Spring 有哪些方式？"></a>1.10 使用 Spring 有哪些方式？</h2><p>使用 Spring 有以下方式：</p><ul><li>作为一个成熟的 Spring Web 应用程序。</li><li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li><li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li><li>用于远程使用。</li></ul><h1 id="2-Spring控制反转-IOC"><a href="#2-Spring控制反转-IOC" class="headerlink" title="2 Spring控制反转(IOC)"></a>2 Spring控制反转(IOC)</h1><h2 id="2-1-什么是Spring-IOC-容器？"><a href="#2-1-什么是Spring-IOC-容器？" class="headerlink" title="2.1 什么是Spring IOC 容器？"></a>2.1 什么是Spring IOC 容器？</h2><p>控制反转即IoC (Inversion of Control)，它把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。</p><p>Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p><h2 id="2-2-控制反转-IoC-有什么作用"><a href="#2-2-控制反转-IoC-有什么作用" class="headerlink" title="2.2 控制反转(IoC)有什么作用"></a>2.2 控制反转(IoC)有什么作用</h2><ul><li>管理对象的创建和依赖关系的维护。对象的创建并不是一件简单的事，在对象关系比较复杂时，如果依赖关系需要程序猿来维护的话，那是相当头疼的</li><li>解耦，由容器去维护具体的对象</li><li>托管了类的产生过程，比如我们需要在类的产生过程中做一些处理，最直接的例子就是代理，如果有容器程序可以把这部分处理交给容器，应用程序则无需去关心类是如何完成代理的</li></ul><h2 id="2-3-IOC的优点是什么？"><a href="#2-3-IOC的优点是什么？" class="headerlink" title="2.3 IOC的优点是什么？"></a>2.3 IOC的优点是什么？</h2><ul><li>IOC 或 依赖注入把应用的代码量降到最低。</li><li>它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</li><li>最小的代价和最小的侵入性使松散耦合得以实现。</li><li>IOC容器支持加载服务时的饿汉式初始化和懒加载。</li></ul><h2 id="2-4-Spring-IoC-的实现机制"><a href="#2-4-Spring-IoC-的实现机制" class="headerlink" title="2.4 Spring IoC 的实现机制"></a>2.4 Spring IoC 的实现机制</h2><p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title function_">getInstance</span><span class="params">(String ClassName)</span> &#123;</span><br><span class="line">        Fruit f=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f=(Fruit)Class.forName(ClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        Fruit f=Factory.getInstance(<span class="string">&quot;io.github.dunwu.spring.Apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(f!=<span class="literal">null</span>)&#123;</span><br><span class="line">            f.eat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-Spring-的-IoC支持哪些功能"><a href="#2-5-Spring-的-IoC支持哪些功能" class="headerlink" title="2.5 Spring 的 IoC支持哪些功能"></a>2.5 Spring 的 IoC支持哪些功能</h2><p>Spring 的 IoC 设计支持以下功能：</p><ol><li>依赖注入</li><li>依赖检查</li><li>自动装配</li><li>支持集合</li><li>指定初始化方法和销毁方法</li><li>支持回调某些方法（但是需要实现 Spring 接口，略有侵入）</li></ol><p>其中，最重要的就是依赖注入，从 XML 的配置上说，即 ref 标签。对应 Spring RuntimeBeanReference 对象。</p><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><h2 id="2-6-BeanFactory-和-ApplicationContext有什么区别？"><a href="#2-6-BeanFactory-和-ApplicationContext有什么区别？" class="headerlink" title="2.6 BeanFactory 和 ApplicationContext有什么区别？"></a>2.6 BeanFactory 和 ApplicationContext有什么区别？</h2><p>BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。</p><p><strong>依赖关系</strong></p><p>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p><p>ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul><p><strong>加载方式</strong></p><p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p><p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。</p><p>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。</p><p><strong>创建方式</strong></p><p>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</p><p><strong>注册方式</strong></p><p>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p><h2 id="2-7-Spring-如何设计容器的、BeanFactory和ApplicationContext的关系"><a href="#2-7-Spring-如何设计容器的、BeanFactory和ApplicationContext的关系" class="headerlink" title="2.7 Spring 如何设计容器的、BeanFactory和ApplicationContext的关系"></a>2.7 Spring 如何设计容器的、BeanFactory和ApplicationContext的关系</h2><p>Spring 作者 Rod Johnson 设计了两个接口用以表示容器。</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><p>BeanFactory 简单粗暴，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载&#x2F;刷新所有的 bean。</p><p>当然，除了这两个大接口，还有其他的辅助接口，这里就不介绍他们了。</p><p><strong>BeanFactory和ApplicationContext的关系</strong></p><p>为了更直观的展示 “低级容器” 和 “高级容器” 的关系，这里通过常用的 ClassPathXmlApplicationContext 类来展示整个容器的层级 UML 关系。<br>![在这里插入图片描述](6. spring.assets&#x2F;94d98a757baf443fa616312ef38c87a3.png)</p><p><strong>有点复杂？ 先不要慌，我来解释一下。</strong></p><p>最上面的是 BeanFactory，下面的 3 个绿色的，都是功能扩展接口，这里就不展开讲。</p><p>看下面的隶属 ApplicationContext 粉红色的 “高级容器”，依赖着 “低级容器”，这里说的是依赖，不是继承哦。他依赖着 “低级容器” 的 getBean 功能。而高级容器有更多的功能：支持不同的信息源头，可以访问文件资源，支持应用事件（Observer 模式）。</p><p>通常用户看到的就是 “高级容器”。 但 BeanFactory 也非常够用啦！</p><p>左边灰色区域的是 “低级容器”， 只负载加载 Bean，获取 Bean。容器其他的高级功能是没有的。例如上图画的 refresh 刷新 Bean 工厂所有配置，生命周期事件回调等。</p><p><strong>小结</strong></p><p>说了这么多，不知道你有没有理解Spring IoC？ 这里小结一下：IoC 在 Spring 里，只需要低级容器就可以实现，2 个步骤：</p><p>1、加载配置文件，解析成 BeanDefinition 放在 Map 里。</p><p>2、调用 getBean 的时候，从 BeanDefinition 所属的 Map 里，拿出 Class 对象进行实例化，同时，如果有依赖关系，将递归调用 getBean 方法 —— 完成依赖注入。</p><p><strong>上面就是 Spring 低级容器（BeanFactory）的 IoC。</strong></p><p>至于高级容器 ApplicationContext，他包含了低级容器的功能，当他执行 refresh 模板方法的时候，将刷新整个容器的 Bean。同时其作为高级容器，包含了太多的功能。一句话，他不仅仅是 IoC。他支持不同信息源头，支持 BeanFactory 工具类，支持层级容器，支持访问文件资源，支持事件发布通知，支持接口回调等等。</p><h2 id="2-8-ApplicationContext通常的实现是什么？"><a href="#2-8-ApplicationContext通常的实现是什么？" class="headerlink" title="2.8 ApplicationContext通常的实现是什么？"></a>2.8 ApplicationContext通常的实现是什么？</h2><p><strong>FileSystemXmlApplicationContext</strong> ：此容器从一个XML文件中加载beans的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</p><p><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</p><p><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean。</p><h2 id="2-9-什么是Spring的依赖注入？"><a href="#2-9-什么是Spring的依赖注入？" class="headerlink" title="2.9 什么是Spring的依赖注入？"></a>2.9 什么是Spring的依赖注入？</h2><p>控制反转IoC是一个很大的概念，可以用不同的方式来实现。其主要实现方式有两种：<strong>依赖注入和依赖查找</strong></p><p><strong>依赖注入</strong>：相对于IoC而言，依赖注入(DI)更加准确地描述了IoC的设计理念。所谓依赖注入（Dependency Injection），即组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中。组件不做定位查询，只提供普通的Java方法让容器去决定依赖关系。</p><h2 id="2-10-依赖注入的基本原则"><a href="#2-10-依赖注入的基本原则" class="headerlink" title="2.10 依赖注入的基本原则"></a>2.10 依赖注入的基本原则</h2><p>依赖注入的基本原则是：应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由IoC容器负责，“查找资源”的逻辑应该从应用组件的代码中抽取出来，交给IoC容器负责。容器全权负责组件的装配，它会把符合依赖关系的对象通过属性（JavaBean中的setter）或者是构造器传递给需要的对象。</p><h2 id="2-11-依赖注入有什么优势"><a href="#2-11-依赖注入有什么优势" class="headerlink" title="2.11 依赖注入有什么优势"></a>2.11 依赖注入有什么优势</h2><p>依赖注入之所以更流行是因为它是一种更可取的方式：让容器全权负责依赖查询，受管组件只需要暴露JavaBean的setter方法或者带参数的构造器或者接口，使容器可以在初始化时组装对象的依赖关系。其与依赖查找方式相比，主要优势为：</p><ul><li>查找定位操作与应用代码完全无关。</li><li>不依赖于容器的API，可以很容易地在任何容器以外使用应用对象。</li><li>不需要特殊的接口，绝大多数对象可以做到完全不必依赖容器。</li></ul><h2 id="2-12-有哪些不同类型的依赖注入实现方式？"><a href="#2-12-有哪些不同类型的依赖注入实现方式？" class="headerlink" title="2.12 有哪些不同类型的依赖注入实现方式？"></a>2.12 有哪些不同类型的依赖注入实现方式？</h2><p>依赖注入是时下最流行的IoC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。</p><p><strong>构造器依赖注入</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。<br><strong>Setter方法注入</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</p><h2 id="2-13-构造器依赖注入和-Setter方法注入的区别"><a href="#2-13-构造器依赖注入和-Setter方法注入的区别" class="headerlink" title="2.13 构造器依赖注入和 Setter方法注入的区别"></a>2.13 构造器依赖注入和 Setter方法注入的区别</h2><p>![在这里插入图片描述](6. spring.assets&#x2F;b9b17d2ee0cd437fa1528727d2c3de93.png)</p><h1 id="3-Spring-Beans"><a href="#3-Spring-Beans" class="headerlink" title="3 Spring Beans"></a>3 Spring Beans</h1><h2 id="3-1-什么是Spring-beans？"><a href="#3-1-什么是Spring-beans？" class="headerlink" title="3.1 什么是Spring beans？"></a>3.1 什么是Spring beans？</h2><p>Spring beans 是那些形成Spring应用的主干的java对象。它们被Spring IOC容器初始化，装配，和管理。这些beans通过容器中配置的元数据创建。比如，以XML文件中 的形式定义。</p><h2 id="3-2-一个-Spring-Bean-定义-包含什么？"><a href="#3-2-一个-Spring-Bean-定义-包含什么？" class="headerlink" title="3.2 一个 Spring Bean 定义 包含什么？"></a>3.2 一个 Spring Bean 定义 包含什么？</h2><p>一个Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个bean，它的生命周期详情及它的依赖。</p><h2 id="3-3-如何给Spring-容器提供配置元数据？Spring有几种配置方式"><a href="#3-3-如何给Spring-容器提供配置元数据？Spring有几种配置方式" class="headerlink" title="3.3 如何给Spring 容器提供配置元数据？Spring有几种配置方式"></a>3.3 如何给Spring 容器提供配置元数据？Spring有几种配置方式</h2><p>这里有三种重要的方法给Spring 容器提供配置元数据。</p><ul><li>XML配置文件。</li><li>基于注解的配置。</li><li>基于java的配置。</li></ul><h2 id="3-4-Spring配置文件包含了哪些信息"><a href="#3-4-Spring配置文件包含了哪些信息" class="headerlink" title="3.4 Spring配置文件包含了哪些信息"></a>3.4 Spring配置文件包含了哪些信息</h2><p>Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。</p><h2 id="3-5-Spring基于xml注入bean的几种方式"><a href="#3-5-Spring基于xml注入bean的几种方式" class="headerlink" title="3.5 Spring基于xml注入bean的几种方式"></a>3.5 Spring基于xml注入bean的几种方式</h2><ol><li>Set方法注入；</li><li>构造器注入：①通过index设置参数的位置；②通过type设置参数类型；</li><li>静态工厂注入；</li><li>实例工厂；</li></ol><h2 id="3-6-怎样定义类的作用域？"><a href="#3-6-怎样定义类的作用域？" class="headerlink" title="3.6 怎样定义类的作用域？"></a>3.6 怎样定义类的作用域？</h2><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p><h2 id="3-7-解释Spring支持的几种bean的作用域"><a href="#3-7-解释Spring支持的几种bean的作用域" class="headerlink" title="3.7 解释Spring支持的几种bean的作用域"></a>3.7 解释Spring支持的几种bean的作用域</h2><ul><li>Spring:框架支持以下五种bean的作用域：</li><li>singleton : bean在每个Spring ioc 容器中只有一个实例。</li><li>prototype：一个bean的定义可以有多个实例。</li><li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p>注意： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p><h2 id="3-8-Spring框架中的单例bean是线程安全的吗？"><a href="#3-8-Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="3.8 Spring框架中的单例bean是线程安全的吗？"></a>3.8 Spring框架中的单例bean是线程安全的吗？</h2><p>答：不是，Spring框架中的单例bean不是线程安全的。<br>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><ul><li>有状态就是有数据存储功能。</li><li>无状态就是不会保存数据。</li></ul><h2 id="3-9-Spring如何处理线程并发问题？"><a href="#3-9-Spring如何处理线程并发问题？" class="headerlink" title="3.9 Spring如何处理线程并发问题？"></a>3.9 Spring如何处理线程并发问题？</h2><p>在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域，因为Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程在访问前需要获取锁，没获得锁的线程则需要排队。而ThreadLocal采用了“空间换时间”的方式。</p><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p><h2 id="3-10-解释Spring框架中bean的生命周期"><a href="#3-10-解释Spring框架中bean的生命周期" class="headerlink" title="3.10 解释Spring框架中bean的生命周期"></a>3.10 解释Spring框架中bean的生命周期</h2><p>在传统的Java应用中，bean的生命周期很简单。使用Java关键字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。相比之下，Spring容器中的bean的生命周期就显得相对复杂多了。正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。下图展示了bean装载到Spring应用上下文中的一个典型的生命周期过程。<br>![在这里插入图片描述](6. spring.assets&#x2F;a7fff070dd8246918b2faa1059345d23.png)</p><p>bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。</p><p>正如你所见，在bean准备就绪之前，bean工厂执行了若干启动步骤。</p><p>我们对上图进行详细描述：</p><p>Spring对bean进行实例化；</p><p>Spring将值和bean的引用注入到bean对应的属性中；</p><p>如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p><p>如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p><p>如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p><p>如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用initmethod声明了初始化方法，该方法也会被调用；</p><p>如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p><p>此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p><p>如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p><p>现在你已经了解了如何创建和加载一个Spring容器。但是一个空的容器并没有太大的价值，在你把东西放进去之前，它里面什么都没有。为了从Spring的DI(依赖注入)中受益，我们必须将应用对象装配进Spring容器中。</p><h2 id="3-11-哪些是重要的bean生命周期方法？-你能重载它们吗？"><a href="#3-11-哪些是重要的bean生命周期方法？-你能重载它们吗？" class="headerlink" title="3.11 哪些是重要的bean生命周期方法？ 你能重载它们吗？"></a>3.11 哪些是重要的bean生命周期方法？ 你能重载它们吗？</h2><p>有两个重要的bean 生命周期方法，第一个是setup ， 它是在容器加载bean的时候被调用。第二个方法是 teardown 它是在容器卸载类的时候被调用。</p><p>bean 标签有两个重要的属性（init-method和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。</p><h2 id="3-12-什么是Spring的内部bean？什么是Spring-inner-beans？"><a href="#3-12-什么是Spring的内部bean？什么是Spring-inner-beans？" class="headerlink" title="3.12 什么是Spring的内部bean？什么是Spring inner beans？"></a>3.12 什么是Spring的内部bean？什么是Spring inner beans？</h2><p>在Spring框架中，当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现，内部bean通常是匿名的，它们的Scope一般是prototype。</p><h2 id="3-13-在-Spring中如何注入一个java集合？"><a href="#3-13-在-Spring中如何注入一个java集合？" class="headerlink" title="3.13 在 Spring中如何注入一个java集合？"></a>3.13 在 Spring中如何注入一个java集合？</h2><p>Spring提供以下几种集合的配置元素：</p><p>类型用于注入一列值，允许有相同的值。</p><p>类型用于注入一组值，不允许有相同的值。</p><p>类型用于注入一组键值对，键和值都可以为任意类型。</p><p>类型用于注入一组键值对，键和值都只能为String类型。</p><h2 id="3-14-什么是bean装配？"><a href="#3-14-什么是bean装配？" class="headerlink" title="3.14 什么是bean装配？"></a>3.14 什么是bean装配？</h2><p>装配，或bean 装配是指在Spring 容器中把bean组装到一起，前提是容器需要知道bean的依赖关系，如何通过依赖注入来把它们装配到一起。</p><h2 id="3-15-什么是bean的自动装配？"><a href="#3-15-什么是bean的自动装配？" class="headerlink" title="3.15 什么是bean的自动装配？"></a>3.15 什么是bean的自动装配？</h2><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring 容器能够自动装配相互合作的bean，这意味着容器不需要和配置，能通过Bean工厂自动处理bean之间的协作。这意味着 Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。</p><h2 id="3-16-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？"><a href="#3-16-解释不同方式的自动装配，spring-自动装配-bean-有哪些方式？" class="headerlink" title="3.16 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？"></a>3.16 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？</h2><p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p><p>在Spring框架xml配置中共有5种自动装配：</p><ul><li>no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</li><li>byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。</li><li>byType：通过参数的数据类型进行自动装配。</li><li>constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</li><li>autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</li></ul><h2 id="3-17-使用-Autowired注解自动装配的过程是怎样的？"><a href="#3-17-使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="3.17 使用@Autowired注解自动装配的过程是怎样的？"></a>3.17 使用@Autowired注解自动装配的过程是怎样的？</h2><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，&lt;context:annotation-config &#x2F;&gt;。</p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul><li>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</li><li>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</li><li>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required&#x3D;false。</li></ul><h2 id="3-18-自动装配有哪些局限性？"><a href="#3-18-自动装配有哪些局限性？" class="headerlink" title="3.18 自动装配有哪些局限性？"></a>3.18 自动装配有哪些局限性？</h2><p>自动装配的局限性是：</p><p><strong>重写</strong>：你仍需用 和 配置来定义依赖，意味着总要重写自动装配。<br><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。<br><strong>模糊特性</strong>：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><h2 id="3-19-你可以在Spring中注入一个null-和一个空字符串吗？"><a href="#3-19-你可以在Spring中注入一个null-和一个空字符串吗？" class="headerlink" title="3.19 你可以在Spring中注入一个null 和一个空字符串吗？"></a>3.19 你可以在Spring中注入一个null 和一个空字符串吗？</h2><p>可以。</p><h1 id="4-Spring注解"><a href="#4-Spring注解" class="headerlink" title="4 Spring注解"></a>4 Spring注解</h1><h2 id="4-1-什么是基于Java的Spring注解配置-给一些注解的例子"><a href="#4-1-什么是基于Java的Spring注解配置-给一些注解的例子" class="headerlink" title="4.1 什么是基于Java的Spring注解配置? 给一些注解的例子"></a>4.1 什么是基于Java的Spring注解配置? 给一些注解的例子</h2><p>基于Java的配置，允许你在少量的Java注解的帮助下，进行你的大部分Spring配置而非通过XML文件。</p><p>以@Configuration 注解为例，它用来标记类可以当做一个bean的定义，被Spring IOC容器使用。</p><p>另一个例子是@Bean注解，它表示此方法将要返回一个对象，作为一个bean注册进Spring应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> StudentBean <span class="title function_">myStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-怎样开启注解装配？"><a href="#4-2-怎样开启注解装配？" class="headerlink" title="4.2 怎样开启注解装配？"></a>4.2 怎样开启注解装配？</h2><p>注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置 context:annotation-config&#x2F;元素。</p><h2 id="4-3-Component-Controller-Repository-Service-有何区别？"><a href="#4-3-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="4.3 @Component, @Controller, @Repository, @Service 有何区别？"></a>4.3 @Component, @Controller, @Repository, @Service 有何区别？</h2><p>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</p><p>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h2 id="4-4-Required-注解有什么作用"><a href="#4-4-Required-注解有什么作用" class="headerlink" title="4.4 @Required 注解有什么作用"></a>4.4 @Required 注解有什么作用</h2><p>这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-Autowired-注解有什么作用"><a href="#4-5-Autowired-注解有什么作用" class="headerlink" title="4.5 @Autowired 注解有什么作用"></a>4.5 @Autowired 注解有什么作用</h2><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。@Autowired 注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者具有任意名称和&#x2F;或多个参数的PN方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> string <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-Autowired和-Resource之间的区别"><a href="#4-6-Autowired和-Resource之间的区别" class="headerlink" title="4.6 @Autowired和@Resource之间的区别"></a>4.6 @Autowired和@Resource之间的区别</h2><p>@Autowired可用于：构造函数、成员变量、Setter方法</p><p>@Autowired和@Resource之间的区别</p><p>@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。</p><p>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。</p><h2 id="4-7-Qualifier-注解有什么作用"><a href="#4-7-Qualifier-注解有什么作用" class="headerlink" title="4.7 @Qualifier 注解有什么作用"></a>4.7 @Qualifier 注解有什么作用</h2><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p><h2 id="4-8-RequestMapping-注解有什么用？"><a href="#4-8-RequestMapping-注解有什么用？" class="headerlink" title="4.8 @RequestMapping 注解有什么用？"></a>4.8 @RequestMapping 注解有什么用？</h2><p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类&#x2F;方法。此注释可应用于两个级别：</p><ul><li>类级别：映射请求的 URL</li><li>方法级别：映射 URL 以及 HTTP 请求方法</li></ul><h1 id="5-Spring数据访问"><a href="#5-Spring数据访问" class="headerlink" title="5 Spring数据访问"></a>5 Spring数据访问</h1><h2 id="5-1-解释对象-x2F-关系映射集成模块"><a href="#5-1-解释对象-x2F-关系映射集成模块" class="headerlink" title="5.1 解释对象&#x2F;关系映射集成模块"></a>5.1 解释对象&#x2F;关系映射集成模块</h2><p>Spring 通过提供ORM模块，支持我们在直接JDBC之上使用一个对象&#x2F;关系映射映射(ORM)工具，Spring 支持集成主流的ORM框架，如Hiberate，JDO和 iBATIS，JPA，TopLink，JDO，OJB 。Spring的事务管理同样支持以上所有ORM框架及JDBC。</p><h2 id="5-2-在Spring框架中如何更有效地使用JDBC？"><a href="#5-2-在Spring框架中如何更有效地使用JDBC？" class="headerlink" title="5.2 在Spring框架中如何更有效地使用JDBC？"></a>5.2 在Spring框架中如何更有效地使用JDBC？</h2><p>使用Spring JDBC 框架，资源管理和错误处理的代价都会被减轻。所以开发者只需写statements 和 queries从数据存取数据，JDBC也可以在Spring框架提供的模板类的帮助下更有效地被使用，这个模板叫JdbcTemplate</p><h2 id="5-3-解释JDBC抽象和DAO模块"><a href="#5-3-解释JDBC抽象和DAO模块" class="headerlink" title="5.3 解释JDBC抽象和DAO模块"></a>5.3 解释JDBC抽象和DAO模块</h2><p>通过使用JDBC抽象和DAO模块，保证数据库代码的简洁，并能避免数据库资源错误关闭导致的问题，它在各种不同的数据库的错误信息之上，提供了一个统一的异常访问层。它还利用Spring的AOP 模块给Spring应用中的对象提供事务管理服务。</p><h2 id="5-4-spring-DAO-有什么用？"><a href="#5-4-spring-DAO-有什么用？" class="headerlink" title="5.4 spring DAO 有什么用？"></a>5.4 spring DAO 有什么用？</h2><p>Spring DAO（数据访问对象） 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p><h2 id="5-5-spring-JDBC-API-中存在哪些类？"><a href="#5-5-spring-JDBC-API-中存在哪些类？" class="headerlink" title="5.5 spring JDBC API 中存在哪些类？"></a>5.5 spring JDBC API 中存在哪些类？</h2><ul><li>JdbcTemplate</li><li>SimpleJdbcTemplate</li><li>NamedParameterJdbcTemplate</li><li>SimpleJdbcInsert</li><li>SimpleJdbcCall</li></ul><h2 id="5-6-JdbcTemplate是什么"><a href="#5-6-JdbcTemplate是什么" class="headerlink" title="5.6 JdbcTemplate是什么"></a>5.6 JdbcTemplate是什么</h2><p>JdbcTemplate 类提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p><h2 id="5-7-使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#5-7-使用Spring通过什么方式访问Hibernate？使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="5.7 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？"></a>5.7 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？</h2><p>在Spring中有两种方式访问Hibernate：</p><ul><li>使用 Hibernate 模板和回调进行控制反转</li><li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li></ul><h2 id="5-8-如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"><a href="#5-8-如何通过HibernateDaoSupport将Spring和Hibernate结合起来？" class="headerlink" title="5.8 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？"></a>5.8 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？</h2><p>用Spring的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：</p><ul><li>配置the Hibernate SessionFactory</li><li>继承HibernateDaoSupport实现一个DAO</li><li>在AOP支持的事务中装配</li></ul><h2 id="5-9-Spring支持的事务管理类型，-spring-事务实现方式有哪些？"><a href="#5-9-Spring支持的事务管理类型，-spring-事务实现方式有哪些？" class="headerlink" title="5.9 Spring支持的事务管理类型， spring 事务实现方式有哪些？"></a>5.9 Spring支持的事务管理类型， spring 事务实现方式有哪些？</h2><p>Spring支持两种类型的事务管理：</p><p><strong>编程式事务管理</strong>：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。</p><p><strong>声明式事务管理</strong>：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。</p><h2 id="5-10-Spring事务的实现方式和实现原理"><a href="#5-10-Spring事务的实现方式和实现原理" class="headerlink" title="5.10 Spring事务的实现方式和实现原理"></a>5.10 Spring事务的实现方式和实现原理</h2><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><h2 id="5-11-说一下Spring的事务传播行为"><a href="#5-11-说一下Spring的事务传播行为" class="headerlink" title="5.11 说一下Spring的事务传播行为"></a>5.11 说一下Spring的事务传播行为</h2><p>spring事务的传播行为说的是，当多个事务同时存在的时候，spring如何处理这些事务的行为。</p><blockquote><p>① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<br>③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>④ PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。<br>⑤ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑥ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>⑦ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p></blockquote><h2 id="5-12-说一下-spring-的事务隔离？"><a href="#5-12-说一下-spring-的事务隔离？" class="headerlink" title="5.12 说一下 spring 的事务隔离？"></a>5.12 说一下 spring 的事务隔离？</h2><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ol><li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li><li>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li><li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ol><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p><h2 id="5-13-Spring框架的事务管理有哪些优点？"><a href="#5-13-Spring框架的事务管理有哪些优点？" class="headerlink" title="5.13 Spring框架的事务管理有哪些优点？"></a>5.13 Spring框架的事务管理有哪些优点？</h2><ul><li>为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。</li><li>为编程式事务管理提供了一套简单的API而不是一些复杂的事务API</li><li>支持声明式事务管理。</li><li>和Spring各种数据访问抽象层很好得集成。</li></ul><h2 id="5-14-你更倾向用那种事务管理类型？"><a href="#5-14-你更倾向用那种事务管理类型？" class="headerlink" title="5.14 你更倾向用那种事务管理类型？"></a>5.14 你更倾向用那种事务管理类型？</h2><p>大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h1 id="6-Spring面向切面编程-AOP"><a href="#6-Spring面向切面编程-AOP" class="headerlink" title="6 Spring面向切面编程(AOP)"></a>6 Spring面向切面编程(AOP)</h1><h2 id="6-1-什么是AOP"><a href="#6-1-什么是AOP" class="headerlink" title="6.1 什么是AOP"></a>6.1 什么是AOP</h2><p>OOP(Object-Oriented Programming)面向对象编程，允许开发者定义纵向的关系，但并适用于定义横向的关系，导致了大量代码的重复，而不利于各个模块的重用。</p><p>AOP(Aspect-Oriented Programming)，一般称为面向切面编程，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理等。</p><h2 id="6-2-Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？"><a href="#6-2-Spring-AOP-and-AspectJ-AOP-有什么区别？AOP-有哪些实现方式？" class="headerlink" title="6.2 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？"></a>6.2 Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？</h2><p>AOP实现的关键在于 代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。</p><p>（1）AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</p><p>（2）Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。</p><h2 id="6-3-JDK动态代理和CGLIB动态代理的区别"><a href="#6-3-JDK动态代理和CGLIB动态代理的区别" class="headerlink" title="6.3 JDK动态代理和CGLIB动态代理的区别"></a>6.3 JDK动态代理和CGLIB动态代理的区别</h2><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><ul><li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li><li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li></ul><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p><blockquote><p>InvocationHandler 的 invoke(Object proxy,Method method,Object[] args)：proxy是最终生成的代理实例; method 是被代理目标实例的某个具体方法; args 是被代理目标实例某个方法的具体入参, 在方法反射调用时使用。</p></blockquote><h2 id="6-4-如何理解-Spring-中的代理？"><a href="#6-4-如何理解-Spring-中的代理？" class="headerlink" title="6.4 如何理解 Spring 中的代理？"></a>6.4 如何理解 Spring 中的代理？</h2><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p><p>Advice + Target Object &#x3D; Proxy</p><h2 id="6-5-解释一下Spring-AOP里面的几个名词"><a href="#6-5-解释一下Spring-AOP里面的几个名词" class="headerlink" title="6.5 解释一下Spring AOP里面的几个名词"></a>6.5 解释一下Spring AOP里面的几个名词</h2><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入：</p><ul><li>编译期：切面在目标类编译时被织入。AspectJ的织入编译器是以这种方式织入切面的。</li><li>类加载期：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的加载时织入就支持以这种方式织入切面。</li><li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。</li></ul><h2 id="6-6-Spring在运行时通知对象"><a href="#6-6-Spring在运行时通知对象" class="headerlink" title="6.6 Spring在运行时通知对象"></a>6.6 Spring在运行时通知对象</h2><p>通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。代理封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。</p><h2 id="6-7-Spring只支持方法级别的连接点"><a href="#6-7-Spring只支持方法级别的连接点" class="headerlink" title="6.7 Spring只支持方法级别的连接点"></a>6.7 Spring只支持方法级别的连接点</h2><p>因为Spring基于动态代理，所以Spring只支持方法连接点。Spring缺少对字段连接点的支持，而且它不支持构造器连接点。方法之外的连接点拦截功能，我们可以利用Aspect来补充。</p><h2 id="6-8-在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处"><a href="#6-8-在Spring-AOP-中，关注点和横切关注的区别是什么？在-spring-aop-中-concern-和-cross-cutting-concern-的不同之处" class="headerlink" title="6.8 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处"></a>6.8 在Spring AOP 中，关注点和横切关注的区别是什么？在 spring aop 中 concern 和 cross-cutting concern 的不同之处</h2><p>关注点（concern）是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。</p><p>横切关注点（cross-cutting concern）是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><h2 id="6-9-Spring通知有哪些类型？"><a href="#6-9-Spring通知有哪些类型？" class="headerlink" title="6.9 Spring通知有哪些类型？"></a>6.9 Spring通知有哪些类型？</h2><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用5种类型的通知：</p><ol><li>前置通知（Before）：在目标方法被调用之前调用通知功能；</li><li>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</li><li>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</li><li>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</li><li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br>同一个aspect，不同advice的执行顺序：</li></ol><blockquote><p>①没有异常情况下的执行顺序：<br>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterReturning<br>②有异常情况下的执行顺序：<br>around before advice<br>before advice<br>target method 执行<br>around after advice<br>after advice<br>afterThrowing:异常发生<br>java.lang.RuntimeException: 异常发生</p></blockquote><h2 id="6-10-什么是切面-Aspect？"><a href="#6-10-什么是切面-Aspect？" class="headerlink" title="6.10 什么是切面 Aspect？"></a>6.10 什么是切面 Aspect？</h2><p>aspect 由 pointcount 和 advice 组成，切面是通知和切点的结合。 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.<br>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p><ul><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.<br>可以简单地认为, 使用 @Aspect 注解的类就是切面<br>![在这里插入图片描述](6. spring.assets&#x2F;e7035e8b9f844a619046186c91893ec1.png)</li></ul><h2 id="6-11-解释基于XML-Schema方式的切面实现"><a href="#6-11-解释基于XML-Schema方式的切面实现" class="headerlink" title="6.11 解释基于XML Schema方式的切面实现"></a>6.11 解释基于XML Schema方式的切面实现</h2><p>在这种情况下，切面由常规类以及基于XML的配置实现。</p><h2 id="6-12-解释基于注解的切面实现"><a href="#6-12-解释基于注解的切面实现" class="headerlink" title="6.12 解释基于注解的切面实现"></a>6.12 解释基于注解的切面实现</h2><p>在这种情况下(基于@AspectJ的实现)，涉及到的切面声明的风格与带有java5标注的普通java类一致。</p><h2 id="6-13-有几种不同类型的自动代理？"><a href="#6-13-有几种不同类型的自动代理？" class="headerlink" title="6.13 有几种不同类型的自动代理？"></a>6.13 有几种不同类型的自动代理？</h2><p>BeanNameAutoProxyCreator</p><p>DefaultAdvisorAutoProxyCreator</p><p>Metadata autoproxying</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.Java虚拟机（JVM）面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/5.%20JVM/"/>
      <url>/2022/06/01/javaInterviewQuestions/5.%20JVM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java虚拟机（JVM）面试题（2022版）"><a href="#Java虚拟机（JVM）面试题（2022版）" class="headerlink" title="Java虚拟机（JVM）面试题（2022版）"></a>Java虚拟机（JVM）面试题（2022版）</h1><h2 id="1-java内存区域"><a href="#1-java内存区域" class="headerlink" title="1 java内存区域"></a>1 java内存区域</h2><h2 id="1-1-JVM的主要组成部分及其功能"><a href="#1-1-JVM的主要组成部分及其功能" class="headerlink" title="1.1 JVM的主要组成部分及其功能"></a>1.1 JVM的主要组成部分及其功能</h2><p>![在这里插入图片描述](5. JVM.assets&#x2F;7d73f83b29204542b979aa3de9452f28.png)</p><p>JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。</p><ul><li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li><li>Execution engine（执行引擎）：执行classes中的指令。</li><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li></ul><p><strong>作用</strong> ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><p><strong>下面是Java程序运行机制详细说明</strong></p><p><strong>Java程序运行机制步骤</strong></p><ol><li>首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；</li><li>再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；</li><li>运行字节码的工作是由解释器(java命令)来完成的。</li></ol><p>![在这里插入图片描述](5. JVM.assets&#x2F;799a9dc532bd4506983fd702b1dff0c5.png)</p><p>从上图可以看，java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。</p><p>其实可以一句话来解释：类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p><h2 id="1-2-说一下JVM的运行时数据区"><a href="#1-2-说一下JVM的运行时数据区" class="headerlink" title="1.2 说一下JVM的运行时数据区"></a>1.2 说一下JVM的运行时数据区</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：<br>![在这里插入图片描述](5. JVM.assets&#x2F;e4d3a478b00e43298a7d9bedb1133fe6.png)</p><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p><ul><li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li><li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li><li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li><li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li></ul><h2 id="1-3-深拷贝与浅拷贝"><a href="#1-3-深拷贝与浅拷贝" class="headerlink" title="1.3 深拷贝与浅拷贝"></a>1.3 深拷贝与浅拷贝</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p><p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p><p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。</p><p>浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。</p><p>深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。</p><h2 id="1-4-说一下堆栈的区别"><a href="#1-4-说一下堆栈的区别" class="headerlink" title="1.4 说一下堆栈的区别"></a>1.4 说一下堆栈的区别</h2><p><strong>物理地址</strong></p><p>堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）</p><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p><p><strong>内存分别</strong></p><p>堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。<br>栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。</p><p><strong>存放的内容</strong></p><p>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储<br>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</p><p>PS：</p><ol><li>静态变量放在方法区</li><li>静态的对象还是放在堆。</li></ol><p>程序的可见度</p><p>堆对于整个应用程序都是共享、可见的。<br>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p><h2 id="1-5-队列与栈的区别"><a href="#1-5-队列与栈的区别" class="headerlink" title="1.5 队列与栈的区别"></a>1.5 队列与栈的区别</h2><p>队列和栈都是被用来预存储数据的。</p><ul><li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li><li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li><li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li></ul><h2 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2 HotSpot虚拟机对象探秘"></a>2 HotSpot虚拟机对象探秘</h2><h2 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h2><p>说到对象的创建，首先让我们看看 Java 中提供的几种对象创建方式：</p><table><thead><tr><th>Header</th><th>解释</th></tr></thead><tbody><tr><td>使用new关键字</td><td>调用了构造函数</td></tr><tr><td>使用Class的newInstance方法</td><td>调用了构造函数</td></tr><tr><td>使用Constructor类的newInstance方法</td><td>调用了构造函数</td></tr><tr><td>使用clone方法</td><td>没有调用了构造函数</td></tr><tr><td>使用反序列化</td><td>没有调用了构造函数</td></tr></tbody></table><p>下面是对象创建的主要流程:<br>![在这里插入图片描述](5. JVM.assets&#x2F;581d4b06a02445d29f4f1576426bc593.png)</p><p>虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行方法。</p><h2 id="2-2-为对象分配内存"><a href="#2-2-为对象分配内存" class="headerlink" title="2.2 为对象分配内存"></a>2.2 为对象分配内存</h2><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：</p><ul><li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li><li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li></ul><p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p>![在这里插入图片描述](5. JVM.assets&#x2F;cc2b0b89df5f4f4680b0cebb724c76f3.png)</p><h2 id="2-3-处理并发安全问题"><a href="#2-3-处理并发安全问题" class="headerlink" title="2.3 处理并发安全问题"></a>2.3 处理并发安全问题</h2><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p><ul><li>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+&#x2F;-UserTLAB参数来设定虚拟机是否使用TLAB。<br>![在这里插入图片描述](5. JVM.assets&#x2F;95fc05cca7b045538fc4e514a64445a1.png)</li></ul><h2 id="2-4-对象的访问定位"><a href="#2-4-对象的访问定位" class="headerlink" title="2.4 对象的访问定位"></a>2.4 对象的访问定位</h2><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有 句柄 和 直接指针 两种方式。</p><blockquote><p><strong>指针</strong>： 指向对象，代表一个对象在内存中的起始地址。<br><strong>句柄</strong>： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p></blockquote><p><strong>句柄访问</strong><br>Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息，具体构造如下图所示：<br>![在这里插入图片描述](5. JVM.assets&#x2F;4c451a7b1a5c461eb564a8dddf85afa1.png)</p><p>优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。</p><p><strong>直接指针</strong><br>如果使用直接指针访问，引用 中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。</p><p><strong>优势</strong>：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p><h2 id="3-内存溢出异常"><a href="#3-内存溢出异常" class="headerlink" title="3 内存溢出异常"></a>3 内存溢出异常</h2><h2 id="3-1-Java会存在内存泄漏吗"><a href="#3-1-Java会存在内存泄漏吗" class="headerlink" title="3.1 Java会存在内存泄漏吗"></a>3.1 Java会存在内存泄漏吗</h2><p>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p><p>但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h2><h2 id="4-1-简述Java垃圾回收机制"><a href="#4-1-简述Java垃圾回收机制" class="headerlink" title="4.1 简述Java垃圾回收机制"></a>4.1 简述Java垃圾回收机制</h2><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h2 id="4-2-GC是什么？为什么要GC"><a href="#4-2-GC是什么？为什么要GC" class="headerlink" title="4.2 GC是什么？为什么要GC"></a>4.2 GC是什么？为什么要GC</h2><p>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存</p><p>回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动</p><p>回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><h2 id="4-3-垃圾回收的优点和原理。并考虑2种回收机制"><a href="#4-3-垃圾回收的优点和原理。并考虑2种回收机制" class="headerlink" title="4.3 垃圾回收的优点和原理。并考虑2种回收机制"></a>4.3 垃圾回收的优点和原理。并考虑2种回收机制</h2><p>java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。</p><p>由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。</p><p>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p><p>垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p><p>程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。</p><p>垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。</p><h2 id="4-4-垃圾回收器的基本原理是什么？"><a href="#4-4-垃圾回收器的基本原理是什么？" class="headerlink" title="4.4 垃圾回收器的基本原理是什么？"></a>4.4 垃圾回收器的基本原理是什么？</h2><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><p>可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h2 id="4-5-Java-中都有哪些引用类型？"><a href="#4-5-Java-中都有哪些引用类型？" class="headerlink" title="4.5 Java 中都有哪些引用类型？"></a>4.5 Java 中都有哪些引用类型？</h2><ul><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ul><h2 id="4-6-怎么判断对象是否可以被回收？"><a href="#4-6-怎么判断对象是否可以被回收？" class="headerlink" title="4.6 怎么判断对象是否可以被回收？"></a>4.6 怎么判断对象是否可以被回收？</h2><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p><p>一般有两种方法来判断：</p><ul><li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h2 id="4-7-在Java中，对象什么时候可以被垃圾回收"><a href="#4-7-在Java中，对象什么时候可以被垃圾回收" class="headerlink" title="4.7 在Java中，对象什么时候可以被垃圾回收"></a>4.7 在Java中，对象什么时候可以被垃圾回收</h2><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。<br>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。</p><h2 id="4-8-JVM中的永久代中会发生垃圾回收吗"><a href="#4-8-JVM中的永久代中会发生垃圾回收吗" class="headerlink" title="4.8 JVM中的永久代中会发生垃圾回收吗"></a>4.8 JVM中的永久代中会发生垃圾回收吗</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p><h2 id="4-9-说一下-JVM-有哪些垃圾回收算法？"><a href="#4-9-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="4.9 说一下 JVM 有哪些垃圾回收算法？"></a>4.9 说一下 JVM 有哪些垃圾回收算法？</h2><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><p><strong>标记-清除算法</strong><br>标记无用对象，然后进行清除回收。</p><p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p><ul><li>标记阶段：标记出可以回收的对象。</li><li>清除阶段：回收被标记的对象所占用的空间。<br>标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。</li></ul><p><strong>优点</strong>：实现简单，不需要对象进行移动。</p><p><strong>缺点</strong>：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。</p><p>标记-清除算法的执行的过程如下图所示<br>![在这里插入图片描述](5. JVM.assets&#x2F;bf8a353008044b3ba4d7742fbb977ae2.png)</p><p><strong>复制算法</strong></p><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。</p><p><strong>优点</strong>：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p><p><strong>缺点</strong>：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</p><p>复制算法的执行过程如下图所示<br>![在这里插入图片描述](5. JVM.assets&#x2F;cfeaaac97a85413c904c6c612d4eabee.png)</p><p><strong>标记-整理算法</strong></p><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。</p><p>优点：解决了标记-清理算法存在的内存碎片问题。</p><p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。</p><p>标记-整理算法的执行过程如下图所示<br>![在这里插入图片描述](5. JVM.assets&#x2F;e0982dfee4644099bd8725742c4802e8.png)</p><p><strong>分代收集算法</strong></p><p>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括<strong>年轻代、老年代 和 永久代</strong>，如图所示：</p><p>![在这里插入图片描述](5. JVM.assets&#x2F;c09ce8d684fb4d96bccb4e894609db26.png)</p><h2 id="4-10-说一下-JVM-有哪些垃圾回收器？"><a href="#4-10-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="4.10 说一下 JVM 有哪些垃圾回收器？"></a>4.10 说一下 JVM 有哪些垃圾回收器？</h2><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用。<br>![在这里插入图片描述](5. JVM.assets&#x2F;1744e1be7e3449ccacc1937a13f951b9.png)</p><ul><li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li><li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li><li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D; 用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li><li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li><li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li><li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li><li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li></ul><h2 id="4-11-详细介绍一下-CMS-垃圾回收器？"><a href="#4-11-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="4.11 详细介绍一下 CMS 垃圾回收器？"></a>4.11 详细介绍一下 CMS 垃圾回收器？</h2><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p><h2 id="4-12-新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#4-12-新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="4.12 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>4.12 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h2><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1<br>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li></ul><h2 id="4-13-简述分代垃圾回收器是怎么工作的？"><a href="#4-13-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="4.13 简述分代垃圾回收器是怎么工作的？"></a>4.13 简述分代垃圾回收器是怎么工作的？</h2><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是 2&#x2F;3。</p><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p><ul><li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li><li>清空 Eden 和 From Survivor 分区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ul><p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p><p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p><h2 id="5-内存分配策略"><a href="#5-内存分配策略" class="headerlink" title="5 内存分配策略"></a>5 内存分配策略</h2><h2 id="5-1-简述java内存分配与回收策率以及Minor-GC和Major-GC"><a href="#5-1-简述java内存分配与回收策率以及Minor-GC和Major-GC" class="headerlink" title="5.1 简述java内存分配与回收策率以及Minor GC和Major GC"></a>5.1 简述java内存分配与回收策率以及Minor GC和Major GC</h2><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p><p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p><p>对象优先在 Eden 区分配<br>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC&#x2F;Full GC。</p><ul><li>Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li><li>Major GC&#x2F;Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。<br>大对象直接进入老年代</li></ul><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</p><p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p><p><strong>长期存活对象将进入老年代</strong></p><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p><h2 id="6-虚拟机类加载机制"><a href="#6-虚拟机类加载机制" class="headerlink" title="6 虚拟机类加载机制"></a>6 虚拟机类加载机制</h2><h2 id="6-1-简述java类加载机制"><a href="#6-1-简述java类加载机制" class="headerlink" title="6.1 简述java类加载机制?"></a>6.1 简述java类加载机制?</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p><h2 id="6-2-描述一下JVM加载Class文件的原理机制"><a href="#6-2-描述一下JVM加载Class文件的原理机制" class="headerlink" title="6.2 描述一下JVM加载Class文件的原理机制"></a>6.2 描述一下JVM加载Class文件的原理机制</h2><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种 ：</p><p>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p><p>2.显式装载， 通过class.forname()等方法，显式加载需要的类</p><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h2 id="6-3-什么是类加载器，类加载器有哪些"><a href="#6-3-什么是类加载器，类加载器有哪些" class="headerlink" title="6.3 什么是类加载器，类加载器有哪些?"></a>6.3 什么是类加载器，类加载器有哪些?</h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。</p><p>主要有一下四种类加载器:</p><ol><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。</li></ol><h2 id="6-4-说一下类装载的执行过程？"><a href="#6-4-说一下类装载的执行过程？" class="headerlink" title="6.4 说一下类装载的执行过程？"></a>6.4 说一下类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h2 id="6-5-什么是双亲委派模型？"><a href="#6-5-什么是双亲委派模型？" class="headerlink" title="6.5 什么是双亲委派模型？"></a>6.5 什么是双亲委派模型？</h2><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。<br>![在这里插入图片描述](5. JVM.assets&#x2F;0c1b05509b484fbdb549b73ad5488b8c.png)</p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h2 id="5-7-JVM调优"><a href="#5-7-JVM调优" class="headerlink" title="5.7 JVM调优"></a>5.7 JVM调优</h2><h2 id="7-1-说一下-JVM-调优的工具？"><a href="#7-1-说一下-JVM-调优的工具？" class="headerlink" title="7.1 说一下 JVM 调优的工具？"></a>7.1 说一下 JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h1 id="7-2-常用的-JVM-调优的参数都有哪些？"><a href="#7-2-常用的-JVM-调优的参数都有哪些？" class="headerlink" title="7.2 常用的 JVM 调优的参数都有哪些？"></a>7.2 常用的 JVM 调优的参数都有哪些？</h1><ul><li>Xms2g：初始化推大小为 2g；</li><li>Xmx2g：堆最大内存为 2g；</li><li>XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；</li><li>XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；</li><li>XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li><li>XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li><li>XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li><li>XX:+PrintGC：开启打印 gc 信息；</li><li>XX:+PrintGCDetails：打印 gc 详细信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.并发编程面试题 （2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/4.%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/06/01/javaInterviewQuestions/4.%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并发编程面试题-（2022版）"><a href="#并发编程面试题-（2022版）" class="headerlink" title="并发编程面试题 （2022版）"></a>并发编程面试题 （2022版）</h1><h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><h2 id="1-1-并发编程的优缺点"><a href="#1-1-并发编程的优缺点" class="headerlink" title="1.1 并发编程的优缺点"></a>1.1 并发编程的优缺点</h2><p>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如<strong>：内存泄漏、上下文切换、线程安全、死锁</strong>等问题。</p><p><strong>为什么要使用并发编程（并发编程的优点）</strong></p><ul><li>充分利用多核CPU的计算能力：通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升</li><li>方便进行业务拆分，提升系统并发能力和性能：在特殊的业务场景下，先天的就适合于并发编程。现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。</li></ul><p><strong>并发编程有什么缺点</strong></p><p>并发编程的目的就是为了能提高程序的执行效率，提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如<strong>：内存泄漏、上下文切换、线程安全、死锁</strong>等问题。</p><p><strong>并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</strong><br>并发编程三要素（线程的安全性问题体现在）：</p><ul><li>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</li><li>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</li></ul><p><strong>出现线程安全问题的原因：</strong></p><ul><li>线程切换带来的原子性问题</li><li>缓存导致的可见性问题</li><li>编译优化带来的有序性问题</li></ul><p><strong>解决办法：</strong></p><ul><li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li><li>synchronized、volatile、LOCK，可以解决可见性问题</li><li>Happens-Before 规则可以解决有序性问题</li></ul><p><strong>并行和并发有什么区别？</strong></p><ul><li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li><li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的“同时进行”。</li><li>串行：有n个任务，由一个线程按顺序执行。由于任务、方法都在一个线程执行所以不存在线程不安全情况，也就不存在临界区的问题。</li></ul><p><strong>做一个形象的比喻：</strong></p><p>并发 &#x3D; 两个队列和一台咖啡机。</p><p>并行 &#x3D; 两个队列和两台咖啡机。</p><p>串行 &#x3D; 一个队列和一台咖啡机。</p><p><strong>什么是多线程，多线程的优劣？</strong></p><p>多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。</p><p><strong>多线程的好处：</strong></p><p>可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p><p>多线程的劣势：</p><ul><li>线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；</li><li>多线程需要协调和管理，所以需要 CPU 时间跟踪线程；</li><li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。</li></ul><h2 id="1-2-线程和进程区别"><a href="#1-2-线程和进程区别" class="headerlink" title="1.2 线程和进程区别"></a>1.2 线程和进程区别</h2><p><strong>什么是线程和进程?</strong></p><p><strong>进程</strong><br>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p><strong>线程</strong><br>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p><strong>进程与线程的区别</strong></p><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><ul><li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li><li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</li><li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li><li>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</li></ul><p><strong>什么是上下文切换?</strong></p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。<br>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><p><strong>守护线程和用户线程有什么区别呢？</strong></p><p>守护线程和用户线程</p><ul><li>用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程</li><li>守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作</li></ul><p>main 函数所在的线程就是一个用户线程啊，main 函数启动的同时在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。</p><p>比较明显的区别之一是用户线程结束，JVM 退出，不管这个时候有没有守护线程运行。而守护线程不会影响 JVM 的退出。</p><p><strong>注意事项：</strong></p><ol><li>setDaemon(true)必须在start()方法前执行，否则会抛出 IllegalThreadStateException 异常</li><li>在守护线程中产生的新线程也是守护线程</li><li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li><li>守护 (Daemon) 线程中不能依靠 finally 块的内容来确保执行关闭或清理资源的逻辑。因为我们上面也说过了一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作，所以守护 (Daemon) 线程中的 finally 语句块可能无法被执行。</li></ol><p>如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？<br>windows上面用任务管理器看，linux下可以用 top 这个工具看。</p><ol start="5"><li>找出cpu耗用厉害的进程pid， 终端执行top命令，然后按下shift+p 查找出cpu利用最厉害的pid号</li><li>根据上面第一步拿到的pid号，top -H -p pid 。然后按下shift+p，查找出cpu利用率最厉害的线程号，比如top -H -p 1328</li><li>将获取到的线程号转换成16进制，去百度转换一下就行</li><li>使用jstack工具将进程信息打印输出，jstack pid号 &gt; &#x2F;tmp&#x2F;t.dat，比如jstack 31365 &gt; &#x2F;tmp&#x2F;t.dat</li><li>编辑&#x2F;tmp&#x2F;t.dat文件，查找线程号对应的信息</li></ol><p><strong>什么是线程死锁</strong></p><p>百度百科：死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。<br>![在这里插入图片描述](4. 并发编程.assets&#x2F;31b4c05fef7a48e2ba3e637a4ca533ef.png)</p><p>下面通过一个例子来说明线程死锁，代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLockDemo &#123;</span><br><span class="line">    private static Object resource1 = new Object();//资源 1</span><br><span class="line">    private static Object resource2 = new Object();//资源 2</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.<span class="built_in">sleep</span>(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                synchronized (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.<span class="built_in">sleep</span>(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                synchronized (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000)；让线程 A 休眠 1s 为的是让线程 B 得到CPU执行权，然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p><p><strong>形成死锁的四个必要条件是什么</strong></p><ul><li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放</li><li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</li></ul><p><strong>如何避免线程死锁</strong></p><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong><br>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong><br>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong><br>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong><br>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br></pre></td></tr></table></figure><p><strong>我们分析一下上面的代码为什么避免了死锁的发生?</strong></p><p>线程 1 首先获得到 resource1 的监视器锁，这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><h2 id="1-3-创建线程的四种方式"><a href="#1-3-创建线程的四种方式" class="headerlink" title="1.3 创建线程的四种方式"></a>1.3 创建线程的四种方式</h2><p><strong>创建线程有哪几种方式？</strong></p><p>创建线程有四种方式：</p><ul><li>继承 Thread 类；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>使用 Executors 工具类创建线程池</li></ul><p><strong>继承 Thread 类</strong></p><p>步骤</p><ol><li>定义一个Thread类的子类，重写run方法，将相关逻辑实现，run()方法就是线程要执行的业务逻辑方法</li><li>创建自定义的线程子类对象</li><li>调用子类实例的star()方法来启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法正在执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); </span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main <span class="title function_">main</span><span class="params">()</span>方法执行结束</span><br><span class="line">Thread-<span class="number">0</span> run()方法正在执行...</span><br></pre></td></tr></table></figure><p><strong>实现 Runnable 接口</strong></p><p>步骤</p><p>1.定义Runnable接口实现类MyRunnable，并重写run()方法<br>2.创建MyRunnable实例myRunnable，以myRunnable作为target创建Thead对象，该Thread对象才是真正的线程对象<br>3.调用线程对象的start()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main <span class="title function_">main</span><span class="params">()</span>方法执行完成</span><br><span class="line">Thread-<span class="number">0</span> run()方法执行中...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实现 Callable 接口</strong></p><p>步骤</p><ol><li>创建实现Callable接口的类myCallable</li><li>以myCallable为参数创建FutureTask对象</li><li>将FutureTask作为参数创建Thread对象</li><li>调用线程对象的start()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; call()方法执行中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;返回结果 &quot;</span> + futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> call()方法执行中...</span><br><span class="line">返回结果 <span class="number">1</span></span><br><span class="line">main <span class="title function_">main</span><span class="params">()</span>方法执行完成</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用 Executors 工具类创建线程池</strong></p><p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。<br>主要有newFixedThreadPool，newCachedThreadPool，newSingleThreadExecutor，newScheduledThreadPool，后续详细介绍这四种线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleThreadExecutorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">runnableTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.execute(runnableTest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;线程任务开始执行&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果<br>线程任务开始执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> is running...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> is running...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> is running...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> is running...</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> is running...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说一下 runnable 和 callable 有什么区别？</strong><br>相同点</p><ol><li>都是接口</li><li>都可以编写多线程程序</li><li>都采用Thread.start()启动线程</li></ol><p>主要区别</p><ul><li>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息</li></ul><p>注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p><p><strong>线程的 run()和 start()有什么区别？</strong></p><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p><p><strong>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</strong></p><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p><p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><p><strong>什么是 Callable 和 Future?</strong></p><p>Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p><p>Future 接口表示异步任务，是一个可能还没有完成的异步任务的结果。所以说 Callable用于产生结果，Future 用于获取结果。</p><p><strong>什么是 FutureTask</strong></p><p>FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。一个 FutureTask 对象可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。</p><h2 id="1-4-线程的状态和基本操作"><a href="#1-4-线程的状态和基本操作" class="headerlink" title="1.4 线程的状态和基本操作"></a>1.4 线程的状态和基本操作</h2><p><strong>说说线程的生命周期及五种基本状态？</strong><br>![在这里插入图片描述](4. 并发编程.assets&#x2F;e5db6add6aad471eb1595dee549000db.png)</p><ol><li>新建(new)：新创建了一个线程对象。</li><li>可运行(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。</li><li>运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</li><li>阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。</li></ol><p><strong>阻塞的情况分三种：</strong></p><p>(一). 等待阻塞：运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；<br>(二). 同步阻塞：线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；<br>(三). 其他阻塞: 通过调用线程的 sleep()或 join()或发出了 I&#x2F;O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。<br>\5. 死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><p><strong>Java 中用到的线程调度算法是什么？</strong></p><p>计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</p><p>有两种调度模型：分时调度模型和抢占式调度模型。</p><p>分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p><p>Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。</p><p><strong>线程的调度策略</strong><br>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：</p><p>（1）线程体中调用了 yield 方法让出了对 cpu 的占用权利<br>（2）线程体中调用了 sleep 方法使线程进入睡眠状态<br>（3）线程由于 IO 操作受到阻塞<br>（4）另外一个更高优先级线程出现<br>（5）在支持时间片的系统中，该线程的时间片用完</p><p><strong>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</strong></p><p>线程调度器是一个操作系统服务，它负责为 Runnable 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</p><p>时间分片是指将可用的 CPU 时间分配给可用的 Runnable 线程的过程。分配 CPU 时间可以基于线程优先级或者线程等待的时间。</p><p>线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p><p><strong>请说出与线程同步以及线程调度相关的方法。</strong></p><p>（1） wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；<br>（2）sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；<br>（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；<br>（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p><p><strong>sleep() 和 wait() 有什么区别？</strong></p><p>两者都可以暂停线程的执行</p><ul><li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li><li>是否释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用途不同：Wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li><li>用法不同：wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</li></ul><p><strong>你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</strong></p><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">    <span class="comment">//  判断条件谓词是否得到满足</span></span><br><span class="line">    <span class="keyword">while</span>(!locked) &#123;</span><br><span class="line">        <span class="comment">//  等待唤醒</span></span><br><span class="line">        monitor.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  处理其他的业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</strong></p><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p><p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p><p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p><p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p><p><strong>为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</strong></p><p>当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><p><strong>Thread 类中的 yield 方法有什么作用？</strong></p><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。</p><p>当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。</p><p><strong>为什么 Thread 类的 sleep()和 yield ()方法是静态的？</strong></p><p>Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><p><strong>线程的 sleep()方法和 yield()方法有什么区别？</strong><br>（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</p><p>（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</p><p>（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</p><p>（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。</p><p><strong>如何停止一个正在运行的线程？</strong></p><p>在java中有以下3种方法可以终止正在运行的线程：</p><ol><li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</li><li>使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</li><li>使用interrupt方法中断线程。</li></ol><p><strong>Java 中 interrupted 和 isInterrupted 方法的区别？</strong></p><ul><li>interrupt：用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</li></ul><p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><ul><li>interrupted：是静态方法，查看当前中断信号是true还是false并且清除中断信号。如果一个线程被中断了，第一次调用 interrupted 则返回 true，第二次和后面的就返回 false 了。</li><li>isInterrupted：查看当前中断信号是true还是false</li></ul><p><strong>什么是阻塞式方法？</strong></p><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p><p><strong>Java 中你怎样唤醒一个阻塞的线程？</strong></p><p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p><p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p><p><strong>notify() 和 notifyAll() 有什么区别？</strong></p><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p><p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><p><strong>如何在两个线程间共享数据？</strong></p><ul><li>在两个线程间共享变量即可实现共享。</li><li>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</li></ul><p><strong>Java 如何实现多线程之间的通讯和协作？</strong></p><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p><p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p><p><strong>Java中线程通信协作的最常见的两种方式：</strong></p><p>一.syncrhoized加锁的线程的Object类的wait()&#x2F;notify()&#x2F;notifyAll()<br>二.ReentrantLock类加锁的线程的Condition类的await()&#x2F;signal()&#x2F;signalAll()</p><p><strong>线程间直接的数据交换：</strong></p><p>三.通过管道进行线程间通信：1）字节流；2）字符流</p><p><strong>同步方法和同步块，哪个是更好的选择？</strong></p><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p><p>请知道一条原则：同步的范围越小越好。</p><p><strong>什么是线程同步和线程互斥，有哪几种实现方式？</strong></p><p>当一个线程对共享的数据进行操作时，应使之成为一个”原子操作“，即在没有完成相关操作之前，不允许其他线程打断它，否则，就会破坏数据的完整性，必然会得到错误的处理结果，这就是线程的同步。</p><p>在多线程应用中，考虑不同线程之间的数据同步和防止死锁。当两个或多个线程之间同时等待对方释放资源的时候就会形成线程之间的死锁。为了防止死锁的发生，需要通过同步来实现线程安全。</p><p>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。<br>线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p><p><strong>实现线程同步的方法</strong></p><ul><li>同步代码方法：sychronized 关键字修饰的方法</li><li>同步代码块：sychronized 关键字修饰的代码块</li><li>使用特殊变量域volatile实现线程同步：volatile关键字为域变量的访问提供了一种免锁机制</li><li>使用重入锁实现线程同步：reentrantlock类是可冲入、互斥、实现了lock接口的锁他与sychronized方法具有相同的基本行为和语义</li></ul><p><strong>在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</strong></p><p>在 java 虚拟机中，每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁。</p><p>一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码<br>另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案</p><p><strong>如果你提交任务时，线程池队列已满，这时会发生什么</strong></p><p>这里区分一下：</p><p>（1）如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务</p><p>（2）如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy</p><p><strong>什么叫线程安全？servlet 是线程安全吗?</strong></p><p>线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p><p>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p><p>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。</p><p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p><p>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</p><p><strong>在 Java 程序中怎么保证多线程的运行安全？</strong></p><p>方法一：使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger</p><p>方法二：使用自动锁 synchronized。</p><p>方法三：使用手动锁 Lock。</p><p>手动锁 Java 示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>你对线程优先级的理解是什么？</strong></p><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。</p><p>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><p><strong>线程类的构造方法、静态块是被哪个线程调用的</strong></p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被 new这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设 Thread2 中 new 了Thread1，main 函数中 new 了 Thread2，那么：</p><p>（1）Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run()方法是Thread2 自己调用的</p><p>（2）Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run()方法是Thread1 自己调用的</p><p><strong>Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</strong></p><p>Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。<br>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。</p><p>在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。</p><p><strong>一个线程运行时发生异常会怎样？</strong><br>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler()来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException()方法进行处理。</p><p><strong>Java 线程数过多会造成什么异常？</strong></p><ul><li>线程的生命周期开销非常高</li><li>消耗过多的 CPU<br>资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</li><li>降低稳定性JVM<br>在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</li></ul><h1 id="2-并发理论"><a href="#2-并发理论" class="headerlink" title="2 并发理论"></a>2 并发理论</h1><h2 id="2-1-Java内存模型"><a href="#2-1-Java内存模型" class="headerlink" title="2.1 Java内存模型"></a>2.1 Java内存模型</h2><p><strong>Java中垃圾回收有什么目的？什么时候进行垃圾回收？</strong></p><p>垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。<br>垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p><p><strong>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</strong></p><p>不会，在下一个垃圾回调周期中，这个对象将是被可回收的。<br>也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。</p><p><strong>finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</strong></p><p>1）垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的finalize()方法；<br>finalize是Object类的一个方法，该方法在Object类中的声明protected void finalize() throws Throwable { }<br>在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放对象占用的内存，将首先调用该对象的finalize()方法，并且下一次垃圾回收动作发生时，才真正回收对象占用的内存空间</p><p>2）GC本来就是内存回收了，应用还需要在finalization做什么呢？ 答案是大部分时候，什么都不用做(也就是不需要重载)。只有在某些很特殊的情况下，比如你调用了一些native的方法(一般是C写的)，可以要在finaliztion里去调用C的释放函数。</p><h2 id="2-2-重排序与数据依赖性"><a href="#2-2-重排序与数据依赖性" class="headerlink" title="2.2 重排序与数据依赖性"></a>2.2 重排序与数据依赖性</h2><p><strong>为什么代码会重排序？</strong></p><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><ul><li>在单线程环境下不能改变程序运行的结果；</li><li>存在数据依赖关系的不允许重排序</li></ul><p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p><h2 id="2-3-as-if-serial规则和happens-before规则"><a href="#2-3-as-if-serial规则和happens-before规则" class="headerlink" title="2.3 as-if-serial规则和happens-before规则"></a>2.3 as-if-serial规则和happens-before规则</h2><ul><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li><li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li></ul><h1 id="3-并发关键字"><a href="#3-并发关键字" class="headerlink" title="3 并发关键字"></a>3 并发关键字</h1><p>针对传统的标签传播算法出现的检测社区的结果不稳定性，提出了一种基于密度峰值的核心节点重要性的标签传播算法。算法首先使用密度峰值聚类算法查找出数据集中的核心节点集，在通过RA函数和节点间的路径长度为每个节点赋予</p><h2 id="3-1-Synchronized"><a href="#3-1-Synchronized" class="headerlink" title="3.1 Synchronized"></a>3.1 Synchronized</h2><p><strong>synchronized 的作用？</strong></p><p>在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p><strong>synchronized关键字4个特性</strong></p><ol><li><strong>原子性</strong><br>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li><strong>可见性</strong><br>可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。</li><li><strong>有序性</strong><br>有序性值程序执行的顺序按照代码先后执行。</li><li><strong>可重入性</strong><br>synchronized和ReentrantLock都是可重入锁。当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请同一个锁。可重复锁，表示该锁能够支持一个线程对资源的重复加锁。</li></ol><p><strong>说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</strong></p><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li>修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li><li>修饰代码块: 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p>总结： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。<br>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><p><strong>说一下 synchronized 底层实现原理？</strong></p><p>synchronized是Java中的一个关键字，在使用的过程中并没有看到显示的加锁和解锁过程。因此有必要通过javap命令，查看相应的字节码文件。</p><p><strong>synchronized 同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过JDK 反汇编指令 javap -c -v SynchronizedDemo</p><p>![在这里插入图片描述](4. 并发编程.assets&#x2F;d7a74564e0b346df92c52167d7269ab7.png)</p><p>可以看出在执行同步代码块之前之后都有一个monitor字样，其中前面的是monitorenter，后面的是离开monitorexit，不难想象一个线程也执行同步代码块，首先要获取锁，而获取锁的过程就是monitorenter ，在执行完代码块之后，要释放锁，释放锁就是执行monitorexit指令。</p><p><strong>为什么会有两个monitorexit呢？</strong></p><p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁。</p><p>仅有ACC_SYNCHRONIZED这么一个标志，该标记表明线程进入该方法时，需要monitorenter，退出该方法时需要monitorexit。</p><p><strong>synchronized可重入的原理</strong></p><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><p><strong>什么是自旋</strong></p><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p><strong>多线程中 synchronized 锁升级的原理是什么？</strong></p><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><p><strong>线程 B 怎么知道线程 A 修改了变量</strong></p><p>（1）volatile 修饰变量<br>（2）synchronized 修饰修改变量的方法<br>（3）wait&#x2F;notify<br>（4）while 轮询</p><p><strong>当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</strong></p><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><p><strong>synchronized、volatile、CAS 比较</strong></p><p>（1）synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。<br>（2）volatile 提供多线程共享变量可见性和禁止指令重排序优化。<br>（3）CAS 是基于冲突检测的乐观锁（非阻塞）</p><p><strong>synchronized 和 Lock 有什么区别？</strong></p><ul><li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</li><li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul><p><strong>synchronized 和 ReentrantLock 区别是什么？</strong></p><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p><p>相同点：两者都是可重入锁</p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>主要区别如下：</strong></p><ul><li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li><li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li><li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li><li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，synchronized 操作的应该是对象头中 mark word</li></ul><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul><p><strong>详情参考：</strong><a href="https://blog.csdn.net/qq_43061290/article/details/124187639">https://blog.csdn.net/qq_43061290/article/details/124187639</a></p><h2 id="3-2-volatile"><a href="#3-2-volatile" class="headerlink" title="3.2 volatile"></a>3.2 volatile</h2><p><strong>volatile 关键字的作用</strong></p><ol><li>内存可见性</li><li>防止指令重排</li><li>不能保证原子性</li></ol><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。<br>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</p><p><strong>Java 中能创建 volatile 数组吗？</strong></p><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p><p><strong>volatile 变量和 atomic 变量有什么不同？</strong></p><p>volatile 变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用 volatile 修饰 count 变量，那么 count++ 操作就不是原子性的。<br>而 AtomicInteger 类提供的 atomic 方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p><p><strong>volatile 能使得一个非原子操作变成原子操作吗？</strong></p><p>关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。</p><p>虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。</p><p>所以从Oracle Java Spec里面可以看到：</p><ul><li>对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。</li><li>如果使用volatile修饰long和double，那么其读写都是原子操作</li><li>对于64位的引用地址的读写，都是原子操作</li><li>在实现JVM时，可以自由选择是否把读写long和double作为原子操作</li><li>推荐JVM实现为原子操作</li></ul><p><strong>volatile 修饰符的有过什么实践？</strong></p><p>单例模式</p><p>是否 Lazy 初始化：是</p><p>是否多线程安全：是</p><p>实现难度：较复杂</p><p>描述：对于Double-Check这种可能出现的问题（当然这种概率已经非常小了，但毕竟还是有的嘛~），解决方案是：只需要给instance的声明加上volatile关键字即可volatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障（什么是内存屏障？），这样，在它的赋值完成之前，就不用会调用读操作。</p><p>注意：volatile阻止的不是singleton &#x3D; newSingleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if (instance &#x3D;&#x3D; null)）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton7</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton7</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton7 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton7.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton7</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>synchronized 和 volatile 的区别是什么？</strong></p><p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。<br>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p><p><strong>区别</strong></p><ul><li>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</li><li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li><li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li></ul><h2 id="3-3-final"><a href="#3-3-final" class="headerlink" title="3.3 final"></a>3.3 final</h2><p><strong>什么是不可变对象，它对写并发应用有什么帮助？</strong></p><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p><p>不可变对象的类即为不可变类(Immutable Class)。Java 平台类库中包含许多不可变类，如 String、基本类型的包装类、BigInteger 和 BigDecimal 等。</p><p>只有满足如下状态，一个对象才是不可变的；</p><ul><li>它的状态不能在创建后再被修改；</li><li>所有域都是 final 类型；并且，它被正确创建（创建期间没有发生 this 引用的逸出）。</li></ul><p>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><h1 id="4-Lock体系"><a href="#4-Lock体系" class="headerlink" title="4 Lock体系"></a>4 Lock体系</h1><h2 id="4-1-Lock简介与初始AQS"><a href="#4-1-Lock简介与初始AQS" class="headerlink" title="4.1 Lock简介与初始AQS"></a>4.1 Lock简介与初始AQS</h2><p>Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？<br>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：</p><p>（1）可以使锁更公平<br>（2）可以使线程在等待锁的时候响应中断<br>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间<br>（4）可以在不同的范围，以不同的顺序获取和释放锁</p><p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><p><strong>乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</strong></p><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。</p><p><strong>乐观锁</strong>：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p><p><strong>乐观锁的实现方式：</strong></p><p>1、使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p><p>2、java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置 V 的值与预期原值 A 相匹配，那么处理器会自动将该位置值更新为新值 B。否则处理器不做任何操作。</p><p><strong>什么是 CAS</strong></p><p>CAS 是 compare and swap 的缩写，即我们所说的比较交换。</p><p>cas 是一种基于锁的操作，而且是乐观锁。在 java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。</p><p>java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的(AtomicInteger,AtomicBoolean,AtomicLong)。</p><p><strong>CAS 的会产生什么问题？</strong></p><p>1、ABA 问题：</p><p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p><p>2、循环时间长开销大：</p><p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</p><p>3、只能保证一个共享变量的原子操作：</p><p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p><p><strong>什么是死锁？</strong></p><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p><p><strong>产生死锁的条件是什么？怎么防止死锁？</strong></p><p><strong>产生死锁的必要条件：</strong></p><p>1、互斥条件：所谓互斥就是进程在某一时间内独占资源。<br>2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3、不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。<br>4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p><p><strong>防止死锁可以采用以下的方法：</strong></p><ul><li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li><li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li><li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li><li>尽量减少同步的代码块。</li></ul><p><strong>死锁与活锁的区别，死锁与饥饿的区别？</strong></p><p>死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，这就是所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p>饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><p><strong>Java 中导致饥饿的原因：</strong></p><p>1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。<br>2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。<br>3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</p><p><strong>多线程锁的升级原理是什么？</strong></p><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p><h2 id="4-2-AQS-AbstractQueuedSynchronizer-详解与源码分析"><a href="#4-2-AQS-AbstractQueuedSynchronizer-详解与源码分析" class="headerlink" title="4.2 AQS(AbstractQueuedSynchronizer)详解与源码分析"></a>4.2 AQS(AbstractQueuedSynchronizer)详解与源码分析</h2><p><strong>AQS 介绍</strong></p><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。<br>![在这里插入图片描述](4. 并发编程.assets&#x2F;ee0a163e4c95492d995381cf0da0b491.png)</p><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p><p><strong>AQS 原理分析</strong><br>下面大部分内容其实在AQS类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p><p><strong>AQS 原理概览</strong></p><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个AQS(AbstractQueuedSynchronizer)原理图：<br>![在这里插入图片描述](4. 并发编程.assets&#x2F;aef98f807fb6435fb10fa6f22eeab49d.png)</p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>AQS 对资源的共享方式</strong></p><p>AQS定义两种资源共享方式</p><ul><li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<br><strong>公平锁</strong>：按照线程在队列中的排队顺序，先到者先拿到锁<br><strong>非公平锁</strong>：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li><li>Share（共享）：多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。</p><p><strong>AQS底层使用了模板方法模式</strong></p><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="type">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="type">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="type">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state&#x3D;0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="4-3-ReentrantLock-重入锁-实现原理与公平锁非公平锁区别"><a href="#4-3-ReentrantLock-重入锁-实现原理与公平锁非公平锁区别" class="headerlink" title="4.3 ReentrantLock(重入锁)实现原理与公平锁非公平锁区别"></a>4.3 ReentrantLock(重入锁)实现原理与公平锁非公平锁区别</h2><p><strong>什么是可重入锁（ReentrantLock）？</strong></p><p>ReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。</p><p>在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：1. 重入性的实现原理；2. 公平锁和非公平锁。</p><p>重入性的实现原理</p><p>要想支持重入性，就要解决两个问题：1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。</p><p>ReentrantLock支持两种锁：公平锁和非公平锁。何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO。</p><h2 id="4-4-读写锁ReentrantReadWriteLock源码分析"><a href="#4-4-读写锁ReentrantReadWriteLock源码分析" class="headerlink" title="4.4 读写锁ReentrantReadWriteLock源码分析"></a>4.4 读写锁ReentrantReadWriteLock源码分析</h2><p><strong>ReadWriteLock 是什么</strong></p><p>首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用 ReentrantLock，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。因为这个，才诞生了读写锁 ReadWriteLock。</p><p>ReadWriteLock 是一个读写锁接口，读写锁是用来提升并发程序性能的锁分离技术，ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>而读写锁有以下三个重要的特性：<br>（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。<br>（2）重进入：读锁和写锁都支持线程重进入。</p><p>（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</p><h2 id="4-5-Condition源码分析与等待通知机制"><a href="#4-5-Condition源码分析与等待通知机制" class="headerlink" title="4.5 Condition源码分析与等待通知机制"></a>4.5 Condition源码分析与等待通知机制</h2><h2 id="4-6-LockSupport详解"><a href="#4-6-LockSupport详解" class="headerlink" title="4.6 LockSupport详解"></a>4.6 LockSupport详解</h2><h1 id="5-并发容器"><a href="#5-并发容器" class="headerlink" title="5 并发容器"></a>5 并发容器</h1><h2 id="5-1-并发容器之ConcurrentHashMap详解-JDK1-8版本-与源码分析-什么是ConcurrentHashMap？"><a href="#5-1-并发容器之ConcurrentHashMap详解-JDK1-8版本-与源码分析-什么是ConcurrentHashMap？" class="headerlink" title="5.1 并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析 什么是ConcurrentHashMap？"></a>5.1 并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析 什么是ConcurrentHashMap？</h2><p>ConcurrentHashMap是Java中的一个线程安全且高效的HashMap实现。平时涉及高并发如果要用map结构，那第一时间想到的就是它。相对于hashmap来说，ConcurrentHashMap就是线程安全的map，其中利用了锁分段的思想提高了并发度。</p><p><strong>那么它到底是如何实现线程安全的？</strong></p><p>JDK 1.6版本关键要素：<br>segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；<br>segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。<br>JDK1.8后，ConcurrentHashMap抛弃了原有的Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p><p><strong>Java 中 ConcurrentHashMap 的并发度是什么？</strong></p><p>ConcurrentHashMap 把实际 map 划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap 类构造函数的一个可选参数，默认值为 16，这样在多线程情况下就能避免争用。</p><p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现,利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p><p><strong>什么是并发容器的实现？</strong></p><p>何为同步容器：可以简单地理解为通过 synchronized 来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如 Vector，Hashtable，以及 Collections.synchronizedSet，synchronizedList 等方法返回的容器。可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized。<br>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问 map，并且执行读操作的线程和写操作的线程也可以并发的访问 map，同时允许一定数量的写操作线程并发地修改 map，所以它可以在并发环境下实现更高的吞吐量。</p><p><strong>Java 中的同步集合与并发集合有什么区别？</strong></p><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在 Java1.5 之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5 介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p><p><strong>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</strong></p><p>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。</p><p>ConcurrentHashMap 使用分段锁来保证在多线程下的性能。</p><p>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将hash 表分为 16 个桶，诸如 get，put，remove 等常用操作只锁当前需要用到的桶。<br>这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。</p><p>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当iterator 被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p><h2 id="5-2-并发容器之CopyOnWriteArrayList详解"><a href="#5-2-并发容器之CopyOnWriteArrayList详解" class="headerlink" title="5.2 并发容器之CopyOnWriteArrayList详解"></a>5.2 并发容器之CopyOnWriteArrayList详解</h2><p>CopyOnWriteArrayList 是什么，可以用于什么应用场景？有哪些优缺点？<br>CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。</p><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p><p>CopyOnWriteArrayList 的使用场景<br>通过源码分析，我们看出它的优缺点比较明显，所以使用场景也就比较明显。就是合适读多写少的场景。</p><p>CopyOnWriteArrayList 的缺点</p><ol><li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li><li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li><li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add&#x2F;set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li></ol><p><strong>CopyOnWriteArrayList 的设计思想</strong></p><ol><li>读写分离，读和写分开</li><li>最终一致性</li><li>使用另外开辟空间的思路，来解决并发冲突</li></ol><h2 id="5-3-并发容器之ThreadLocal详解"><a href="#5-3-并发容器之ThreadLocal详解" class="headerlink" title="5.3 并发容器之ThreadLocal详解"></a>5.3 并发容器之ThreadLocal详解</h2><p><strong>ThreadLocal 是什么？有哪些使用场景？</strong></p><p>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p><p>原理：线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。</p><p>ThreadLocal 使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThreadLocal</span> &#123;</span><br><span class="line">    <span class="comment">//线程本地存储变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; THREAD_LOCAL_NUM </span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">3</span>; i++) &#123;<span class="comment">//启动三个线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    add10ByThreadLocal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程本地存储变量加 5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add10ByThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> THREAD_LOCAL_NUM.get();</span><br><span class="line">            n += <span class="number">1</span>;</span><br><span class="line">            THREAD_LOCAL_NUM.set(n);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : ThreadLocal num=&quot;</span> + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印结果：启动了 3 个线程，每个线程最后都打印到 “ThreadLocal num&#x3D;5”，而不是 num 一直在累加直到值等于 15</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> : ThreadLocal num=<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> : ThreadLocal num=<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span> : ThreadLocal num=<span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span> : ThreadLocal num=<span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span> : ThreadLocal num=<span class="number">2</span></span><br><span class="line">Thread-<span class="number">2</span> : ThreadLocal num=<span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span> : ThreadLocal num=<span class="number">4</span></span><br><span class="line">Thread-<span class="number">2</span> : ThreadLocal num=<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> : ThreadLocal num=<span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span> : ThreadLocal num=<span class="number">4</span></span><br><span class="line">Thread-<span class="number">2</span> : ThreadLocal num=<span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span> : ThreadLocal num=<span class="number">5</span></span><br><span class="line">Thread-<span class="number">2</span> : ThreadLocal num=<span class="number">4</span></span><br><span class="line">Thread-<span class="number">2</span> : ThreadLocal num=<span class="number">5</span></span><br><span class="line">Thread-<span class="number">1</span> : ThreadLocal num=<span class="number">5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>什么是线程局部变量？</strong></p><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><h2 id="4-5-5-ThreadLocal内存泄漏分析与解决方案"><a href="#4-5-5-ThreadLocal内存泄漏分析与解决方案" class="headerlink" title="4.5.5 ThreadLocal内存泄漏分析与解决方案"></a>4.5.5 ThreadLocal内存泄漏分析与解决方案</h2><p><strong>ThreadLocal造成内存泄漏的原因？</strong></p><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</p><p><strong>ThreadLocal内存泄漏解决方案？</strong></p><ul><li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li><li>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</li></ul><h2 id="5-6-并发容器之BlockingQueue详解"><a href="#5-6-并发容器之BlockingQueue详解" class="headerlink" title="5.6 并发容器之BlockingQueue详解"></a>5.6 并发容器之BlockingQueue详解</h2><p><strong>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</strong></p><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。<br>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7 提供了 7 个阻塞队列。分别是：</p><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p><p>SynchronousQueue：一个不存储元素的阻塞队列。</p><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>Java 5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait,notify,notifyAll,sychronized 这些关键字。而在 java 5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p><p>BlockingQueue 接口是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向 BlockingQueue 中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>阻塞队列使用最经典的场景就是 socket 客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p><h2 id="5-7-并发容器之ConcurrentLinkedQueue详解与源码分析"><a href="#5-7-并发容器之ConcurrentLinkedQueue详解与源码分析" class="headerlink" title="5.7 并发容器之ConcurrentLinkedQueue详解与源码分析"></a>5.7 并发容器之ConcurrentLinkedQueue详解与源码分析</h2><h2 id="5-8-并发容器之ArrayBlockingQueue与LinkedBlockingQueue详解"><a href="#5-8-并发容器之ArrayBlockingQueue与LinkedBlockingQueue详解" class="headerlink" title="5.8 并发容器之ArrayBlockingQueue与LinkedBlockingQueue详解"></a>5.8 并发容器之ArrayBlockingQueue与LinkedBlockingQueue详解</h2><h1 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6 线程池"></a>6 线程池</h1><h2 id="6-1-Executors类创建四种常见线程池"><a href="#6-1-Executors类创建四种常见线程池" class="headerlink" title="6.1 Executors类创建四种常见线程池"></a>6.1 Executors类创建四种常见线程池</h2><p><strong>可以参考：线程池详解（通俗易懂超级好）</strong><a href="https://blog.csdn.net/qq_43061290/article/details/106911277">https://blog.csdn.net/qq_43061290/article/details/106911277</a></p><p><strong>什么是线程池？有哪几种创建方式？</strong></p><blockquote><p>池化技术相比大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p></blockquote><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。</p><p>线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><p>（1）newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p><p>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</p><p>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><p><strong>线程池有什么优点？</strong></p><ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销。</li><li>提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li><li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><p>综上所述使用线程池框架 Executor 能更好的管理线程、提供系统资源使用率。</p><p><strong>线程池都有哪些状态？</strong></p><ul><li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li><li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li><li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li></ul><p><strong>什么是 Executor 框架？为什么使用 Executor 框架？</strong></p><p>Executor 框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。<br>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的，而且无限制的创建线程会引起应用程序内存溢出。</p><p>所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors 框架可以非常方便的创建一个线程池。</p><p><strong>在 Java 中 Executor 和 Executors 的区别？</strong></p><ul><li>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li><li>Executor 接口对象能执行我们的线程任务。</li><li>ExecutorService 接口继承了 Executor 接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</li><li>使用 ThreadPoolExecutor 可以创建自定义线程池。</li><li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 get()方法获取计算的结果。</li></ul><p><strong>线程池中 submit() 和 execute() 方法有什么区别？</strong></p><p>接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</p><p>返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有</p><p>异常处理：submit()方便Exception处理</p><p><strong>什么是线程组，为什么在 Java 中不推荐使用？</strong></p><p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><p>线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p><p>为什么不推荐使用线程组？因为使用有很多的安全隐患吧，没有具体追究，如果需要使用，推荐使用线程池。</p><h2 id="6-2-线程池之ThreadPoolExecutor详解"><a href="#6-2-线程池之ThreadPoolExecutor详解" class="headerlink" title="6.2 线程池之ThreadPoolExecutor详解"></a>6.2 线程池之ThreadPoolExecutor详解</h2><p>Executors和ThreaPoolExecutor创建线程池的区别<br>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 各个方法的弊端：</p><ul><li>newFixedThreadPool 和 newSingleThreadExecutor:<br>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</li><li>newCachedThreadPool 和 newScheduledThreadPool:<br>主要问题是线程数最大数是 Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至 OOM。</li></ul><p>ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p><p><strong>你知道怎么创建线程池吗？</strong></p><p>创建线程池的方式有多种，这里你只需要答 ThreadPoolExecutor 即可。</p><p>ThreadPoolExecutor() 是最原始的线程池创建，也是阿里巴巴 Java 开发手册中明确规范的创建线程池的方式。</p><p><strong>ThreadPoolExecutor构造函数重要参数分析</strong><br>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li>corePoolSize ：核心线程数，线程数定义了最小可以同时运行的线程数量。</li><li>maximumPoolSize ：线程池中允许存在的工作线程的最大数量</li><li>workQueue：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中。</li></ul><p><strong>ThreadPoolExecutor其他常见参数:</strong></p><ol><li>keepAliveTime：线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li><li>unit ：keepAliveTime 参数的时间单位。</li><li>threadFactory：为线程池提供创建新线程的线程工厂</li><li>handler ：线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li></ol><p><strong>ThreadPoolExecutor饱和策略</strong></p><p><strong>ThreadPoolExecutor 饱和策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:</p><ul><li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li><li>ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。</li></ul><p>举个例子： Spring 通过 ThreadPoolTaskExecutor 或者我们直接通过 ThreadPoolExecutor 的构造函数创建线程池的时候，当我们不指定 RejectedExecutionHandler 饱和策略的话来配置线程池的时候默认使用的是 ThreadPoolExecutor.AbortPolicy。在默认情况下，ThreadPoolExecutor 将抛出 RejectedExecutionException 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 ThreadPoolExecutor.CallerRunsPolicy。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 ThreadPoolExecutor 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p><p><strong>一个简单的线程池Demo:Runnable+ThreadPoolExecutor</strong></p><p>线程池实现原理<br>![在这里插入图片描述](4. 并发编程.assets&#x2F;03e7c13778344479bbc297b6ec88bf63.png)</p><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。<br>首先创建一个 Runnable 接口的实现类（当然也可以是 Callable 接口，我们上面也说了两者的区别。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以阿里巴巴推荐的使用 ThreadPoolExecutor 构造函数自定义参数的方式来创建线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li>corePoolSize: 核心线程数为 5。</li><li>maximumPoolSize ：最大线程数 10</li><li>keepAliveTime : 等待时间为 1L。</li><li>unit: 等待时间的单位为 TimeUnit.SECONDS。</li><li>workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</li><li>handler:饱和策略为 CallerRunsPolicy。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Output：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">44</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">54</span> CST <span class="number">2019</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3-线程池之ScheduledThreadPoolExecutor详解"><a href="#6-3-线程池之ScheduledThreadPoolExecutor详解" class="headerlink" title="6.3 线程池之ScheduledThreadPoolExecutor详解"></a>6.3 线程池之ScheduledThreadPoolExecutor详解</h2><h2 id="6-4-FutureTask详解"><a href="#6-4-FutureTask详解" class="headerlink" title="6.4 FutureTask详解"></a>6.4 FutureTask详解</h2><h1 id="7-原子类操作"><a href="#7-原子类操作" class="headerlink" title="7 原子类操作"></a>7 原子类操作</h1><p><strong>什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？</strong></p><p>原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。</p><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作。 CAS 操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</p><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p><p>int++并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</p><p>为了解决这个问题，必须保证增加操作是原子的，在 JDK1.5 之前我们可以使用同步技术来做到这一点。到 JDK1.5，java.util.concurrent.atomic 包提供了 int 和long 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><p>java.util.concurrent 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择另一个线程进入，这只是一种逻辑上的理解。</p><p>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference</p><p>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</p><p>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p><p>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个 boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）</p><p><strong>说一下 atomic 的原理？</strong></p><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p><p>AtomicInteger 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">valueOffset = unsafe.objectFieldOffset</span><br><span class="line">(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><p><strong>可以参考：线程池详解（通俗易懂超级好）</strong><a href="https://blog.csdn.net/qq_43061290/article/details/106911277">https://blog.csdn.net/qq_43061290/article/details/106911277</a></p><h1 id="8-并发工具"><a href="#8-并发工具" class="headerlink" title="8 并发工具"></a>8 并发工具</h1><h2 id="8-1-并发工具之CountDownLatch与CyclicBarrier-在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？"><a href="#8-1-并发工具之CountDownLatch与CyclicBarrier-在-Java-中-CycliBarriar-和-CountdownLatch-有什么区别？" class="headerlink" title="8.1 并发工具之CountDownLatch与CyclicBarrier 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？"></a>8.1 并发工具之CountDownLatch与CyclicBarrier 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？</h2><p>CountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p><ul><li>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；- CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。</li><li>调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；</li><li>CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；</li><li>CountDownLatch是不能复用的，而CyclicLatch是可以复用的。</li></ul><h2 id="8-2-并发工具之Semaphore与Exchanger"><a href="#8-2-并发工具之Semaphore与Exchanger" class="headerlink" title="8.2 并发工具之Semaphore与Exchanger"></a>8.2 并发工具之Semaphore与Exchanger</h2><p><strong>Semaphore 有什么作用</strong></p><p>Semaphore 就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个 int 型整数 n，表示某段代码最多只有 n 个线程可以访问，如果超出了 n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果 Semaphore 构造函数中传入的 int 型整数 n&#x3D;1，相当于变成了一个 synchronized 了。<br>Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</p><p><strong>什么是线程间交换数据的工具Exchanger</strong></p><p>Exchanger是一个用于线程间协作的工具类，用于两个线程间交换数据。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据是通过exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</p><p><strong>常用的并发工具类有哪些？</strong></p><ul><li>Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li>CountDownLatch(倒计时器)： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li>CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Java异常面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/3.%20Java%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/06/01/javaInterviewQuestions/3.%20Java%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java异常面试题（2022版）"><a href="#Java异常面试题（2022版）" class="headerlink" title="Java异常面试题（2022版）"></a>Java异常面试题（2022版）</h1><h1 id="1-1-异常简介"><a href="#1-1-异常简介" class="headerlink" title="1.1 异常简介"></a>1.1 异常简介</h1><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。</p><h2 id="1-2-Java异常架构"><a href="#1-2-Java异常架构" class="headerlink" title="1.2 Java异常架构"></a>1.2 Java异常架构</h2><p>![在这里插入图片描述](3. Java异常.assets&#x2F;cb4d777ebd614caca5dc69a681ac98c1.png)</p><p><strong>1. Throwable</strong></p><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><p><strong>2. Error（错误）</strong></p><p>定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><p><strong>3. Exception（异常）</strong></p><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：<strong>运行时异常和编译时异常</strong>。</p><p><strong>运行时异常</strong><br>定义：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p><p>特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p><p>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p><p><strong>编译时异常</strong></p><p>定义: Exception 中除 RuntimeException 及其子类之外的异常。</p><p>特点: Java 编译器会检查它。如果程序中出现此类异常，比如ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p><p><strong>4. 受检异常与非受检异常</strong></p><p>Java 的所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）。</p><p><strong>受检异常</strong></p><p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。<strong>除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</p><p><strong>非受检异常</strong></p><p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。<strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）</strong>。</p><h2 id="1-3-Java异常关键字"><a href="#1-3-Java异常关键字" class="headerlink" title="1.3 Java异常关键字"></a>1.3 Java异常关键字</h2><ul><li>try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li>catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li>finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li>throw – 用于抛出异常。</li><li>throws – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h1 id="2-Java异常处理"><a href="#2-Java异常处理" class="headerlink" title="2 Java异常处理"></a>2 Java异常处理</h1><p>![在这里插入图片描述](3. Java异常.assets&#x2F;d6468eaeb9644d538a2e8bf86a21cb43.png)<br>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。</p><p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p><h2 id="2-1-声明异常"><a href="#2-1-声明异常" class="headerlink" title="2.1 声明异常"></a>2.1 声明异常</h2><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><p><strong>注意</strong></p><ul><li>非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</li><li>一个方法出现编译时异常，就需要 try-catch&#x2F; throws 处理，否则会导致编译错误。</li></ul><h2 id="2-2-抛出异常"><a href="#2-2-抛出异常" class="headerlink" title="2.2 抛出异常"></a>2.2 抛出异常</h2><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。</p><p>throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p><h2 id="2-3-捕获异常"><a href="#2-3-捕获异常" class="headerlink" title="2.3 捕获异常"></a>2.3 捕获异常</h2><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</p><h2 id="2-4-如何选择异常类型"><a href="#2-4-如何选择异常类型" class="headerlink" title="2.4 如何选择异常类型"></a>2.4 如何选择异常类型</h2><p>可以根据下图来选择是捕获异常，声明异常还是抛出异常<br>![在这里插入图片描述](3. Java异常.assets&#x2F;89f3b333086848a6a1666e567fff166b.png)</p><h2 id="2-5-常见异常处理方式"><a href="#2-5-常见异常处理方式" class="headerlink" title="2.5 常见异常处理方式"></a>2.5 常见异常处理方式</h2><p><strong>直接抛出异常</strong></p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) throws IOException &#123;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = new BufferedReader(new FileReader(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=null) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装异常再抛出</strong></p><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) throws MyException &#123;    </span><br><span class="line">    try &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        MyException ex = new MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>捕获异常</strong><br>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        // handle FileNotFoundException</span><br><span class="line">    &#125; catch (IOException e)&#123;</span><br><span class="line">        // handle IOException</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        // handle FileNotFoundException or UnknownHostException</span><br><span class="line">    &#125; catch (IOException e)&#123;</span><br><span class="line">        // handle IOException</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义异常</strong></p><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line">    public <span class="function"><span class="title">MyException</span></span>()&#123; &#125;</span><br><span class="line">    public MyException(String msg)&#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><p>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) throws MyException &#123;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        reader = new BufferedReader(new FileReader(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=null) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        MyException ex = new MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (null != reader) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入 finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入 finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。</p><p>若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码中的 catch 子句修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是否执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readFile method catch block.</span><br><span class="line">readFile method finally block.</span><br></pre></td></tr></table></figure><p>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</p><p><strong>try-with-resource</strong></p><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private  static void <span class="function"><span class="title">tryWithResourceTest</span></span>()&#123;</span><br><span class="line">    try (Scanner scanner = new Scanner(new FileInputStream(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (IOException e)&#123;</span><br><span class="line">        // handle exception</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h1 id="3-Java异常常见面试题"><a href="#3-Java异常常见面试题" class="headerlink" title="3 Java异常常见面试题"></a>3 Java异常常见面试题</h1><h2 id="3-1-Error和Exception区别是什么？"><a href="#3-1-Error和Exception区别是什么？" class="headerlink" title="3.1 Error和Exception区别是什么？"></a>3.1 Error和Exception区别是什么？</h2><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p><p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p><h2 id="3-2-运行时异常和一般异常-受检异常-区别是什么？"><a href="#3-2-运行时异常和一般异常-受检异常-区别是什么？" class="headerlink" title="3.2 运行时异常和一般异常(受检异常)区别是什么？"></a>3.2 运行时异常和一般异常(受检异常)区别是什么？</h2><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p><p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p><p>RuntimeException异常和受检异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p><h2 id="3-3-JVM-是如何处理异常的？"><a href="#3-3-JVM-是如何处理异常的？" class="headerlink" title="3.3 JVM 是如何处理异常的？"></a>3.3 JVM 是如何处理异常的？</h2><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p><p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p><h2 id="3-4-throw-和-throws-的区别是什么？"><a href="#3-4-throw-和-throws-的区别是什么？" class="headerlink" title="3.4 throw 和 throws 的区别是什么？"></a>3.4 throw 和 throws 的区别是什么？</h2><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。<br><strong>throws 关键字和 throw 关键字在使用上的几点区别如下：</strong></p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h2 id="3-5-final、finally、finalize-有什么区别？"><a href="#3-5-final、finally、finalize-有什么区别？" class="headerlink" title="3.5 final、finally、finalize 有什么区别？"></a>3.5 final、finally、finalize 有什么区别？</h2><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li></ul><h2 id="3-6-NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#3-6-NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="3.6 NoClassDefFoundError 和 ClassNotFoundException 区别？"></a>3.6 NoClassDefFoundError 和 ClassNotFoundException 区别？</h2><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p><p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；</p><p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p><h2 id="3-7-try-catch-finally-中哪个部分可以省略？"><a href="#3-7-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="3.7 try-catch-finally 中哪个部分可以省略？"></a>3.7 try-catch-finally 中哪个部分可以省略？</h2><p>答：catch 可以省略</p><p><strong>原因</strong></p><p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p><p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p><p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p><h2 id="3-8-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#3-8-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="3.8 try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>3.8 try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>答：会执行，在 return 前执行。</p><p>注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。<br>代码示例1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int <span class="function"><span class="title">getInt</span></span>() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(a / 0);</span><br><span class="line">        a = 20;</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        a = 30;</span><br><span class="line">        <span class="built_in">return</span> a;</span><br><span class="line">        /*</span><br><span class="line">         * <span class="built_in">return</span> a 在程序执行到这一步的时候，这里不是<span class="built_in">return</span> a 而是 <span class="built_in">return</span> 30；这个返回路径就形成了</span><br><span class="line">         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span><br><span class="line">         * 再次回到以前的路径,继续走<span class="built_in">return</span> 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span><br><span class="line">         */</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        a = 40;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：30<br>代码示例2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int <span class="function"><span class="title">getInt</span></span>() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(a / 0);</span><br><span class="line">        a = 20;</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        a = 30;</span><br><span class="line">        <span class="built_in">return</span> a;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        a = 40;</span><br><span class="line">        //如果这样，就又重新形成了一条返回路径，由于只能通过1个<span class="built_in">return</span>返回，所以这里直接返回40</span><br><span class="line">        <span class="built_in">return</span> a; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：40</p><h2 id="3-9-ExampleA-继承-Exception，类-ExampleB-继承ExampleA"><a href="#3-9-ExampleA-继承-Exception，类-ExampleB-继承ExampleA" class="headerlink" title="3.9 ExampleA 继承 Exception，类 ExampleB 继承ExampleA"></a>3.9 ExampleA 继承 Exception，类 ExampleB 继承ExampleA</h2><p>有如下代码片断：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">throw new ExampleB(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125; catch（ExampleA e）&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ExampleA&quot;</span>);</span><br><span class="line">&#125; catch（Exception e）&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问执行此段代码的输出是什么？</p><p>答：</p><p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p><p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Annoyance extends Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Sneeze extends Annoyance &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">throws Exception &#123;</span><br><span class="line">try &#123;</span><br><span class="line">try &#123;</span><br><span class="line">throw new Sneeze();</span><br><span class="line">&#125; catch ( Annoyance a ) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>);</span><br><span class="line">throw a;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch ( Sneeze s ) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>);</span><br><span class="line"><span class="built_in">return</span> ;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果</span><br><span class="line">Caught Annoyance</span><br><span class="line">Caught Sneeze</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="3-10-常见的-RuntimeException-有哪些？"><a href="#3-10-常见的-RuntimeException-有哪些？" class="headerlink" title="3.10 常见的 RuntimeException 有哪些？"></a>3.10 常见的 RuntimeException 有哪些？</h2><ul><li>ClassCastException(类转换异常)</li><li>IndexOutOfBoundsException(数组越界)</li><li>NullPointerException(空指针)</li><li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li><li>还有IO操作的BufferOverflowException异常</li></ul><h2 id="3-11-Java常见异常有哪些"><a href="#3-11-Java常见异常有哪些" class="headerlink" title="3.11 Java常见异常有哪些"></a>3.11 Java常见异常有哪些</h2><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p><p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p><p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p><p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p><p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p><p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p><p>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p><p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p><p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p><p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p><p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p><p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p><p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p><p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p><p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p><h1 id="4-Java异常处理最佳实践"><a href="#4-Java异常处理最佳实践" class="headerlink" title="4 Java异常处理最佳实践"></a>4 Java异常处理最佳实践</h1><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。</p><p>本文给出几个被很多团队使用的异常处理最佳实践。</p><h2 id="4-1-在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#4-1-在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="4.1 在 finally 块中清理资源或者使用 try-with-resource 语句"></a>4.1 在 finally 块中清理资源或者使用 try-with-resource 语句</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">doNotCloseResourceInTry</span></span>() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        // use the inputStream to <span class="built_in">read</span> a file</span><br><span class="line">        // <span class="keyword">do</span> NOT <span class="keyword">do</span> this</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p><p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p><p><strong>使用 finally 代码块</strong><br>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">closeResourceInFinally</span></span>() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        // use the inputStream to <span class="built_in">read</span> a file</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 7 的 try-with-resource 语法</strong></p><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">automaticallyCloseResource</span></span>() &#123;</span><br><span class="line">    File file = new File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    try (FileInputStream inputStream = new FileInputStream(file);) &#123;</span><br><span class="line">        // use the inputStream to <span class="built_in">read</span> a file</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-优先明确的异常"><a href="#4-2-优先明确的异常" class="headerlink" title="4.2 优先明确的异常"></a>4.2 优先明确的异常</h2><p>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。<br>因此，总是尝试寻找最适合你的异常事件的类，例如，抛出一个 NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void doNotDoThis() throws Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public void doThis() throws NumberFormatException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-对异常进行文档说明"><a href="#4-3-对异常进行文档说明" class="headerlink" title="4.3 对异常进行文档说明"></a>4.3 对异常进行文档说明</h2><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething(String input) throws MyBusinessException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-使用描述性消息抛出异常"><a href="#4-4-使用描述性消息抛出异常" class="headerlink" title="4.4 使用描述性消息抛出异常"></a>4.4 使用描述性消息抛出异常</h2><p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p><p>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p><p>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    new Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-优先捕获最具体的异常"><a href="#4-5-优先捕获最具体的异常" class="headerlink" title="4.5 优先捕获最具体的异常"></a>4.5 优先捕获最具体的异常</h2><p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p><p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。<br>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">catchMostSpecificExceptionFirst</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-不要捕获-Throwable-类"><a href="#4-6-不要捕获-Throwable-类" class="headerlink" title="4.6 不要捕获 Throwable 类"></a>4.6 不要捕获 Throwable 类</h2><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p><p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">doNotCatchThrowable</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // don<span class="string">&#x27;t do this!</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4-7-不要忽略异常"><a href="#4-7-不要忽略异常" class="headerlink" title="4.7 不要忽略异常"></a>4.7 不要忽略异常</h2><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">doNotIgnoreExceptions</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        // this will never happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。<br>合理的做法是至少要记录异常的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">logAnException</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-8-不要记录并抛出异常"><a href="#4-8-不要记录并抛出异常" class="headerlink" title="4.8 不要记录并抛出异常"></a>4.8 不要记录并抛出异常</h2><p>这可能是本文中最常被忽略的最佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    new Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:589)</span><br><span class="line">at java.lang.Long.(Long.java:965)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)</span><br></pre></td></tr></table></figure><p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        throw new MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h2 id="4-9-包装异常时不要抛弃原始的异常"><a href="#4-9-包装异常时不要抛弃原始的异常" class="headerlink" title="4.9 包装异常时不要抛弃原始的异常"></a>4.9 包装异常时不要抛弃原始的异常</h2><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        throw new MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-不要使用异常控制程序的流程"><a href="#4-10-不要使用异常控制程序的流程" class="headerlink" title="4.10 不要使用异常控制程序的流程"></a>4.10 不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h2 id="4-11-使用标准异常"><a href="#4-11-使用标准异常" class="headerlink" title="4.11 使用标准异常"></a>4.11 使用标准异常</h2><p>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。</p><h2 id="4-12-异常会影响性能"><a href="#4-12-异常会影响性能" class="headerlink" title="4.12 异常会影响性能"></a>4.12 异常会影响性能</h2><p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。<br>仅在异常情况下使用异常；<br>在可恢复的异常情况下使用异常；<br>尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</p><h2 id="4-13-总结"><a href="#4-13-总结" class="headerlink" title="4.13 总结"></a>4.13 总结</h2><p>综上所述，当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。<br>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p><p>异常处理-阿里巴巴Java开发手册<br>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj !&#x3D; null) {…} 反例：try { obj.method(); } catch (NullPointerException e) {…}</p><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</p><p>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int x = 0;</span><br><span class="line">public int <span class="function"><span class="title">checkReturn</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // x等于1，此处不返回</span><br><span class="line">        <span class="built_in">return</span> ++x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 返回的结果是2</span><br><span class="line">        <span class="built_in">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p><p>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</p><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>正例：使用JDK8的Optional类来防止NPE问题。</p><p>【推荐】定义时区分unchecked &#x2F; checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException &#x2F; ServiceException等。</p><p>【参考】对于公司外的http&#x2F;api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto) {…}</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Java集合容器面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/2.%20Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/06/01/javaInterviewQuestions/2.%20Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java集合容器面试题（2022版）"><a href="#Java集合容器面试题（2022版）" class="headerlink" title="Java集合容器面试题（2022版）"></a>Java集合容器面试题（2022版）</h1><h1 id="1-集合容器概述"><a href="#1-集合容器概述" class="headerlink" title="1 集合容器概述"></a>1 集合容器概述</h1><h2 id="1-1-什么是集合"><a href="#1-1-什么是集合" class="headerlink" title="1.1 什么是集合"></a>1.1 什么是集合</h2><p><strong>集合框架：用于存储数据的容器。</strong></p><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。<br>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p><p><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p><p><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</p><p><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。<br>它减少了程序设计的辛劳。</p><p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。</p><p>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</p><h2 id="1-2-集合的特点"><a href="#1-2-集合的特点" class="headerlink" title="1.2 集合的特点"></a>1.2 集合的特点</h2><p><strong>集合的特点主要有如下两点：</strong></p><ul><li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li><li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li></ul><h2 id="1-3-集合和数组的区别"><a href="#1-3-集合和数组的区别" class="headerlink" title="1.3 集合和数组的区别"></a>1.3 集合和数组的区别</h2><ul><li>1、数组是固定长度的；集合可变长度的。</li><li>2、数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>3、数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><p><strong>数据结构：就是容器中存储数据的方式。</strong></p><p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p><p>集合容器在不断向上抽取过程中，出现了集合体系。在使用一个体系的原则：参阅顶层内容。建立底层对象。</p><h2 id="1-4-使用集合框架的好处"><a href="#1-4-使用集合框架的好处" class="headerlink" title="1.4 使用集合框架的好处"></a>1.4 使用集合框架的好处</h2><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h2 id="1-5-常用的集合类有哪些？"><a href="#1-5-常用的集合类有哪些？" class="headerlink" title="1.5 常用的集合类有哪些？"></a>1.5 常用的集合类有哪些？</h2><p><strong>Map接口和Collection接口是所有集合框架的父接口：</strong></p><ul><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ul><h2 id="1-6-List、Set、Map三者的区别？"><a href="#1-6-List、Set、Map三者的区别？" class="headerlink" title="1.6 List、Set、Map三者的区别？"></a>1.6 List、Set、Map三者的区别？</h2><p><strong>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</strong><br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/01.png"></p><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p><p>Collection集合主要有List和Set两大接口</p><ul><li><strong>List</strong>：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li><strong>Set</strong>：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li></ul><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p><p><strong>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</strong></p><h2 id="1-7-集合框架底层数据结构"><a href="#1-7-集合框架底层数据结构" class="headerlink" title="1.7 集合框架底层数据结构"></a>1.7 集合框架底层数据结构</h2><p><strong>Collection</strong><br>1、List</p><ul><li>Arraylist： Object数组</li><li>Vector： Object数组</li><li>LinkedList： 双向循环链表</li></ul><p>2、Set</p><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul><p>3、Map</p><ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h2 id="1-8-哪些集合类是线程安全？"><a href="#1-8-哪些集合类是线程安全？" class="headerlink" title="1.8 哪些集合类是线程安全？"></a>1.8 哪些集合类是线程安全？</h2><ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul><h2 id="1-9-java集合的快速失败机制“fail-fast”"><a href="#1-9-java集合的快速失败机制“fail-fast”" class="headerlink" title="1.9 java集合的快速失败机制“fail-fast”"></a>1.9 java集合的快速失败机制“fail-fast”</h2><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p><p><strong>例如</strong>：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p><strong>原因</strong>：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>解决办法</strong>：<br>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。<br>使用CopyOnWriteArrayList来替换ArrayList</p><h2 id="1-10-怎么确保一个集合不能被修改"><a href="#1-10-怎么确保一个集合不能被修改" class="headerlink" title="1.10 怎么确保一个集合不能被修改"></a>1.10 怎么确保一个集合不能被修改</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>实例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">&quot;y&quot;</span>); // 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure><h1 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2 Collection接口"></a>2 Collection接口</h1><h2 id="2-1-List接口"><a href="#2-1-List接口" class="headerlink" title="2.1 List接口"></a>2.1 List接口</h2><p><strong>迭代器 Iterator 是什么？</strong></p><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><p><strong>Iterator 怎么使用？有什么特点？</strong></p><p>Iterator 使用代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><p><strong>如何边遍历边移除 Collection 中的元素？</strong></p><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   *// <span class="keyword">do</span> something*</span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种最常见的错误代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><p><strong>Iterator 和 ListIterator 有什么区别？</strong></p><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><p><strong>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</strong><br>遍历方式有以下几种：</p><ul><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ul><p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li></ul><p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><p><strong>说一下 ArrayList 的优缺点</strong></p><p><strong>ArrayList的优点如下：</strong></p><ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul><p><strong>ArrayList 的缺点如下：</strong></p><ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li><li>ArrayList 比较适合顺序添加、随机访问的场景。</li></ul><p><strong>如何实现数组和 List 之间的转换？</strong></p><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li><li></li></ul><p><strong>代码示例如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// list to array</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">list.toArray();</span><br><span class="line"></span><br><span class="line">// array to list</span><br><span class="line">String[] array = new String[]&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">Arrays.asList(array);</span><br></pre></td></tr></table></figure><p><strong>ArrayList 和 LinkedList 的区别是什么？</strong></p><ul><li><strong>数据结构实现</strong>：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li><strong>随机访问效率</strong>：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li><strong>增加和删除效率</strong>：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li><strong>内存空间占用</strong>：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li><strong>线程安全</strong>：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><p><strong>补充</strong>：数据结构基础之双向链表</p><p><strong>双向链表也叫双链表</strong>，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><p><strong>ArrayList 和 Vector 的区别是什么？</strong></p><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><p><strong>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</strong></p><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p><p>Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。</p><p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。</p><p><strong>多线程场景下如何使用 ArrayList？</strong></p><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么 ArrayList 的 elementData 加上 transient 修饰？</strong></p><p>ArrayList 中的数组定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] elementData;</span><br></pre></td></tr></table></figure><p>再看一下 ArrayList 的定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123;</span><br><span class="line">    *// Write out element count, and any hidden stuff*</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    *// Write out array length*</span><br><span class="line">        s.writeInt(elementData.length);</span><br><span class="line">    *// Write out all elements <span class="keyword">in</span> the proper order.*</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;size; i++)</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><p><strong>List 和 Set 的区别</strong><br>List , Set 都是继承自Collection 接口</p><p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p><p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p><p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p><p><strong>Set和List对比</strong></p><ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li></ul><h2 id="2-2-Set接口"><a href="#2-2-Set接口" class="headerlink" title="2.2 Set接口"></a>2.2 Set接口</h2><p><strong>说一下 HashSet 的实现原理？</strong></p><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><p><strong>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</strong></p><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p><strong>以下是HashSet 部分源码：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final Object PRESENT = new Object();</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    // 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="line"><span class="built_in">return</span> map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><p><strong>&#x3D;&#x3D;与equals的区别</strong></p><ol><li>&#x3D;&#x3D;是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>&#x3D;&#x3D;是指对内存地址进行比较 equals()是对字符串的内容进行比较3.&#x3D;&#x3D;指引用是否相同 equals()指的是值是否相同</li></ol><p><strong>HashSet与HashMap的区别</strong><br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/02.png"></p><h2 id="2-3-队列"><a href="#2-3-队列" class="headerlink" title="2.3 队列"></a>2.3 队列</h2><p><strong>BlockingQueue是什么？</strong><br>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。</p><p>BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><p><strong>在 Queue 中 poll()和 remove()有什么区别？</strong></p><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><p>代码示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">&quot;string&quot;</span>); // add</span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure><h1 id="3-Map接口"><a href="#3-Map接口" class="headerlink" title="3 Map接口"></a>3 Map接口</h1><h2 id="3-1-HashMap的实现原理"><a href="#3-1-HashMap的实现原理" class="headerlink" title="3.1 HashMap的实现原理"></a>3.1 HashMap的实现原理</h2><p><strong>HashMap概述</strong>： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p><strong>HashMap的数据结构</strong>： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p><strong>HashMap 基于 Hash 算法实现的</strong></p><ul><li>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标<br>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li></ul><p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p><h2 id="3-2-HashMap在JDK1-7和1-8中有哪些区别？HashMap的底层实现"><a href="#3-2-HashMap在JDK1-7和1-8中有哪些区别？HashMap的底层实现" class="headerlink" title="3.2 HashMap在JDK1.7和1.8中有哪些区别？HashMap的底层实现"></a>3.2 HashMap在JDK1.7和1.8中有哪些区别？HashMap的底层实现</h2><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。</p><p><strong>JDK1.8之前</strong><br>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/03.png"></p><p><strong>JDK1.8之后</strong></p><p>JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</p><p><strong>补充</strong>：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64。此时并不会将链表变为红黑树。而是选择进行数组扩容。</p><p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考</p><p>treeifysin方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int <span class="built_in">hash</span>) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    // 如果表的长度小于 64 会先扩容！！！ 否则 扩容</span><br><span class="line">    // MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line">    <span class="keyword">if</span> (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - 1) &amp; <span class="built_in">hash</span>]) != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">            <span class="keyword">if</span> (tl == null)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != null)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/04.png"></p><p><strong>JDK1.7 VS JDK1.8 比较</strong></p><p>JDK1.8主要解决或优化了一下问题：</p><ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/05.png"></p><p><strong>补充：</strong></p><h2 id="3-3-HashMap的PUT方法的具体流程"><a href="#3-3-HashMap的PUT方法的具体流程" class="headerlink" title="3.3 HashMap的PUT方法的具体流程"></a>3.3 HashMap的PUT方法的具体流程</h2><p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index &#x3D; (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p><strong>putVal方法执行流程图</strong><br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/06.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    <span class="built_in">return</span> putVal(<span class="built_in">hash</span>(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int <span class="built_in">hash</span>(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    <span class="built_in">return</span> (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现Map.put和相关方法</span><br><span class="line">final V putVal(int <span class="built_in">hash</span>, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 步骤①：tab为空则创建 </span><br><span class="line">    // table未初始化或者长度为0，进行扩容</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 步骤②：计算index，并对null做处理  </span><br><span class="line">    // (n - 1) &amp; <span class="built_in">hash</span> 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - 1) &amp; <span class="built_in">hash</span>]) == null)</span><br><span class="line">        tab[i] = newNode(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">    // 桶中已经存在元素</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 步骤③：节点key存在，直接覆盖value </span><br><span class="line">        // 比较桶中第一个元素(数组中的结点)的<span class="built_in">hash</span>值相等，key相等</span><br><span class="line">        <span class="keyword">if</span> (p.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                // 将第一个元素赋值给e，用e来记录</span><br><span class="line">                e = p;</span><br><span class="line">        // 步骤④：判断该链为红黑树 </span><br><span class="line">        // <span class="built_in">hash</span>值不相等，即key不相等；为红黑树结点</span><br><span class="line">        // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">            // 放入树中</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, <span class="built_in">hash</span>, key, value);</span><br><span class="line">        // 步骤⑤：该链为链表 </span><br><span class="line">        // 为链表结点</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            // 在链表最末插入结点</span><br><span class="line">            <span class="keyword">for</span> (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 到达链表的尾部</span><br><span class="line">                </span><br><span class="line">                //判断该链表尾部指针是不是空的</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == null) &#123;</span><br><span class="line">                    // 在尾部插入新结点</span><br><span class="line">                    p.next = newNode(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">                    //判断链表的长度是否达到转化红黑树的临界值，临界值为8</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 <span class="keyword">for</span> 1st</span><br><span class="line">                        //链表结构转树形结构</span><br><span class="line">                        treeifyBin(tab, <span class="built_in">hash</span>);</span><br><span class="line">                    // 跳出循环</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                // 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">                <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    // 相等，跳出循环</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前的key已经存在的情况下，再来一个相同的<span class="built_in">hash</span>值、key值时，返回新来的value这个值</span><br><span class="line">        <span class="keyword">if</span> (e != null) &#123; </span><br><span class="line">            // 记录e的value</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            // onlyIfAbsent为<span class="literal">false</span>或者旧值为null</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                //用新值替换旧值</span><br><span class="line">                e.value = value;</span><br><span class="line">            // 访问后回调</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            // 返回旧值</span><br><span class="line">            <span class="built_in">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构性修改</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 步骤⑥：超过最大容量就扩容 </span><br><span class="line">    // 实际大小大于阈值则扩容</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    // 插入后回调</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；<br>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h2 id="3-4-HashMap的扩容操作及原理"><a href="#3-4-HashMap的扩容操作及原理" class="headerlink" title="3.4 HashMap的扩容操作及原理"></a>3.4 HashMap的扩容操作及原理</h2><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] <span class="function"><span class="title">resize</span></span>() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;//oldTab指向<span class="built_in">hash</span>桶数组</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; 0) &#123;//如果oldCap不为空的话，就是<span class="built_in">hash</span>桶数组不为空</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//如果大于最大容量了，就赋值为整数最大的阀值</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="built_in">return</span> oldTab;//返回</span><br><span class="line">        &#125;//如果当前<span class="built_in">hash</span>桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="string">1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span></span><br><span class="line"><span class="string">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span></span><br><span class="line"><span class="string">            newThr = oldThr &lt;&lt; 1</span>; // double threshold 双倍扩容阀值threshold</span><br><span class="line">    &#125;</span><br><span class="line">    // 旧的容量为0，但threshold大于零，代表有参构造有<span class="built_in">cap</span>传入，threshold已经被初始化成最小2的n次幂</span><br><span class="line">    // 直接将该值赋给新的容量</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; 0) // initial capacity was placed <span class="keyword">in</span> threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br><span class="line">    <span class="keyword">else</span> &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 新的threshold = 新的<span class="built_in">cap</span> * 0.75</span><br><span class="line">    <span class="keyword">if</span> (newThr == 0) &#123;</span><br><span class="line">        <span class="built_in">float</span> ft = (<span class="built_in">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="built_in">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    // 计算出新的数组长度后赋给当前成员变量table</span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">&quot;rawtypes&quot;</span>,<span class="string">&quot;unchecked&quot;</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//新建<span class="built_in">hash</span>桶数组</span><br><span class="line">    table = newTab;//将新数组的值复制给旧的<span class="built_in">hash</span>桶数组</span><br><span class="line">    // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span><br><span class="line">    <span class="keyword">if</span> (oldTab != null) &#123;</span><br><span class="line">        // 遍历新数组的所有桶下标</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span><br><span class="line">                <span class="keyword">if</span> (e.next == null)</span><br><span class="line">                    // 用同样的<span class="built_in">hash</span>映射算法把该元素加入新的数组</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).<span class="built_in">split</span>(this, newTab, j, oldCap);</span><br><span class="line">                // e是链表的头并且e.next!=null，那么处理链表中元素重排</span><br><span class="line">                <span class="keyword">else</span> &#123; // preserve order</span><br><span class="line">                    // loHead,loTail 代表扩容后不用变换下标，见注1</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    // hiHead,hiTail 代表扩容后变换下标，见注1</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    // 遍历链表</span><br><span class="line">                    <span class="keyword">do</span> &#123;             </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == null)</span><br><span class="line">                                // 初始化<span class="built_in">head</span>指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br><span class="line">                                // 代表下标保持不变的链表的头元素</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>                                </span><br><span class="line">                                // loTail.next指向当前e</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            // loTail指向当前的元素e</span><br><span class="line">                            // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span><br><span class="line">                            // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br><span class="line">                            // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br><span class="line">                            loTail = e;                           </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == null)</span><br><span class="line">                                // 初始化<span class="built_in">head</span>指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != null);</span><br><span class="line">                    // 遍历结束, 将<span class="built_in">tail</span>指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br><span class="line">                    <span class="keyword">if</span> (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题?</strong></p><p>初始容量为16，达到阈值扩容，阈值等于最大容量*负载因子，扩容每次2倍，总是2的n次方。<br>①、table数组大小是由capacity这个参数确定的,默认是16,也可以构造时传入,最大限制是1&lt;&lt;30;</p><p>②、loadFactor是装载因子,主要目的是用来确认table数组是否需要动态扩展,默认值是0.75,比如table数组大小为16,装载因子为0.75时,threshold就是12,当table的实际大小超过12时,table就需要动态扩容;</p><p>③、扩容时,调用resize()方法,将table长度变为原来的两倍(注意是table长度,而不是threshold)</p><p>④、如果数据很大的情况下,扩展时将会带来性能的损失,在性能要求很高的地方,这种损失很可能很致命。</p><h2 id="3-5-HashMap是如何解决哈希冲突的？"><a href="#3-5-HashMap是如何解决哈希冲突的？" class="headerlink" title="3.5 HashMap是如何解决哈希冲突的？"></a>3.5 HashMap是如何解决哈希冲突的？</h2><p>答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；</p><p><strong>什么是哈希？</strong></p><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><p><strong>什么是哈希冲突？</strong></p><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><p><strong>HashMap的数据结构</strong></p><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突：<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/07.png"></p><p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</p><p><strong>hash()函数</strong></p><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int <span class="built_in">hash</span>(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    <span class="built_in">return</span> (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p><p><strong>Jdk1.8新增红黑树</strong><br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/08.png"></p><p>通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p><p><strong>总结</strong></p><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><ol><li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li><li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li><li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li></ol><h2 id="3-6-能否使用任何类作为Map的key"><a href="#3-6-能否使用任何类作为Map的key" class="headerlink" title="3.6 能否使用任何类作为Map的key?"></a>3.6 能否使用任何类作为Map的key?</h2><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h2 id="3-7-为什么HashMap中的String、Integer这样的包装类适合作为K"><a href="#3-7-为什么HashMap中的String、Integer这样的包装类适合作为K" class="headerlink" title="3.7 为什么HashMap中的String、Integer这样的包装类适合作为K"></a>3.7 为什么HashMap中的String、Integer这样的包装类适合作为K</h2><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul><h2 id="3-8-如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#3-8-如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="3.8 如果使用Object作为HashMap的Key，应该怎么办呢？"></a>3.8 如果使用Object作为HashMap的Key，应该怎么办呢？</h2><p>答：重写hashCode()和equals()方法</p><ul><li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li></ul><h2 id="3-9-HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#3-9-HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="3.9 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>3.9 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><p>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p><strong>那怎么解决呢？</strong></p><ul><li>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ul><h2 id="3-10-HashMap-的长度为什么是2的幂次方"><a href="#3-10-HashMap-的长度为什么是2的幂次方" class="headerlink" title="3.10 HashMap 的长度为什么是2的幂次方"></a>3.10 HashMap 的长度为什么是2的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>那为什么是两次扰动呢？</strong></p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><h2 id="3-11-HashMap-与-HashTable-有什么区别？"><a href="#3-11-HashMap-与-HashTable-有什么区别？" class="headerlink" title="3.11 HashMap 与 HashTable 有什么区别？"></a>3.11 HashMap 与 HashTable 有什么区别？</h2><ul><li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li><li>初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ul><h2 id="3-12-如何决定使用-HashMap-还是-TreeMap？"><a href="#3-12-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="3.12 如何决定使用 HashMap 还是 TreeMap？"></a>3.12 如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h2 id="3-13-HashMap-和-ConcurrentHashMap-的区别"><a href="#3-13-HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="3.13 HashMap 和 ConcurrentHashMap 的区别"></a>3.13 HashMap 和 ConcurrentHashMap 的区别</h2><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h2 id="3-14-ConcurrentHashMap-和-Hashtable-的区别？"><a href="#3-14-ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="3.14 ConcurrentHashMap 和 Hashtable 的区别？"></a>3.14 ConcurrentHashMap 和 Hashtable 的区别？</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要</strong>）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p><strong>HashTable:</strong><br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/09.png"></p><p>JDK1.7的ConcurrentHashMap<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/10.png"></p><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/11.png"></p><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h2 id="3-15-ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#3-15-ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="3.15 ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>3.15 ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><p><strong>JDK1.7</strong></p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。<br>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/12.png"></p><p>1、该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</p><p>2、Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p><p><strong>JDK1.8</strong></p><p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>结构如下：<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/02/13.png"></p><p>附加源码，有需要的可以看看<br>插入元素过程（建议去看看源码）：<br>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - 1) &amp; <span class="built_in">hash</span>)) == null) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, null, new Node&lt;K,V&gt;(<span class="built_in">hash</span>, key, value, null)))</span><br><span class="line">        <span class="built_in">break</span>;                   // no lock when adding to empty bin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= 0) &#123;</span><br><span class="line">    binCount = 1;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == null) &#123;</span><br><span class="line">            pred.next = new Node&lt;K,V&gt;(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p><p>2、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p><h1 id="4-辅助工具类"><a href="#4-辅助工具类" class="headerlink" title="4 辅助工具类"></a>4 辅助工具类</h1><h2 id="4-1-Array-和-ArrayList-有何区别？"><a href="#4-1-Array-和-ArrayList-有何区别？" class="headerlink" title="4.1 Array 和 ArrayList 有何区别？"></a>4.1 Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h2 id="4-2-如何实现-Array-和-List-之间的转换？"><a href="#4-2-如何实现-Array-和-List-之间的转换？" class="headerlink" title="4.2 如何实现 Array 和 List 之间的转换？"></a>4.2 如何实现 Array 和 List 之间的转换？</h2><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h2 id="4-3-comparable-和-comparator的区别？"><a href="#4-3-comparable-和-comparator的区别？" class="headerlink" title="4.3 comparable 和 comparator的区别？"></a>4.3 comparable 和 comparator的区别？</h2><ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p><h2 id="4-4-Collection-和-Collections-有什么区别？"><a href="#4-4-Collection-和-Collections-有什么区别？" class="headerlink" title="4.4 Collection 和 Collections 有什么区别？"></a>4.4 Collection 和 Collections 有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="4-5-TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#4-5-TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="4.5 TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>4.5 TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p><p>Collections 工具类的 sort 方法有两种重载的形式，</p><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Java基础知识面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/1.%20Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/06/01/javaInterviewQuestions/1.%20Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java基础知识面试题（2022版）"><a href="#Java基础知识面试题（2022版）" class="headerlink" title="Java基础知识面试题（2022版）"></a>Java基础知识面试题（2022版）</h1><table><thead><tr><th>序列号</th><th>内容</th><th>链接</th></tr></thead><tbody><tr><td>1</td><td>Java基础知识面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124023797">https://blog.csdn.net/qq_43061290/article/details/124023797</a></td></tr><tr><td>2</td><td>Java集合容器面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124043363">https://blog.csdn.net/qq_43061290/article/details/124043363</a></td></tr><tr><td>3</td><td>Java异常面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124078378">https://blog.csdn.net/qq_43061290/article/details/124078378</a></td></tr><tr><td>4</td><td>并发编程面试题 （2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104563">https://blog.csdn.net/qq_43061290/article/details/124104563</a></td></tr><tr><td>5</td><td>JVM面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104514">https://blog.csdn.net/qq_43061290/article/details/124104514</a></td></tr><tr><td>6</td><td>Spring面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124227864">https://blog.csdn.net/qq_43061290/article/details/124227864</a></td></tr><tr><td>7</td><td>Spring MVC面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124337927">https://blog.csdn.net/qq_43061290/article/details/124337927</a></td></tr><tr><td>8</td><td>Spring Boot面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124339493">https://blog.csdn.net/qq_43061290/article/details/124339493</a></td></tr><tr><td>9</td><td>Spring Cloud面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124341152">https://blog.csdn.net/qq_43061290/article/details/124341152</a></td></tr><tr><td>10</td><td>MyBatis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124468306">https://blog.csdn.net/qq_43061290/article/details/124468306</a></td></tr><tr><td>11</td><td>Redis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124473691">https://blog.csdn.net/qq_43061290/article/details/124473691</a></td></tr><tr><td>12</td><td>MySQL数据库面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124427311">https://blog.csdn.net/qq_43061290/article/details/124427311</a></td></tr><tr><td>13</td><td>消息中间件MQ知识点（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124542376">https://blog.csdn.net/qq_43061290/article/details/124542376</a></td></tr><tr><td>14</td><td>ZooKeeper面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124548428">https://blog.csdn.net/qq_43061290/article/details/124548428</a></td></tr><tr><td>15</td><td>架构设计&amp;分布式&amp;数据结构与算法面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124624540">https://blog.csdn.net/qq_43061290/article/details/124624540</a></td></tr><tr><td>16</td><td>计算机网络编程面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124041420">https://blog.csdn.net/qq_43061290/article/details/124041420</a></td></tr></tbody></table><h1 id="1-1-Java概述"><a href="#1-1-Java概述" class="headerlink" title="1.1 Java概述"></a>1.1 Java概述</h1><h2 id="1-1-1-何为编程"><a href="#1-1-1-何为编程" class="headerlink" title="1.1.1 何为编程"></a>1.1.1 何为编程</h2><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p><h2 id="1-1-2-什么是Java"><a href="#1-1-2-什么是Java" class="headerlink" title="1.1.2 什么是Java"></a>1.1.2 什么是Java</h2><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。除此之外，还有目前比较流行的Python、Go等语言，适用于不同的处理场景。</p><h2 id="1-1-3-jdk1-5之后的三大版本"><a href="#1-1-3-jdk1-5之后的三大版本" class="headerlink" title="1.1.3 jdk1.5之后的三大版本"></a>1.1.3 jdk1.5之后的三大版本</h2><ul><li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li><li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEEJava ME（J2ME，Java 2 Platform Micro Edition，微型版）Java ME 以前称为 J2ME。</li><li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul><h2 id="1-1-4-JVM、JRE和JDK的关系"><a href="#1-1-4-JVM、JRE和JDK的关系" class="headerlink" title="1.1.4 JVM、JRE和JDK的关系"></a>1.1.4 JVM、JRE和JDK的关系</h2><ul><li>JVM<br>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li><li>JRE<br>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包<br>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li><li>JDK<br>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</li></ul><p><code>**JDK&gt;JRE&gt;JVM**</code><br>JDK&gt;JRE&gt;JVM</p><p><strong>JVM&amp;JRE&amp;JDK关系图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A01.png"></p><h2 id="1-1-5-什么是JAVA跨平台性，其原理是什么"><a href="#1-1-5-什么是JAVA跨平台性，其原理是什么" class="headerlink" title="1.1.5 什么是JAVA跨平台性，其原理是什么"></a>1.1.5 什么是JAVA跨平台性，其原理是什么</h2><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。<br>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h2 id="1-1-6-Java语言有哪些特点"><a href="#1-1-6-Java语言有哪些特点" class="headerlink" title="1.1.6 Java语言有哪些特点"></a>1.1.6 Java语言有哪些特点</h2><ul><li>简单易学（Java语言的语法与C语言和C++语言很接近）</li><li>面向对象（封装，继承，多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li><li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li><li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li><li>安全性</li></ul><h2 id="1-1-7-什么是字节码？采用字节码的最大好处是什么"><a href="#1-1-7-什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="1.1.7 什么是字节码？采用字节码的最大好处是什么"></a>1.1.7 什么是字节码？采用字节码的最大好处是什么</h2><ul><li>字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</li><li></li></ul><p><strong>采用字节码的好处：</strong></p><ul><li>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</li></ul><p><strong>先看下java中的编译器和解释器：</strong></p><ul><li>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</li></ul><p><strong>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。</strong></p><h2 id="1-1-8-什么是java程序的主类？应用程序和小程序的主类有何不同？"><a href="#1-1-8-什么是java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="1.1.8 什么是java程序的主类？应用程序和小程序的主类有何不同？"></a>1.1.8 什么是java程序的主类？应用程序和小程序的主类有何不同？</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><h2 id="1-1-9-java应用程序和小程序之间的差别"><a href="#1-1-9-java应用程序和小程序之间的差别" class="headerlink" title="1.1.9 java应用程序和小程序之间的差别"></a>1.1.9 java应用程序和小程序之间的差别</h2><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h2 id="1-1-10-java与C-的区别"><a href="#1-1-10-java与C-的区别" class="headerlink" title="1.1.10 java与C++的区别"></a>1.1.10 java与C++的区别</h2><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h2 id="1-1-11-Oracle-jDK-和OpenJdk的对比"><a href="#1-1-11-Oracle-jDK-和OpenJdk的对比" class="headerlink" title="1.1.11 Oracle jDK 和OpenJdk的对比"></a>1.1.11 Oracle jDK 和OpenJdk的对比</h2><p>（1）Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；<br>（2）OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；<br>（3）Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；<br>（4）在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；<br>（5）Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；<br>（6）Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</p><h1 id="1-2-Java基础语法"><a href="#1-2-Java基础语法" class="headerlink" title="1.2 Java基础语法"></a>1.2 Java基础语法</h1><h2 id="1-2-1-数据类型"><a href="#1-2-1-数据类型" class="headerlink" title="1.2.1 数据类型"></a>1.2.1 数据类型</h2><p><strong>Java有哪些数据类型</strong><br>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><p><strong>分类</strong><br><strong>基本数据类型</strong></p><ul><li>数值型</li><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li><li>字符型(char)</li><li>布尔型(boolean)</li></ul><p><strong>引用数据类型</strong></p><ul><li><p>类(class)</p></li><li><p>接口(interface)</p></li><li><p>数组([])<br>Java基本数据类型图</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A02.png"></p></li></ul><p>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上<br>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><p><strong>用最有效率的方法计算 2 乘以 8</strong><br>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p><p>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少<br>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p><p><strong>float f&#x3D;3.4;是否正确</strong><br>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p><p><strong>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</strong><br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p><p>而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p><p><strong>装箱和拆箱</strong><br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比 如：把 int 转化成 Integer，double 转化成 Double，等等。<br>反之就是自动拆箱。 原始类型: boolean，char，byte，short，int，long，float，double 封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>String 转出 int 型，判断能不能转？如何转？<br>答：可以转，得处理异常 Integer.parseInt(s) 主要为 NumberFormatException：1）当 你输入为字母时，也就是内容不是数字时，如 abcd<br>2）当你输入为空时<br>3）当你输入超出 int 上限时 Long.parseLong(“123”)转换为 long</p><h2 id="1-2-2-java-基本类型与引用类型的区别"><a href="#1-2-2-java-基本类型与引用类型的区别" class="headerlink" title="1.2.2 java 基本类型与引用类型的区别"></a>1.2.2 java 基本类型与引用类型的区别</h2><p>基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所 处的位置&#x2F;地址）</p><p><strong>int和Integer的区别</strong></p><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p><p><strong>延伸：</strong><br><strong>关于Integer和int的比较</strong><br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = new Integer(100);</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">int j = 100；</span><br><span class="line">System.out.print(i == j); //true</span><br></pre></td></tr></table></figure><p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128<del>127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128</del>127之间时，非new生成Integer变量时，java API中最终会按照new Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br><span class="line">Integer i = 128;</span><br><span class="line">Integer j = 128;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>对于第4条的原因：<br>java在编译Integer i &#x3D; 100 ;时，会翻译成为Integer i &#x3D; Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="built_in">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127进行缓存，下次再写Integer j &#x3D; 127时，就会直接从缓存中取，就不会new了</p><h2 id="1-2-3-编码及注释"><a href="#1-2-3-编码及注释" class="headerlink" title="1.2.3 编码及注释"></a>1.2.3 编码及注释</h2><p><strong>Java语言采用何种编码方案？有何特点？</strong><br>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><p>定义：用于解释说明程序的文字<br>分类<br>单行注释<br>格式： &#x2F;&#x2F; 注释文字<br>多行注释<br>格式： &#x2F;* 注释文字 <em>&#x2F;文档注释格式：&#x2F;</em>* 注释文字 *&#x2F;</p><p><strong>作用</strong><br>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。<br>注意事项：多行和文档注释都不能嵌套使用。</p><h2 id="1-2-4-访问修饰符"><a href="#1-2-4-访问修饰符" class="headerlink" title="1.2.4 访问修饰符"></a>1.2.4 访问修饰符</h2><p>访问修饰符 public,private,protected,以及不写（默认）时的区别<br>定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。<br><strong>分类</strong></p><ul><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法<br>访问修饰符图<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A03.png"></li></ul><h2 id="1-2-5-运算符"><a href="#1-2-5-运算符" class="headerlink" title="1.2.5 运算符"></a>1.2.5 运算符</h2><ul><li><p>&amp;和&amp;&amp;的区别</p><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><ul><li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li></ul></li></ul><h2 id="1-2-6-关键字"><a href="#1-2-6-关键字" class="headerlink" title="1.2.6 关键字"></a>1.2.6 关键字</h2><p><strong>Java 有没有 goto</strong><br>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><p><strong>final 有什么用？</strong></p><ul><li>用于修饰类、属性和方法；</li><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><p><strong>Final、 finally 、finalize区别</strong></p><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表<br>示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li></ul><p><strong>this关键字的用法</strong><br>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p>this的用法在java中大体可以分为3种：</p><ol><li>普通的直接引用，this相当于是指向当前对象本身。</li><li>形参与成员名字重名，用this来区分：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>引用本类的构造函数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>super关键字的用法</strong><br>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p><strong>super也有三种用法：</strong></p><ol><li>普通的直接引用</li></ol><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><ol><li>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1class Person&#123;</span><br><span class="line">2.    protected String name;</span><br><span class="line">3. </span><br><span class="line">4.    public Person(String name) &#123;</span><br><span class="line">5.        this.name = name;</span><br><span class="line">6.    &#125;</span><br><span class="line">7. </span><br><span class="line">8.&#125;</span><br><span class="line">9. </span><br><span class="line">10.class Student extends Person&#123;</span><br><span class="line">11.    private String name;</span><br><span class="line">12. </span><br><span class="line">13.    public Student(String name, String name1) &#123;</span><br><span class="line">14.        super(name);</span><br><span class="line">15.        this.name = name1;</span><br><span class="line">16.    &#125;</span><br><span class="line">17. </span><br><span class="line">18.    public void <span class="function"><span class="title">getInfo</span></span>()&#123;</span><br><span class="line">19.        System.out.println(this.name);      //Child</span><br><span class="line">20.        System.out.println(super.name);     //Father</span><br><span class="line">21.    &#125;</span><br><span class="line">22. </span><br><span class="line">23.&#125;</span><br><span class="line">24.</span><br><span class="line">25.public class Test &#123;</span><br><span class="line">26.    public static void main(String[] args) &#123;</span><br><span class="line">27.       Student s1 = new Student(<span class="string">&quot;Father&quot;</span>,<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">28.       s1.getInfo();</span><br><span class="line">29. </span><br><span class="line">30.    &#125;</span><br><span class="line">31.&#125;</span><br></pre></td></tr></table></figure><p>3、引用父类构造函数</p><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><p><strong>this与super的区别</strong></p><ul><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调 用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><p><strong>static存在的主要意义</strong></p><ul><li>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</li><li>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li></ul><p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><p><strong>static的独特之处</strong></p><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</p><blockquote><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p></blockquote><p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。<br>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！<br>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><p><strong>static应用场景</strong></p><p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。<br>因此比较常见的static应用场景有：<br>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p><p><strong>static注意事项</strong></p><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p><h2 id="1-2-7-流程控制语句"><a href="#1-2-7-流程控制语句" class="headerlink" title="1.2.7 流程控制语句"></a>1.2.7 流程控制语句</h2><p><strong>break ,continue ,return 的区别及作用</strong></p><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)<br>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><p><strong>在 Java 中，如何跳出当前的多重嵌套循环</strong></p><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == 5) &#123;</span><br><span class="line">                <span class="built_in">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-3-面向对象"><a href="#1-3-面向对象" class="headerlink" title="1.3 面向对象"></a>1.3 面向对象</h1><h2 id="1-3-1-面向对象概述"><a href="#1-3-1-面向对象概述" class="headerlink" title="1.3.1 面向对象概述"></a>1.3.1 面向对象概述</h2><p><strong>面向对象和面向过程的区别</strong><br><strong>面向过程：</strong></p><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul><p><strong>面向对象：</strong></p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul><p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p><p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h2 id="1-3-2-面向对象三大特性"><a href="#1-3-2-面向对象三大特性" class="headerlink" title="1.3.2 面向对象三大特性"></a>1.3.2 面向对象三大特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面向对象的特征主要有以下几个方面：抽象、封装、继承。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li><li>封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</li><li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关于继承如下 3 点请记住：</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><p><strong>多态</strong></p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中Java 面向对象编程三大特性：封装 继承 多态</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</li><li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</li></ul><p><strong>关于继承如下 3 点请记住：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.子类拥有父类非 private 的属性和方法。</span><br><span class="line"></span><br><span class="line">2子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</span><br><span class="line"></span><br><span class="line">3子类可以用自己的方式实现父类的方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</li></ul><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ul><p><strong>什么是多态机制？Java语言是如何实现多态的？</strong></p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。<br><strong>多态的实现</strong></p><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><p><strong>面向对象五大基本原则是什么（可选）</strong></p><p><strong>1 单一职责原则SRP(Single Responsibility Principle)</strong><br>类的功能要单一，不能包罗万象，跟杂货铺似的。<br><strong>2 开放封闭原则OCP(Open－Close Principle)</strong><br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。<br><strong>3 里式替换原则LSP(the Liskov Substitution Principle LSP)</strong><br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~<br><strong>4 依赖倒置原则DIP(the Dependency Inversion Principle DIP)</strong><br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。<br><strong>5 接口分离原则ISP(the Interface Segregation Principle ISP)</strong><br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p><p><strong>Java创建对象的方式</strong></p><p>1、<strong>使用new关键字</strong>：比如：Student student &#x3D; new Student();</p><p>2、<strong>使用Class类的newInstance方法</strong>：可以使用Class类的newInstance方法创建对象，这个newInstance方法调用无参的构造器创建对象，如：Student student2 &#x3D; (Student)Class.forName(“根路径.Student”).newInstance();　或者：Student stu &#x3D; Student.class.newInstance();</p><p>3、<strong>使用Constructor类的newInstance方法</strong>：本方法和Class类的newInstance方法很像，java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。如： Constructor constructor &#x3D; Student.class.getInstance(); Student stu &#x3D; constructor.newInstance();　这两种newInstance的方法就是大家所说的反射，事实上Class的newInstance方法内部调用Constructor的newInstance方法。这也是众多框架Spring、Hibernate、Struts等使用后者的原因。</p><p>4、<strong>使用Clone的方法</strong>：无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用clone方法创建对象并不会调用任何构造函数。要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。如：Student stu2 &#x3D; stu.clone();这也是原型模式的应用。</p><p>5、<strong>使用反序列化</strong>：序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：ObjectInputStream in &#x3D; new ObjectInputStream (new FileInputStream(“data.obj”)); Student stu3 &#x3D; (Student)in.readObject();</p><h2 id="1-3-3-类与接口"><a href="#1-3-3-类与接口" class="headerlink" title="1.3.3 类与接口"></a>1.3.3 类与接口</h2><p><strong>抽象类和接口的对比</strong></p><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。<br>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br><strong>相同点</strong></p><ul><li><p>接口和抽象类都不能实例化</p></li><li><p>都位于继承的顶端，用于被其他实现或继承</p></li><li><p>都包含抽象方法，其子类都必须覆写这些抽象方法</p><p><strong>不同点</strong><br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A04.png"></p></li></ul><p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。<br>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p><p><strong>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</strong></p><p>1.行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。<br>2.选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p><p><strong>普通类和抽象类有哪些区别？</strong></p><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><p><strong>抽象类能使用 final 修饰吗？</strong><br>答：不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><p><strong>创建一个对象用什么关键字？对象实例与对象引用有何不同？</strong><br>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h2 id="1-3-4-变量与方法"><a href="#1-3-4-变量与方法" class="headerlink" title="1.3.4 变量与方法"></a>1.3.4 变量与方法</h2><p><strong>成员变量与局部变量的区别有哪些</strong></p><ul><li>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li><li>成员变量：方法外部，类内部定义的变量</li><li>局部变量：类的方法中的变量。</li></ul><p>成员变量和局部变量的区别<br><strong>作用域</strong></p><ul><li>成员变量：针对整个类有效。</li><li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)<br><strong>存储位置</strong></li><li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li><li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。<br><strong>生命周期</strong></li><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：当方法调用完，或者语句结束后，就自动释放。<br><strong>初始值</strong></li><li>成员变量：有默认初始值。</li><li>局部变量：没有默认初始值，使用前必须赋值。<br><strong>使用原则</strong></li><li>在使用变量时需要遵循的原则为：就近原则</li><li>首先在局部范围找，有就使用；接着在成员位置找。</li></ul><p><strong>在Java中定义一个不做事且没有参数的构造方法的作用</strong></p><p>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><p><strong>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</strong></p><p>帮助子类做初始化工作。<br><strong>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</strong></p><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。<br><strong>构造方法有哪些特性？</strong></p><ul><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ul><p><strong>静态变量和实例变量区别</strong></p><ul><li>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li><li>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</li></ul><p><strong>静态变量与普通变量区别</strong><br>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<br>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p><p><strong>静态方法和实例方法有何不同？</strong><br>静态方法和实例方法的区别主要体现在两个方面：</p><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ul><p><strong>在一个静态方法内调用一个非静态成员为什么是非法的？</strong></p><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><p><strong>什么是方法的返回值？返回值的作用是什么？</strong></p><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p><h2 id="1-3-5-内部类"><a href="#1-3-5-内部类" class="headerlink" title="1.3.5 内部类"></a>1.3.5 内部类</h2><p><strong>什么是内部类？</strong></p><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p><p><strong>内部类的分类有哪些</strong></p><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类。</strong><br>静态内部类<br>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">    private static int radius = 1;</span><br><span class="line"></span><br><span class="line">    static class StaticInner &#123;</span><br><span class="line">        public void <span class="function"><span class="title">visit</span></span>() &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>成员内部类</strong><br>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private static  int radius = 1;</span><br><span class="line">    private int count =2;</span><br><span class="line">     class Inner &#123;</span><br><span class="line">        public void <span class="function"><span class="title">visit</span></span>() &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer   variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new Outer();</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br><span class="line">inner.visit();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>局部内部类</strong><br>定义在方法中的内部类，就是局部内部类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private  int out_a = 1;</span><br><span class="line">    private static int STATIC_b = 2;</span><br><span class="line">    public void <span class="function"><span class="title">testFunctionClass</span></span>()&#123;</span><br><span class="line">        int inner_c =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void <span class="function"><span class="title">testStaticFunctionClass</span></span>()&#123;</span><br><span class="line">        int d =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">                // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">testStaticFunctionClass</span></span>()&#123;</span><br><span class="line">    class Inner &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner  inner = new Inner();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>匿名内部类</strong><br>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private void <span class="built_in">test</span>(final int i) &#123;</span><br><span class="line">        new <span class="function"><span class="title">Service</span></span>() &#123;</span><br><span class="line">            public void <span class="function"><span class="title">method</span></span>() &#123;</span><br><span class="line">                <span class="keyword">for</span> (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line"> interface Service&#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除了没有名字，匿名内部类还有以下特点：</strong></p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><p><strong>匿名内部类创建方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new 类/接口&#123; </span><br><span class="line">  //匿名内部类实现部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>内部类的优点</strong><br><strong>我们为什么要使用内部类呢？因为它有以下优点：</strong></p><p>1一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</p><p>2内部类不为同一包的其他类所见，具有很好的封装性；</p><p>3内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</p><p>4匿名内部类可以很方便的定义回调。</p><p><strong>内部类有哪些应用场景</strong></p><ul><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ul><p><strong>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</strong></p><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？<br>先看这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    void <span class="function"><span class="title">outMethod</span></span>()&#123;</span><br><span class="line">        final int a =10;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            void <span class="function"><span class="title">innerMethod</span></span>()&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。<br>内部类相关，看程序说出运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private int age = 12;</span><br><span class="line">    class Inner &#123;</span><br><span class="line">        private int age = 13;</span><br><span class="line">        public void <span class="function"><span class="title">print</span></span>() &#123;</span><br><span class="line">            int age = 14;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部变量：&quot;</span> + age);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + this.age);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outer.this.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer.Inner <span class="keyword">in</span> = new Outer().new Inner();</span><br><span class="line">        in.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br>局部变量：14<br>内部类变量：13<br>外部类变量：12</p><h2 id="1-3-6-重写与重载、多态"><a href="#1-3-6-重写与重载、多态" class="headerlink" title="1.3.6 重写与重载、多态"></a>1.3.6 重写与重载、多态</h2><p><strong>构造器（constructor）是否可被重写（override）？</strong></p><p>答：构造器不能被继承，因此不能被重写，但可以被重载。</p><p><strong>Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</strong></p><p>答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法 是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</p><p><strong>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</strong></p><p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分，即：</p><p>1.可以在一个类中也可以在继承关系的类中；<br>2.名相同；<br>3.参数列表不同（个数，顺序，类型） 和方法的返回值类型无关。</p><p><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。即：</p><p>1.不能存在同一个类中，在继承或实现关系的类中；<br>\2. 名相同，参数列表相同，方法返回值相同，<br>3.子类方法的访问修饰符要大于父类的。<br>4.子类的检查异常类型要小于父类的检查异常</p><p><strong>多态在实际中的应用：</strong></p><p>答：在实际开发工作中，常常遇到一个功能有多种实现方式，比如支付方式，有分微信支付、京东支付、支付宝、银联等支付方式，不同支付方式的大概流程大抵相似，实现细节有所区别。这个时候就可以用到java的多态机制，先定义一个公共接口，接口定义支付流程的各个方法，具体的支付方式实现该接口的方法。在控制层，利用spring的注入获取支付类型和支付方式实现类的引用映射，根据请求需要的支付类型就可以调用对应支付方式的方法，以此实现业务的解耦和拓展。后期需要增加支付方式，只需要实现共同接口即可。</p><h2 id="1-3-7-对象相等判断"><a href="#1-3-7-对象相等判断" class="headerlink" title="1.3.7 对象相等判断"></a>1.3.7 对象相等判断</h2><p><strong>&#x3D;&#x3D;和 equals 的区别是什么</strong></p><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址。</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p><strong>情况1</strong>：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D; ” 比较这两个对象。</p><p><strong>情况2</strong>：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。<br>举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = new String(<span class="string">&quot;ab&quot;</span>); // a 为一个引用</span><br><span class="line">        String b = new String(<span class="string">&quot;ab&quot;</span>); // b为另一个引用,对象的内容一样</span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; // 放在常量池中</span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; // 从常量池中查找</span><br><span class="line">        <span class="keyword">if</span> (aa == bb) // <span class="literal">true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) // <span class="literal">false</span>，非同一对象</span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) // <span class="literal">true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (42 == 42.0) &#123; // <span class="literal">true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。<br><strong>hashCode 与 equals (重要)</strong></p><p>HashSet如何检查重复<br>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？<br>hashCode和equals方法的关系<br>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><p><strong>hashCode()介绍</strong><br>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>为什么要有 hashCode</strong></p><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：<br>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>hashCode()与equals()的相关规定</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等，对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li></ul><p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></p><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><p><strong>对象的相等与指向他们的引用相等，两者有什么不同？</strong></p><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h2 id="1-3-8-值传递"><a href="#1-3-8-值传递" class="headerlink" title="1.3.8 值传递"></a>1.3.8 值传递</h2><p><strong>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</strong></p><p>答：是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p><p><strong>为什么 Java 中只有值传递</strong></p><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。<br>下面通过 3 个例子来给大家说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">example 1</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = 20;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line">public static void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解析：</strong><br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A05.png"></p><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example 2</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">        System.out.println(arr[0]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void change(int[] array) &#123;</span><br><span class="line">        // 将数组的第一个元素变为0</span><br><span class="line">        array[0] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解析：<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A06.png"></p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。<br>很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">example 3</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Student s1 = new Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        Student s2 = new Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void swap(Student x, Student y) &#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解析：<br>交换之前：<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A07.png"></p><p>交换之后：<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A08.png"></p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p><p><strong>总结</strong></p><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。<br>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p><strong>值传递和引用传递有什么区别</strong></p><p><strong>值传递</strong>：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p><p><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><h2 id="1-3-9-Java包"><a href="#1-3-9-Java包" class="headerlink" title="1.3.9 Java包"></a>1.3.9 Java包</h2><p>JDK 中常用的包有哪些<br>java.lang：这个是系统的基础类；<br>java.io：这里面是所有输入输出有关的类，比如文件操作等；<br>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；<br>java.net：这里面是与网络有关的类；<br>java.util：这个是系统辅助类，特别是集合类；<br>java.sql：这个是数据库操作的类。</p><p><strong>import java和javax有什么区别</strong></p><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</p><p>所以，实际上java和javax没有区别。这都是一个名字。</p><h1 id="1-4-IO流"><a href="#1-4-IO流" class="headerlink" title="1.4 IO流"></a>1.4 IO流</h1><h2 id="1-4-1-Java中-IO-流分为几种"><a href="#1-4-1-Java中-IO-流分为几种" class="headerlink" title="1.4.1 Java中 IO 流分为几种?"></a>1.4.1 Java中 IO 流分为几种?</h2><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li><p>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p></li><li><p>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。<br>按操作方式分类结构图：<br><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A09.png"></p><p>按操作对象分类结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/JavaInterviewQuestions/01/A10.png"></p></li></ul><h2 id="1-4-2-BIO-NIO-AIO-有什么区别"><a href="#1-4-2-BIO-NIO-AIO-有什么区别" class="headerlink" title="1.4.2 BIO,NIO,AIO 有什么区别?"></a>1.4.2 BIO,NIO,AIO 有什么区别?</h2><p>简答</p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><p><strong>详细回答</strong></p><ul><li><strong>BIO (Blocking I&#x2F;O)</strong>: 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I&#x2F;O)</strong>: NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I&#x2F;O)</strong>: AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h2 id="1-4-3-Files的常用方法都有哪些？"><a href="#1-4-3-Files的常用方法都有哪些？" class="headerlink" title="1.4.3 Files的常用方法都有哪些？"></a>1.4.3 Files的常用方法都有哪些？</h2><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。</p><h1 id="1-5-反射"><a href="#1-5-反射" class="headerlink" title="1.5 反射"></a>1.5 反射</h1><h2 id="1-5-1-什么是反射机制"><a href="#1-5-1-什么是反射机制" class="headerlink" title="1.5.1 什么是反射机制"></a>1.5.1 什么是反射机制</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p><strong>静态编译和动态编译</strong></p><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h2 id="1-5-2-反射机制优缺点"><a href="#1-5-2-反射机制优缺点" class="headerlink" title="1.5.2 反射机制优缺点"></a>1.5.2 反射机制优缺点</h2><p>• 优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p><p>• 缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p><h2 id="1-5-3-反射机制的应用场景"><a href="#1-5-3-反射机制的应用场景" class="headerlink" title="1.5.3 反射机制的应用场景"></a>1.5.3 反射机制的应用场景</h2><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：<br>①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</p><p><strong>Spring 通过 XML 配置模式装载 Bean 的过程：</strong></p><p>1)将程序内所有 XML 或 Properties 配置文件加载入内存中;</p><p>2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</p><p>3)使用反射机制，根据这个字符串获得某个类的Class实例;</p><p>4)动态配置实例的属性</p><h2 id="1-5-4-Java获取反射的三种方法"><a href="#1-5-4-Java获取反射的三种方法" class="headerlink" title="1.5.4 Java获取反射的三种方法"></a>1.5.4 Java获取反射的三种方法</h2><p><strong>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int <span class="built_in">id</span>;</span><br><span class="line">    String name;</span><br><span class="line">    protected boolean sex;</span><br><span class="line">    public <span class="built_in">float</span> score;</span><br><span class="line">&#125;</span><br><span class="line">public class Get &#123;</span><br><span class="line">    //获取反射机制三种方式</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        //方式一(通过建立对象)</span><br><span class="line">        Student stu = new Student();</span><br><span class="line">        Class classobj1 = stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        //方式二（所在通过路径-相对路径）</span><br><span class="line">        Class classobj2 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        //方式三（通过类名）</span><br><span class="line">        Class classobj3 = Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>反射机制详细介绍</code><br>包括：获取Class对象的方式、获取成员变量、获取构造方法等等。参考：<a href="https://blog.csdn.net/qq_43061290/article/details/105064453">https://blog.csdn.net/qq_43061290/article/details/105064453</a></p><h1 id="1-6-网络编程"><a href="#1-6-网络编程" class="headerlink" title="1.6 网络编程"></a>1.6 网络编程</h1><p><a href="https://blog.csdn.net/qq_43061290/article/details/124041420">网络编程的面试题</a><br>重学TCP&#x2F;IP协议和三次握手四次挥手，包括TCP&#x2F;IP协议和三次握手四次挥手的知识，计算机网络体系结构，HTTP协议，get请求和post请求区别，session和cookie的区别等。<br>欢迎大家阅读第14章：<a href="https://blog.csdn.net/qq_43061290/article/details/124041420">https://blog.csdn.net/qq_43061290/article/details/124041420</a></p><h1 id="1-7-常用API"><a href="#1-7-常用API" class="headerlink" title="1.7 常用API"></a>1.7 常用API</h1><h2 id="1-7-1-String-相关-StringBuffer、StringBuilde"><a href="#1-7-1-String-相关-StringBuffer、StringBuilde" class="headerlink" title="1.7.1 String 相关:StringBuffer、StringBuilde"></a>1.7.1 String 相关:StringBuffer、StringBuilde</h2><p><strong>字符型常量和字符串常量的区别</strong></p><ul><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占两个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ul><p><strong>什么是字符串常量池？</strong></p><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p><p><strong>String 是最基本的数据类型吗</strong></p><p>答：不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};</p><p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p><p><strong>String有哪些特性</strong></p><ul><li>1、不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>2、常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>3、final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><p><strong>String为什么是不可变的吗？</strong></p><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/** The value is used <span class="keyword">for</span> character storage. */</span><br><span class="line">private final char value[];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>String真的是不可变的吗？</strong></p><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：<br>1）String不可变但不代表引用不可以变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span> + str);</span><br><span class="line">结果：</span><br><span class="line">str=Hello World</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解析：<br>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><ol><li>通过反射是可以修改所谓的“不可变”对象</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建字符串<span class="string">&quot;Hello World&quot;</span>， 并赋给引用s</span><br><span class="line">String s = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); // Hello World</span><br><span class="line">// 获取String类中的value字段</span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">// 改变value属性的访问权限</span><br><span class="line">valueFieldOfString.setAccessible(<span class="literal">true</span>);</span><br><span class="line">// 获取s对象上的value属性的值</span><br><span class="line">char[] value = (char[]) valueFieldOfString.get(s);</span><br><span class="line">// 改变value所引用的数组中的第5个字符</span><br><span class="line">value[5] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); // Hello_World</span><br><span class="line">结果：</span><br><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><p><strong>是否可以继承 String 类</strong></p><p>答：String 类是 final 类，不可以被继承。</p><p><strong>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</strong></p><p>答：不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</p><p><strong>String s &#x3D; new String(“xyz”);创建了几个字符串对象</strong></p><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>; //str1指向静态区</span><br><span class="line">String str2 = new String(<span class="string">&quot;hello&quot;</span>);  //str2指向堆上的对象</span><br><span class="line">String str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str4 = new String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); //true</span><br><span class="line">System.out.println(str2.equals(str4)); //true</span><br><span class="line">System.out.println(str1 == str3); //true</span><br><span class="line">System.out.println(str1 == str2); //false</span><br><span class="line">System.out.println(str2 == str4); //false</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); //false</span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); //true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如何将字符串反转？</strong></p><p>答：使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>数组有没有 length()方法？String 有没有 length()方法</strong></p><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</p><p><strong>String 类的常用方法都有那些？</strong></p><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p><p><strong>在使用 HashMap 的时候，用 String 做 key 有什么好处？</strong></p><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><p><strong>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</strong></p><ul><li>1、可变性<br>String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</li><li>2、线程安全性<br>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li><li>3、性能<br>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><p><strong>对于三者使用的总结</strong></p><p>如果要操作少量的数据用 &#x3D; String<br>单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p><p><strong>String，是否可以继承，“+”怎样实现，与 StringBuffer 区别</strong></p><p>答：在Java中，使用“+”来串联字符串的时候，实际上底层是通过StirngBuilder实例的append()实现的。</p><p><strong>String有重写Object的 hashcode和toString吗？如果重写Equals不重写hashcode会出现什么问题？</strong></p><p>答：String重写了Object类的hashcode和toString方法。<br>当equals方法被重写时，通常有必要重写hashcode方法，以维护hashCode方法的常规协定，该协定声明相等的俩个对象必须有相同的hashcode.<br>Object1.euqal(object2)为true，Object1.hashCode()&#x3D;&#x3D;Object2.hashCode()则为true。<br>Object1.hashCode()&#x3D;&#x3D;Object2.hashCode()为false，Object1.euqal(object2)必定为false。<br>Object1.hashCode()&#x3D;&#x3D;Object2.hashCode()为true，Object1.euqal(object2)不一定为true。</p><h2 id="1-7-2-Date相关"><a href="#1-7-2-Date相关" class="headerlink" title="1.7.2 Date相关"></a>1.7.2 Date相关</h2><h2 id="1-7-3-包装类相关"><a href="#1-7-3-包装类相关" class="headerlink" title="1.7.3 包装类相关"></a>1.7.3 包装类相关</h2><p><strong>自动装箱与拆箱</strong></p><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><p><strong>int 和 Integer 有什么区别</strong></p><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p><p><strong>Java 为每个原始类型提供了包装类型：</strong></p><p>原始类型: boolean，char，byte，short，int，long，float，double<br>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><p><strong>int与Integer的基本使用对比</strong></p><p>• Integer是int的包装类；int是基本数据类型；<br>• Integer变量必须实例化后才能使用；int变量不需要；<br>• Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；<br>• Integer的默认值是null；int的默认值是0。</p><p><strong>int与Integer的深入对比</strong><br>（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</span><br><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = new Integer(100);</span><br><span class="line">System.out.print(i == j); //false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">int j = 100；</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（4）对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br><span class="line">Integer i = 128;</span><br><span class="line">Integer j = 128;</span><br><span class="line">System.out.print(i == j); //false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于第4条的原因： java在编译Integer i &#x3D; 100 ;时，会翻译成为Integer i &#x3D; Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127这个Integer对象进行缓存，下次再写Integer j &#x3D; 127时，就会直接从缓存中取，就不会new了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="built_in">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> new Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-8-常用的工具类库"><a href="#1-8-常用的工具类库" class="headerlink" title="1.8 常用的工具类库"></a>1.8 常用的工具类库</h1><h1 id="1-9-栈、堆、方法区存储的内容"><a href="#1-9-栈、堆、方法区存储的内容" class="headerlink" title="1.9 栈、堆、方法区存储的内容"></a>1.9 栈、堆、方法区存储的内容</h1><p><strong>堆区:</strong></p><p>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)</p><p>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。</p><p><strong>栈区:</strong></p><p>1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用<br>2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p><p><strong>方法区:</strong></p><p>1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。<br>2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
