<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/02/20/javaInterviewQuestions/3.%20Java%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/02/20/javaInterviewQuestions/3.%20Java%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java异常面试题（2022版）"><a href="#Java异常面试题（2022版）" class="headerlink" title="Java异常面试题（2022版）"></a>Java异常面试题（2022版）</h1><table><thead><tr><th>序列号</th><th>内容</th><th>链接</th></tr></thead><tbody><tr><td>1</td><td>Java基础知识面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124023797">https://blog.csdn.net/qq_43061290/article/details/124023797</a></td></tr><tr><td>2</td><td>Java集合容器面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124043363">https://blog.csdn.net/qq_43061290/article/details/124043363</a></td></tr><tr><td>3</td><td>Java异常面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124078378">https://blog.csdn.net/qq_43061290/article/details/124078378</a></td></tr><tr><td>4</td><td>并发编程面试题 （2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104563">https://blog.csdn.net/qq_43061290/article/details/124104563</a></td></tr><tr><td>5</td><td>JVM面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104514">https://blog.csdn.net/qq_43061290/article/details/124104514</a></td></tr><tr><td>6</td><td>Spring面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124227864">https://blog.csdn.net/qq_43061290/article/details/124227864</a></td></tr><tr><td>7</td><td>Spring MVC面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124337927">https://blog.csdn.net/qq_43061290/article/details/124337927</a></td></tr><tr><td>8</td><td>Spring Boot面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124339493">https://blog.csdn.net/qq_43061290/article/details/124339493</a></td></tr><tr><td>9</td><td>Spring Cloud面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124341152">https://blog.csdn.net/qq_43061290/article/details/124341152</a></td></tr><tr><td>10</td><td>MyBatis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124468306">https://blog.csdn.net/qq_43061290/article/details/124468306</a></td></tr><tr><td>11</td><td>Redis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124473691">https://blog.csdn.net/qq_43061290/article/details/124473691</a></td></tr><tr><td>12</td><td>MySQL数据库面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124427311">https://blog.csdn.net/qq_43061290/article/details/124427311</a></td></tr><tr><td>13</td><td>消息中间件MQ知识点（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124542376">https://blog.csdn.net/qq_43061290/article/details/124542376</a></td></tr><tr><td>14</td><td>ZooKeeper面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124548428">https://blog.csdn.net/qq_43061290/article/details/124548428</a></td></tr><tr><td>15</td><td>架构设计&amp;分布式&amp;数据结构与算法面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124624540">https://blog.csdn.net/qq_43061290/article/details/124624540</a></td></tr><tr><td>16</td><td>计算机网络编程面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124041420">https://blog.csdn.net/qq_43061290/article/details/124041420</a></td></tr></tbody></table><h1 id="1-1-异常简介"><a href="#1-1-异常简介" class="headerlink" title="1.1 异常简介"></a>1.1 异常简介</h1><p>Java异常是Java提供的一种识别及响应错误的一致性机制。<br>Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。</p><h2 id="1-2-Java异常架构"><a href="#1-2-Java异常架构" class="headerlink" title="1.2 Java异常架构"></a>1.2 Java异常架构</h2><p>![在这里插入图片描述](3. Java异常.assets&#x2F;cb4d777ebd614caca5dc69a681ac98c1.png)</p><p><strong>1. Throwable</strong></p><p>Throwable 是 Java 语言中所有错误与异常的超类。</p><p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p><p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p><p><strong>2. Error（错误）</strong></p><p>定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p><p>特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p><p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p><p><strong>3. Exception（异常）</strong></p><p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：<strong>运行时异常和编译时异常</strong>。</p><p><strong>运行时异常</strong><br>定义：RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。</p><p>特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p><p>RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p><p><strong>编译时异常</strong></p><p>定义: Exception 中除 RuntimeException 及其子类之外的异常。</p><p>特点: Java 编译器会检查它。如果程序中出现此类异常，比如ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。该异常我们必须手动在代码里添加捕获语句来处理该异常。</p><p><strong>4. 受检异常与非受检异常</strong></p><p>Java 的所有异常可以分为受检异常（checked exception）和非受检异常（unchecked exception）。</p><p><strong>受检异常</strong></p><p>编译器要求必须处理的异常。正确的程序在运行过程中，经常容易出现的、符合预期的异常情况。一旦发生此类异常，就必须采用某种方式进行处理。<strong>除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常</strong>。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过。</p><p><strong>非受检异常</strong></p><p>编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。<strong>该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）</strong>。</p><h2 id="1-3-Java异常关键字"><a href="#1-3-Java异常关键字" class="headerlink" title="1.3 Java异常关键字"></a>1.3 Java异常关键字</h2><ul><li>try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li><li>catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li><li>finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li><li>throw – 用于抛出异常。</li><li>throws – 用在方法签名中，用于声明该方法可能抛出的异常。</li></ul><h1 id="2-Java异常处理"><a href="#2-Java异常处理" class="headerlink" title="2 Java异常处理"></a>2 Java异常处理</h1><p>![在这里插入图片描述](3. Java异常.assets&#x2F;d6468eaeb9644d538a2e8bf86a21cb43.png)<br>Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和 finally。</p><p>在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。</p><h2 id="2-1-声明异常"><a href="#2-1-声明异常" class="headerlink" title="2.1 声明异常"></a>2.1 声明异常</h2><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><p><strong>注意</strong></p><ul><li>非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。</li><li>一个方法出现编译时异常，就需要 try-catch&#x2F; throws 处理，否则会导致编译错误。</li></ul><h2 id="2-2-抛出异常"><a href="#2-2-抛出异常" class="headerlink" title="2.2 抛出异常"></a>2.2 抛出异常</h2><p>如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。</p><p>throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。</p><h2 id="2-3-捕获异常"><a href="#2-3-捕获异常" class="headerlink" title="2.3 捕获异常"></a>2.3 捕获异常</h2><p>程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。</p><h2 id="2-4-如何选择异常类型"><a href="#2-4-如何选择异常类型" class="headerlink" title="2.4 如何选择异常类型"></a>2.4 如何选择异常类型</h2><p>可以根据下图来选择是捕获异常，声明异常还是抛出异常<br>![在这里插入图片描述](3. Java异常.assets&#x2F;89f3b333086848a6a1666e567fff166b.png)</p><h2 id="2-5-常见异常处理方式"><a href="#2-5-常见异常处理方式" class="headerlink" title="2.5 常见异常处理方式"></a>2.5 常见异常处理方式</h2><p><strong>直接抛出异常</strong></p><p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) throws IOException &#123;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = new BufferedReader(new FileReader(file));</span><br><span class="line">    <span class="keyword">while</span>((result = reader.readLine())!=null) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装异常再抛出</strong></p><p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) throws MyException &#123;    </span><br><span class="line">    try &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        MyException ex = new MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>捕获异常</strong><br>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        // handle FileNotFoundException</span><br><span class="line">    &#125; catch (IOException e)&#123;</span><br><span class="line">        // handle IOException</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (FileNotFoundException | UnknownHostException e) &#123;</span><br><span class="line">        // handle FileNotFoundException or UnknownHostException</span><br><span class="line">    &#125; catch (IOException e)&#123;</span><br><span class="line">        // handle IOException</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义异常</strong></p><p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line">    public <span class="function"><span class="title">MyException</span></span>()&#123; &#125;</span><br><span class="line">    public MyException(String msg)&#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><p>当方法中发生异常，异常处之后的代码不会再执行，如果之前获取了一些本地资源需要释放，则需要在方法正常结束时和 catch 语句中都调用释放本地资源的代码，显得代码比较繁琐，finally 语句可以解决这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private static void readFile(String filePath) throws MyException &#123;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    String result;</span><br><span class="line">    BufferedReader reader = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        reader = new BufferedReader(new FileReader(file));</span><br><span class="line">        <span class="keyword">while</span>((result = reader.readLine())!=null) &#123;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">        MyException ex = new MyException(<span class="string">&quot;read file failed.&quot;</span>);</span><br><span class="line">        ex.initCause(e);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;readFile method finally block.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (null != reader) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法时，读取文件时若发生异常，代码会进入 catch 代码块，之后进入 finally 代码块；若读取文件时未发生异常，则会跳过 catch 代码块直接进入 finally 代码块。所以无论代码中是否发生异常，fianlly 中的代码都会执行。</p><p>若 catch 代码块中包含 return 语句，finally 中的代码还会执行吗？将以上代码中的 catch 子句修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;readFile method catch block.&quot;</span>);</span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 readFile 方法，观察当 catch 子句中调用 return 语句时，finally 子句是否执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readFile method catch block.</span><br><span class="line">readFile method finally block.</span><br></pre></td></tr></table></figure><p>可见，即使 catch 中包含了 return 语句，finally 子句依然会执行。若 finally 中也包含 return 语句，finally 中的 return 会覆盖前面的 return.</p><p><strong>try-with-resource</strong></p><p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private  static void <span class="function"><span class="title">tryWithResourceTest</span></span>()&#123;</span><br><span class="line">    try (Scanner scanner = new Scanner(new FileInputStream(<span class="string">&quot;c:/abc&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>))&#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125; catch (IOException e)&#123;</span><br><span class="line">        // handle exception</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p><h1 id="3-Java异常常见面试题"><a href="#3-Java异常常见面试题" class="headerlink" title="3 Java异常常见面试题"></a>3 Java异常常见面试题</h1><h2 id="3-1-Error和Exception区别是什么？"><a href="#3-1-Error和Exception区别是什么？" class="headerlink" title="3.1 Error和Exception区别是什么？"></a>3.1 Error和Exception区别是什么？</h2><p>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</p><p>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p><h2 id="3-2-运行时异常和一般异常-受检异常-区别是什么？"><a href="#3-2-运行时异常和一般异常-受检异常-区别是什么？" class="headerlink" title="3.2 运行时异常和一般异常(受检异常)区别是什么？"></a>3.2 运行时异常和一般异常(受检异常)区别是什么？</h2><p>运行时异常包括 RuntimeException 类及其子类，表示 JVM 在运行期间可能出现的异常。 Java 编译器不会检查运行时异常。</p><p>受检异常是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检异常。</p><p>RuntimeException异常和受检异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。</p><h2 id="3-3-JVM-是如何处理异常的？"><a href="#3-3-JVM-是如何处理异常的？" class="headerlink" title="3.3 JVM 是如何处理异常的？"></a>3.3 JVM 是如何处理异常的？</h2><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含异常名称，异常描述以及异常发生时应用程序的状态。创建异常对象并转交给 JVM 的过程称为抛出异常。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p><p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。</p><h2 id="3-4-throw-和-throws-的区别是什么？"><a href="#3-4-throw-和-throws-的区别是什么？" class="headerlink" title="3.4 throw 和 throws 的区别是什么？"></a>3.4 throw 和 throws 的区别是什么？</h2><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。<br><strong>throws 关键字和 throw 关键字在使用上的几点区别如下：</strong></p><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h2 id="3-5-final、finally、finalize-有什么区别？"><a href="#3-5-final、finally、finalize-有什么区别？" class="headerlink" title="3.5 final、finally、finalize 有什么区别？"></a>3.5 final、finally、finalize 有什么区别？</h2><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li></ul><h2 id="3-6-NoClassDefFoundError-和-ClassNotFoundException-区别？"><a href="#3-6-NoClassDefFoundError-和-ClassNotFoundException-区别？" class="headerlink" title="3.6 NoClassDefFoundError 和 ClassNotFoundException 区别？"></a>3.6 NoClassDefFoundError 和 ClassNotFoundException 区别？</h2><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。</p><p>引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是变异后被删除了等原因导致；</p><p>ClassNotFoundException 是一个受查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p><h2 id="3-7-try-catch-finally-中哪个部分可以省略？"><a href="#3-7-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="3.7 try-catch-finally 中哪个部分可以省略？"></a>3.7 try-catch-finally 中哪个部分可以省略？</h2><p>答：catch 可以省略</p><p><strong>原因</strong></p><p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p><p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p><p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p><h2 id="3-8-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#3-8-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="3.8 try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>3.8 try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><p>答：会执行，在 return 前执行。</p><p>注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。<br>代码示例1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int <span class="function"><span class="title">getInt</span></span>() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(a / 0);</span><br><span class="line">        a = 20;</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        a = 30;</span><br><span class="line">        <span class="built_in">return</span> a;</span><br><span class="line">        /*</span><br><span class="line">         * <span class="built_in">return</span> a 在程序执行到这一步的时候，这里不是<span class="built_in">return</span> a 而是 <span class="built_in">return</span> 30；这个返回路径就形成了</span><br><span class="line">         * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40</span><br><span class="line">         * 再次回到以前的路径,继续走<span class="built_in">return</span> 30，形成返回路径之后，这里的a就不是a变量了，而是常量30</span><br><span class="line">         */</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        a = 40;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：30<br>代码示例2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int <span class="function"><span class="title">getInt</span></span>() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(a / 0);</span><br><span class="line">        a = 20;</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        a = 30;</span><br><span class="line">        <span class="built_in">return</span> a;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        a = 40;</span><br><span class="line">        //如果这样，就又重新形成了一条返回路径，由于只能通过1个<span class="built_in">return</span>返回，所以这里直接返回40</span><br><span class="line">        <span class="built_in">return</span> a; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：40</p><h2 id="3-9-ExampleA-继承-Exception，类-ExampleB-继承ExampleA"><a href="#3-9-ExampleA-继承-Exception，类-ExampleB-继承ExampleA" class="headerlink" title="3.9 ExampleA 继承 Exception，类 ExampleB 继承ExampleA"></a>3.9 ExampleA 继承 Exception，类 ExampleB 继承ExampleA</h2><p>有如下代码片断：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">throw new ExampleB(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125; catch（ExampleA e）&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;ExampleA&quot;</span>);</span><br><span class="line">&#125; catch（Exception e）&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问执行此段代码的输出是什么？</p><p>答：</p><p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB 类型的异常）</p><p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一书）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Annoyance extends Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Sneeze extends Annoyance &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Human &#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">throws Exception &#123;</span><br><span class="line">try &#123;</span><br><span class="line">try &#123;</span><br><span class="line">throw new Sneeze();</span><br><span class="line">&#125; catch ( Annoyance a ) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>);</span><br><span class="line">throw a;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch ( Sneeze s ) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>);</span><br><span class="line"><span class="built_in">return</span> ;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果</span><br><span class="line">Caught Annoyance</span><br><span class="line">Caught Sneeze</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><h2 id="3-10-常见的-RuntimeException-有哪些？"><a href="#3-10-常见的-RuntimeException-有哪些？" class="headerlink" title="3.10 常见的 RuntimeException 有哪些？"></a>3.10 常见的 RuntimeException 有哪些？</h2><ul><li>ClassCastException(类转换异常)</li><li>IndexOutOfBoundsException(数组越界)</li><li>NullPointerException(空指针)</li><li>ArrayStoreException(数据存储异常，操作数组时类型不一致)</li><li>还有IO操作的BufferOverflowException异常</li></ul><h2 id="3-11-Java常见异常有哪些"><a href="#3-11-Java常见异常有哪些" class="headerlink" title="3.11 Java常见异常有哪些"></a>3.11 Java常见异常有哪些</h2><p>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</p><p>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</p><p>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p><p>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</p><p>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p><p>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p><p>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</p><p>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</p><p>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</p><p>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</p><p>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</p><p>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</p><p>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</p><p>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p><p>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</p><h1 id="4-Java异常处理最佳实践"><a href="#4-Java异常处理最佳实践" class="headerlink" title="4 Java异常处理最佳实践"></a>4 Java异常处理最佳实践</h1><p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。而团队之间的这些规范往往是截然不同的。</p><p>本文给出几个被很多团队使用的异常处理最佳实践。</p><h2 id="4-1-在-finally-块中清理资源或者使用-try-with-resource-语句"><a href="#4-1-在-finally-块中清理资源或者使用-try-with-resource-语句" class="headerlink" title="4.1 在 finally 块中清理资源或者使用 try-with-resource 语句"></a>4.1 在 finally 块中清理资源或者使用 try-with-resource 语句</h2><p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">doNotCloseResourceInTry</span></span>() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        // use the inputStream to <span class="built_in">read</span> a file</span><br><span class="line">        // <span class="keyword">do</span> NOT <span class="keyword">do</span> this</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p><p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p><p><strong>使用 finally 代码块</strong><br>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">closeResourceInFinally</span></span>() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        // use the inputStream to <span class="built_in">read</span> a file</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java 7 的 try-with-resource 语法</strong></p><p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">automaticallyCloseResource</span></span>() &#123;</span><br><span class="line">    File file = new File(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    try (FileInputStream inputStream = new FileInputStream(file);) &#123;</span><br><span class="line">        // use the inputStream to <span class="built_in">read</span> a file</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-优先明确的异常"><a href="#4-2-优先明确的异常" class="headerlink" title="4.2 优先明确的异常"></a>4.2 优先明确的异常</h2><p>因此需要保证提供给他们尽可能多的信息。这样你的 API 更容易被理解。你的方法的调用者能够更好的处理异常并且避免额外的检查。<br>因此，总是尝试寻找最适合你的异常事件的类，例如，抛出一个 NumberFormatException 来替换一个 IllegalArgumentException 。避免抛出一个不明确的异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void doNotDoThis() throws Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">public void doThis() throws NumberFormatException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-对异常进行文档说明"><a href="#4-3-对异常进行文档说明" class="headerlink" title="4.3 对异常进行文档说明"></a>4.3 对异常进行文档说明</h2><p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。<br>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething(String input) throws MyBusinessException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-使用描述性消息抛出异常"><a href="#4-4-使用描述性消息抛出异常" class="headerlink" title="4.4 使用描述性消息抛出异常"></a>4.4 使用描述性消息抛出异常</h2><p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p><p>但这里并不是说要对错误信息长篇大论，因为本来 Exception 的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p><p>如果抛出一个特定的异常，它的类名很可能已经描述了这种错误。所以，你不需要提供很多额外的信息。一个很好的例子是 NumberFormatException 。当你以错误的格式提供 String 时，它将被 java.lang.Long 类的构造函数抛出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    new Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-优先捕获最具体的异常"><a href="#4-5-优先捕获最具体的异常" class="headerlink" title="4.5 优先捕获最具体的异常"></a>4.5 优先捕获最具体的异常</h2><p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p><p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p><p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。<br>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">catchMostSpecificExceptionFirst</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        doSomething(<span class="string">&quot;A message&quot;</span>);</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        log.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-不要捕获-Throwable-类"><a href="#4-6-不要捕获-Throwable-类" class="headerlink" title="4.6 不要捕获 Throwable 类"></a>4.6 不要捕获 Throwable 类</h2><p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p><p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p><p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">doNotCatchThrowable</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // don<span class="string">&#x27;t do this!</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4-7-不要忽略异常"><a href="#4-7-不要忽略异常" class="headerlink" title="4.7 不要忽略异常"></a>4.7 不要忽略异常</h2><p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">doNotIgnoreExceptions</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        // this will never happen</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。<br>合理的做法是至少要记录异常的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">logAnException</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;This should never happen: &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-8-不要记录并抛出异常"><a href="#4-8-不要记录并抛出异常" class="headerlink" title="4.8 不要记录并抛出异常"></a>4.8 不要记录并抛出异常</h2><p>这可能是本文中最常被忽略的最佳实践。可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    new Long(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.NumberFormatException: For input string: <span class="string">&quot;xyz&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:589)</span><br><span class="line">at java.lang.Long.(Long.java:965)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)</span><br><span class="line">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)</span><br></pre></td></tr></table></figure><p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        throw new MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p><h2 id="4-9-包装异常时不要抛弃原始的异常"><a href="#4-9-包装异常时不要抛弃原始的异常" class="headerlink" title="4.9 包装异常时不要抛弃原始的异常"></a>4.9 包装异常时不要抛弃原始的异常</h2><p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。<br>在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">do</span> something</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        throw new MyBusinessException(<span class="string">&quot;A message that describes the error.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-不要使用异常控制程序的流程"><a href="#4-10-不要使用异常控制程序的流程" class="headerlink" title="4.10 不要使用异常控制程序的流程"></a>4.10 不要使用异常控制程序的流程</h2><p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p><h2 id="4-11-使用标准异常"><a href="#4-11-使用标准异常" class="headerlink" title="4.11 使用标准异常"></a>4.11 使用标准异常</h2><p>如果使用内建的异常可以解决问题，就不要定义自己的异常。Java API 提供了上百种针对不同情况的异常类型，在开发中首先尽可能使用 Java API 提供的异常，如果标准的异常不能满足你的要求，这时候创建自己的定制异常。尽可能得使用标准异常有利于新加入的开发者看懂项目代码。</p><h2 id="4-12-异常会影响性能"><a href="#4-12-异常会影响性能" class="headerlink" title="4.12 异常会影响性能"></a>4.12 异常会影响性能</h2><p>异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。<br>仅在异常情况下使用异常；<br>在可恢复的异常情况下使用异常；<br>尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</p><h2 id="4-13-总结"><a href="#4-13-总结" class="headerlink" title="4.13 总结"></a>4.13 总结</h2><p>综上所述，当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。<br>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p><p>异常处理-阿里巴巴Java开发手册<br>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过catch NumberFormatException来实现。 正例：if (obj !&#x3D; null) {…} 反例：try { obj.method(); } catch (NullPointerException e) {…}</p><p>【强制】异常不要用来做流程控制，条件控制。 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</p><p>【强制】不要在finally块中使用return。 说明：try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 反例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private int x = 0;</span><br><span class="line">public int <span class="function"><span class="title">checkReturn</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // x等于1，此处不返回</span><br><span class="line">        <span class="built_in">return</span> ++x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 返回的结果是2</span><br><span class="line">        <span class="built_in">return</span> ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p><p>【强制】在调用RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用Throwable类来进行拦截。 说明：通过反射机制来调用方法，如果找不到方法，抛出NoSuchMethodException。什么情况会抛出NoSuchMethodError呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出NoSuchMethodError。</p><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： 1） 返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 2） 数据库的查询结果可能为null。 3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 5） 对于Session中获取的数据，建议进行NPE检查，避免空指针。 6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br>正例：使用JDK8的Optional类来防止NPE问题。</p><p>【推荐】定义时区分unchecked &#x2F; checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException &#x2F; ServiceException等。</p><p>【参考】对于公司外的http&#x2F;api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 说明：关于RPC方法返回方式使用Result方式的理由： 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto) {…}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Puls学习</title>
      <link href="/2022/12/01/MyBatis-Puls/"/>
      <url>/2022/12/01/MyBatis-Puls/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis-Puls"><a href="#MyBatis-Puls" class="headerlink" title="MyBatis-Puls"></a>MyBatis-Puls</h1><h2 id="1、MyBatisPlus概述"><a href="#1、MyBatisPlus概述" class="headerlink" title="1、MyBatisPlus概述"></a>1、MyBatisPlus概述</h2><p>需要的基础：学完MyBatis、Spring、SpringMVC就可以学习这个了！</p><p>为什么学习它呢？MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码他都可以自动化完成！</p><p>JPA、tk-mapper、MyBatisPlus</p><blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2></blockquote><p>是什么？MyBatis本来就是简化JDBC操作的！</p><p>官网：<a href="https://baomidou.com/">MyBatis-Plus (baomidou.com)</a>，简化Mybaits！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/01.png" alt="1669374703084"></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/02.png" alt="1669375014235"></p><blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2></blockquote><ul><li><p><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</p></li><li><p><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</p></li><li><p><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</p></li><li><p><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</p></li><li><p><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</p></li><li><p><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</p></li><li><p><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</p></li><li><p><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</p></li><li><p><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</p></li><li><p><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</p></li><li><p><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</p></li><li><p><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</p></li></ul><blockquote><h3 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a>支持数据库</h3></blockquote><blockquote><p>任何能使用 <code>MyBatis</code> 进行 CRUD, 并且支持标准 SQL 的数据库，具体支持情况如下，如果不在下列表查看分页部分教程 PR 您的支持。</p></blockquote><ul><li><p>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</p></li><li><p>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库</p></li></ul><blockquote><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/03.png" alt="1669375402243"></p><h2 id="2、快速开始"><a href="#2、快速开始" class="headerlink" title="2、快速开始"></a>2、快速开始</h2><p>地址：<a href="https://mp.baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">快速开始</a>  </p><p>使用第三方组件：</p><p>1、导入对应的依赖  </p><p>2、研究依赖如何配置</p><p>3、代码如何编写</p><p>4、提高扩展技术能力！</p><blockquote><p>步骤</p></blockquote><p>1、创建数据库 <code>mybatis_plus</code></p><p>2、创建<code>user</code>表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--其对应的数据库 Schema 脚本如下：</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--其对应的数据库 Data 脚本如下</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--真实的开发中，version（乐观锁）、delete（逻辑删除）、gmt_create、gmt_modified</span></span><br></pre></td></tr></table></figure><p>3、编写项目，初始化项目！使用<code>SpringBoot</code>初始化</p><p>4、导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：我们使用Mybatis-plus可以节省我们大量的代码，尽量不要同时导入 mybatis 和 mybatis-plus！版本的差异！</p><p>5、连接数据库！这一步和mybatis相同！</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动不同 com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置 serverTimezone=GMT%2B8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p><strong>6、传统方式pojo-dao（连接mybatis，配置mapper.xml文件）-service-controller</strong> </p><p>6、使用了mybatis-plus 之后</p><ul><li><p>pojo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: User实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/25 20:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.yang.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 代表了持久层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/25 20:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在对应的mapper上面继承基本的接口BaseMapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">//所有的CRUD操作都已经编写完成了</span></span><br><span class="line">    <span class="comment">//你不需要像以前的配置一大堆文件了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点，我们需要再主启动类上去扫描我们的mapper包下的所有接口 <code>@MapperScan(&quot;com.kuang.mapper&quot;)</code></p></li><li><p>测试类中测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MybatisPlusApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//继承了BaseMapper，所有的方法都来自父类</span></span><br><span class="line">    <span class="comment">//我们也可以编写自己的扩展方法</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//参数是一个Wrapper，条件构造器，这里我们先不用 null</span></span><br><span class="line">        <span class="comment">//查询全部用户</span></span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/04.png" alt="1669381395273"></p><blockquote><p>思考问题？</p></blockquote><p>1、SQL谁帮我们写的？MyBatis-Plus 都写好了</p><p>2、方法哪里来的？MyBatis-Plus 都写好了</p><h2 id="3、配置日志"><a href="#3、配置日志" class="headerlink" title="3、配置日志"></a>3、配置日志</h2><p>我们所有的sql现在是不可见的，我们希望知道他是怎么执行的，所以我们必须要看日志！</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/05.png" alt="1669381687617"></p><h2 id="4、CRUD扩展"><a href="#4、CRUD扩展" class="headerlink" title="4、CRUD扩展"></a>4、CRUD扩展</h2><h3 id="4-1、插入操作"><a href="#4-1、插入操作" class="headerlink" title="4.1、插入操作"></a>4.1、插入操作</h3><blockquote><p>Insert插入</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;冰冰&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">3</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;123456@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);   <span class="comment">//帮我们自动生成id</span></span><br><span class="line">    System.out.println(result); <span class="comment">//返回受影响的行数</span></span><br><span class="line">    System.out.println(user);   <span class="comment">//发现 id会自动回填</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/06.png" alt="1669382707305"></p><blockquote><p>数据库插入的id默认值为：全局的唯一id</p></blockquote><h3 id="4-2、主键生成策略"><a href="#4-2、主键生成策略" class="headerlink" title="4.2、主键生成策略"></a>4.2、主键生成策略</h3><blockquote><p>默认：ID_WORKER全局唯一id</p></blockquote><p>分布式系统唯一id生成方案：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><p><strong>雪花算法：</strong></p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！</p><blockquote><p>主键自增</p></blockquote><p>我们需要配置主键自增：</p><p>1、实体类字段上<code>@TableId(type = IdType.AUTO)</code></p><p>2、数据库字段一定要是自增的！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/07.png" alt="1669383550080"></p><p>3、再次测试插入即可！</p><blockquote><p>其他源码解释</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdType</span> &#123;</span><br><span class="line">    AUTO(<span class="number">0</span>),<span class="comment">//数据库id自增</span></span><br><span class="line">    NONE(<span class="number">1</span>),<span class="comment">//未设置主键</span></span><br><span class="line">    INPUT(<span class="number">2</span>),<span class="comment">//手动输入</span></span><br><span class="line">    ASSIGN_ID(<span class="number">3</span>),<span class="comment">//默认的全局唯一id</span></span><br><span class="line">    ASSIGN_UUID(<span class="number">4</span>),<span class="comment">//全局唯一id UUID</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>); <span class="comment">//ID_WORKER 字符串表示法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、更新操作"><a href="#4-3、更新操作" class="headerlink" title="4.3、更新操作"></a>4.3、更新操作</h3><blockquote><p>update 操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id更新数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;爱吃花椒的喵酱&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/08.png" alt="1669391752852"></p><p>所有的SQL都是自动帮你动态配置的！</p><h3 id="4-4、自动填充"><a href="#4-4、自动填充" class="headerlink" title="4.4、自动填充"></a>4.4、自动填充</h3><p>创建时间、修改时间！这些个操作都是自动化完成的，我们不希望手动更新！</p><p>阿里巴巴开发手册：所有的数据库表：gmt_create、gmr_modified、几乎所有的表都要配置上！而且需要自动化！</p><blockquote><h4 id="方式一：数据库级别（工作中不允许修改数据库）"><a href="#方式一：数据库级别（工作中不允许修改数据库）" class="headerlink" title="方式一：数据库级别（工作中不允许修改数据库）"></a>方式一：数据库级别（工作中不允许修改数据库）</h4></blockquote><p>1、在表中新增字段 <strong>create_time, update_time</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/09.png" alt="1669446686055"></p><blockquote><p><font color=red>若直接在表中添加字段报错，可使用sql语句添加：</font></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `<span class="keyword">user</span>` <span class="keyword">add</span> `create_time` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;创建时间&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `<span class="keyword">user</span>` <span class="keyword">add</span> `update_time` datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">on</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>;</span><br></pre></td></tr></table></figure><p>2、再次测试插入方法，我们需要先把实体类同步！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure><p>3、再次更新查看结果即可</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/10.png" alt="1669448126288"></p><blockquote><h4 id="方式二：代码级别"><a href="#方式二：代码级别" class="headerlink" title="方式二：代码级别"></a>方式二：代码级别</h4></blockquote><p>1、删除数据库的默认值，更新操作！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/11.png" alt="1669448335373"></p><p>2、实体类的字段属性上需要增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字段添加填充内容</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure><p>3、编写处理器处理注解即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//一定不要忘记把处理器加到IOC容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ...&quot;</span>);</span><br><span class="line">        <span class="comment">//default MetaObjectHandler setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject)</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试插入</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/12.png" alt="1669450253368"></p><p>5、测试更新</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/13.png" alt="1669450439720"></p><h3 id="4-5、乐观锁"><a href="#4-5、乐观锁" class="headerlink" title="4.5、乐观锁"></a>4.5、乐观锁</h3><p>在面试过程中，我们经常会被问到乐观锁，悲观 锁！这个其实非常简单！</p><blockquote><p>乐观锁：顾名思义十分乐观，他总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试！</p><p>悲观锁：顾名思义十分悲观，他总是任务总是出现问题，无论干什么都会上锁！再去操作！</p></blockquote><p>我们这里主要讲解，乐观锁机制！</p><p>乐观锁实现方式：</p><ul><li>取出记录，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时，set version &#x3D; new version where version &#x3D; oldversion</li><li>如果version不对，就更新失败</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--乐观锁：1、先查询，获得版本号：version = 1 </span></span><br><span class="line"><span class="comment">-- A --</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;bingbing&quot;,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> &quot;bingbing&quot;,version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>测试一下Mybatis-Plus的乐观锁插件</p></blockquote><p>1、给数据库中增加version字段！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/14.png" alt="1669452668358"></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/15.png" alt="1669452704864"></p><p>2、我们实体类加对应的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span>    <span class="comment">//乐观锁Version注解</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><p>3、注册组件</p><p><strong>旧方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">//旧插件版本</span></span><br><span class="line">    <span class="comment">//乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;   </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试一下！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试乐观锁失败</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testVersion2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//线程一</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;喵酱&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;112233@qq.com&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程二：插队操作</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectById(<span class="number">6L</span>);</span><br><span class="line">    user2.setName(<span class="string">&quot;喵酱22&quot;</span>);</span><br><span class="line">    user2.setEmail(<span class="string">&quot;112233@qq.com&quot;</span>);</span><br><span class="line">    user2.setAge(<span class="number">3</span>);</span><br><span class="line">    userMapper.updateById(user2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋值多次尝试提交</span></span><br><span class="line">    userMapper.updateById(user);    <span class="comment">//若果没有乐观锁就会覆盖插队现成的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/16.png" alt="1669459690045"></p><h3 id="4-6、查询操作"><a href="#4-6、查询操作" class="headerlink" title="4.6、查询操作"></a>4.6、查询操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">6L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试批量查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按条件查询之————map操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//自定义要查询的条件--可设置多个条件</span></span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;yang&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7、分页查询"><a href="#4-7、分页查询" class="headerlink" title="4.7、分页查询"></a>4.7、分页查询</h3><p>分页在网站使用的十分之多！</p><p>1、原始的 limit 进行分页</p><p>2、pageHelper 第三方插件</p><p>3、MyBatis-Plus其实也内置了分页插件</p><blockquote><p>如何使用？</p></blockquote><p>1、配置拦截器组件即可</p><p><strong>旧方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">//乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分页插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PaginationInterceptor</span> <span class="variable">paginationInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">        <span class="keyword">return</span> paginationInterceptor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;   </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、直接使用Page对象即可！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试分页查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//参数一：当前页</span></span><br><span class="line">    <span class="comment">//参数二：页面大小</span></span><br><span class="line">    <span class="comment">//使用了分页插件之后，所有的分页操作也变得简单了！</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;数据总数：&quot;</span> + page.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/17.png" alt="1669466730146"></p><h3 id="4-8、删除操作"><a href="#4-8、删除操作" class="headerlink" title="4.8、删除操作"></a>4.8、删除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.deleteById(<span class="number">1596132421525368839L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByBatchId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.deleteBatchIds(Arrays.asList(<span class="number">7L</span>, <span class="number">1596132421525368838L</span>, <span class="number">1596132421525368837L</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;删除数据条数为：&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过map按条件删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//自定义要删除的条件--可设置多个条件</span></span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除数据条数为：&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果（map条件删除）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/18.png" alt="1669469599394"></p><p>我们在工作中会遇到一些问题：逻辑删除！</p><h3 id="4-9、逻辑删除"><a href="#4-9、逻辑删除" class="headerlink" title="4.9、逻辑删除"></a>4.9、逻辑删除</h3><blockquote><p>物理删除：从数据库中直接移除</p><p>逻辑删除：在数据库中没有被移除，而是通过一个变量来让他失效！deleted &#x3D; 0 &#x3D;&gt; deleted &#x3D; 1</p></blockquote><p>管理员可以查看被删除的记录！防止数据的丢失，类似于回收站!</p><p>测试一下：</p><p>1、在数据表中增加一个deleted字段</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/19.png" alt="1669475688162"></p><p>2、实体类中增加属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span> <span class="comment">//逻辑删除</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure><p>3、配置！</p><blockquote><p>旧方法：在application.properties配置文件中添加逻辑删除配置</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置逻辑删除</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描我们的 mapper 文件夹</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑删除组件！</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新方法：在配置类中添加逻辑删除插件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描mapper文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新插件版本为 MyBatis-Plus 3.5.2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑删除插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试一下删除！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/20.png" alt="1669477199547"></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/21.png" alt="1669477291045"></p><p>以上的所有CRUD操作及其扩展操作，我们都必须精通掌握！会大大提高你的工作和写项目的效率！</p><h3 id="4-10、性能分析插件"><a href="#4-10、性能分析插件" class="headerlink" title="4.10、性能分析插件"></a>4.10、性能分析插件</h3><p>我们在平时的开发中，会遇到一些满Sql。测试、druid···</p><p>MybatisPlus也提供了性能分析插件，如果超过这个时间就停止运行！</p><p><strong>性能分析拦截器作用：用于输出每条sql语句及其执行时间</strong></p><p><strong>旧方法：</strong></p><p>1、导入插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//性能分析插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="comment">//设置dev开发、test测试 环境开启  保证我们的效率</span></span><br><span class="line"><span class="keyword">public</span> PerformanceInterceptor <span class="title function_">performanceInterceptor</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="type">PerformanceInterceptor</span> <span class="variable">performanceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PerformanceInterceptor</span>();       performanceInterceptor.setMaxTime(<span class="number">100</span>);<span class="comment">//设置sql最大执行时间*ms，如果超过了则不执行</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="literal">true</span>);<span class="comment">//开启sql格式化    </span></span><br><span class="line"><span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 要在SpringBoot中配置环境为dev或test环境！</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置开发环境</span></span><br><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><p>2、测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Testvoid</span> contextLoads() &#123;    </span><br><span class="line">    <span class="comment">//参数是一个wrapper ，条件构造器，这里我们先不用 null    </span></span><br><span class="line">    <span class="comment">//查询全部的用户    </span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>); </span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/22.png" alt="img"></p><p>使用性能分析插件，可以帮助我们提高效率！</p><blockquote><p><font color=red>(新版本不提供这个插件了)</font></p></blockquote><p><strong>! ! ! 新版本使用方法：</strong><a href="https://baomidou.com/pages/833fab/">执行SQL分析打印 </a></p><p><strong>mybatis-plus 执行SQL分析打印，及其SQL美化插件</strong></p><p>该功能依赖 <code>p6spy</code> 组件，完美的输出打印 SQL 及执行时长， MP<code>3.1.0</code> 以上版本</p><p>1、在pom.xml中引入<code>p6spy</code> ：sql性能分析依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- p6spy sql性能分析插件--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/p6spy/p6spy --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、application.yml 配置：更改数据库驱动</p><blockquote><p>若使用此配置则应该将原来的application.properties配置文件删除或注释其内容</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.p6spy.engine.spy.P6SpyDriver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:p6spy:mysql://127.0.0.1:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p>3、spy.properties 配置（添加这个配置文件）:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#3.2.1以上使用</span></span><br><span class="line"><span class="attr">modulelist</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"><span class="comment">#3.2.1以下使用或者不配置</span></span><br><span class="line"><span class="comment">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span></span><br><span class="line"><span class="comment"># 自定义日志打印</span></span><br><span class="line"><span class="attr">logMessageFormat</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span></span><br><span class="line"><span class="comment">#日志输出到控制台</span></span><br><span class="line"><span class="attr">appender</span>=<span class="string">com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span></span><br><span class="line"><span class="comment"># 使用日志系统记录 sql</span></span><br><span class="line"><span class="comment">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span></span><br><span class="line"><span class="comment"># 设置 p6spy driver 代理</span></span><br><span class="line"><span class="attr">deregisterdrivers</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 取消JDBC URL前缀</span></span><br><span class="line"><span class="attr">useprefix</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span></span><br><span class="line"><span class="attr">excludecategories</span>=<span class="string">info,debug,result,commit,resultset</span></span><br><span class="line"><span class="comment"># 日期格式</span></span><br><span class="line"><span class="attr">dateformat</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment"># 实际驱动可多个</span></span><br><span class="line"><span class="comment">#driverlist=org.h2.Driver</span></span><br><span class="line"><span class="comment"># 是否开启慢SQL记录</span></span><br><span class="line"><span class="attr">outagedetection</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 慢SQL记录标准 2 秒</span></span><br><span class="line"><span class="attr">outagedetectioninterval</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><blockquote><p>测试：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试批量查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/23.png" alt="1669551682881"></p><p><strong>注意！</strong></p><blockquote><ul><li>driver-class-name 为 p6spy 提供的驱动类</li><li>url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址</li><li>打印出 sql 为 null,在 excludecategories 增加 commit</li><li>批量操作不打印 sql,去除 excludecategories 中的 batch</li><li>批量操作打印重复的问题请使用 MybatisPlusLogFactory (3.2.1 新增）</li><li>该插件有性能损耗，不建议生产环境使用。</li></ul></blockquote><h3 id="4-11、条件构造器"><a href="#4-11、条件构造器" class="headerlink" title="4.11、条件构造器"></a>4.11、条件构造器</h3><p><strong>十分重要：Wrapper</strong> </p><p>我们写一些复杂的SQL就可以使用他来替代！</p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/24.png" alt="1669553674673"></p><p>1、测试1，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询name不为空的用户，并且邮箱不为空的用户，年龄大于12</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.isNotNull(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>) <span class="comment">//字段 IS NULL</span></span><br><span class="line">            .ge(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>);  <span class="comment">// 大于等于 &gt;=</span></span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/25.png" alt="1669556166417"></p><p>2、测试2，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//查询名字等于 wang 的用户</span></span><br><span class="line">    wrapper.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/26.png" alt="1669557423547"></p><p>3、测试3，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//查询年龄在19到30岁之间的用户</span></span><br><span class="line">    wrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">//区间</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(wrapper);   <span class="comment">//查询结果数</span></span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/27.png" alt="1669557369997"></p><p>4、测试4，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模糊查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//左和右%e%</span></span><br><span class="line">    wrapper.notLike(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;e&quot;</span>) <span class="comment">//NOT LIKE &#x27;%值%&#x27;</span></span><br><span class="line">            .likeRight(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;t&quot;</span>);    <span class="comment">//LIKE &#x27;值%&#x27;</span></span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/28.png" alt="1669557865876"></p><p>5、测试5，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//字段 IN ( sql语句 )</span></span><br><span class="line">    <span class="comment">//例: inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)---&gt;age in (1,2,3,4,5,6)</span></span><br><span class="line">    <span class="comment">//例: inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3)</span></span><br><span class="line">    <span class="comment">//id 在子查询中查出来</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where age&lt;10&quot;</span>);</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    userList.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/29.png" alt="1669559310217"></p><p>6、测试6，记住查看输出的SQL进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询并排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//排序：ORDER BY 字段, ... DESC</span></span><br><span class="line">    <span class="comment">//例: orderByDesc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id DESC,name DESC</span></span><br><span class="line">    <span class="comment">//通过id进行排序</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);  <span class="comment">//倒序</span></span><br><span class="line">    userMapper.selectList(wrapper).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/30.png" alt="1669559594544"></p><h3 id="4-12、代码自动生成器"><a href="#4-12、代码自动生成器" class="headerlink" title="4.12、代码自动生成器"></a>4.12、代码自动生成器</h3><p>dao、pojo、service、controller都给我自己去编写完成！</p><p>AutoGenerator 是MyBatis-Plus的代码生成器，通过AutoGenerator可以快速的生成Entity、Mapper、Mapper.xml、Service、Controllerr 等各个模块的代码,极大的提高了开发效率。</p><p>测试：</p><p><strong>代码生成器（旧）：</strong>适用版本：&#x3D;&#x3D;mybatis-plus-generator 3.5.1&#x3D;&#x3D; 以下版本，3.5.1 及以上的请参考 <a href="https://baomidou.com/pages/779a6e/">代码生成器新</a></p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--generator:代码生成器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--velocity:模板引擎--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--swagger2--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql 5 驱动不同 com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置 serverTimezone=GMT%2B8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p>搭建代码自动生成器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.FieldFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableFill;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自动生成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/28 15:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoCode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//全局策略 globalConfig 配置</span></span><br><span class="line">        <span class="comment">//1、全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        <span class="comment">//生成项目目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        <span class="comment">//开发人员</span></span><br><span class="line">        gc.setAuthor(<span class="string">&quot;yang&quot;</span>);</span><br><span class="line">        <span class="comment">//是否打开输出目录</span></span><br><span class="line">        gc.setOpen(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//是否覆盖</span></span><br><span class="line">        gc.setFileOverride(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//service 命名方式 : 默认值：null 例如：%sBusiness 生成 UserBusiness</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);</span><br><span class="line">        gc.setIdType(IdType.ASSIGN_ID);</span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">        <span class="comment">//开启swagger2模式</span></span><br><span class="line">        gc.setSwagger2(<span class="literal">true</span>);</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、数据源 dataSourceConfig 配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、包名配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        <span class="comment">//父包模块名</span></span><br><span class="line">        pc.setModuleName(<span class="string">&quot;blog&quot;</span>);</span><br><span class="line">        <span class="comment">//父包名。如果为空，将下面子包名必须写全部，否则就只需写子包名</span></span><br><span class="line">        pc.setParent(<span class="string">&quot;com.yang&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo&quot;</span>);</span><br><span class="line">        pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">        pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">        pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        <span class="comment">//要映射的表名</span></span><br><span class="line">        strategy.setInclude(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//数据库表映射到实体的命名策略:underline_to_camel下划线转驼峰命名</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        <span class="comment">//数据库字段映射到实体的命名策略</span></span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        <span class="comment">//自动Lombok</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//自动填充配置</span></span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">createTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;create_time&quot;</span>, FieldFill.INSERT);</span><br><span class="line">        <span class="type">TableFill</span> <span class="variable">updateTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableFill</span>(<span class="string">&quot;update_time&quot;</span>, FieldFill.UPDATE);</span><br><span class="line">        ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        tableFills.add(createTime);</span><br><span class="line">        tableFills.add(updateTime);</span><br><span class="line">        <span class="comment">//表填充字段</span></span><br><span class="line">        strategy.setTableFillList(tableFills);</span><br><span class="line">        <span class="comment">//乐观锁--乐观锁属性名称&quot;version&quot;</span></span><br><span class="line">        strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line">        <span class="comment">//逻辑删除属性名称:&quot;deleted&quot;</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);</span><br><span class="line">        <span class="comment">//生成 @RestController 控制器</span></span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//驼峰转连字符  eg://localhost:8080/hello_id_2</span></span><br><span class="line">        strategy.setControllerMappingHyphenStyle(<span class="literal">true</span>);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行代码构造器</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>运行结果：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/MyBatis-Plus/31.png" alt="1669809361739"></p><ol><li><p>编写自动填充处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自动填充处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/29 23:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//一定不要忘记把处理器加到IOC容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start insert fill ...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时候的填充策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metaObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;start update fill ...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>乐观锁、逻辑删除、分页等插件配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.BlockAttackInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/29 23:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.yang.blog.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">// 注册乐观锁插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册逻辑删除插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Swagger配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.blog.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.oas.annotations.EnableOpenApi;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Swagger配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Mr.Yang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2022/11/30 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableOpenApi</span>  <span class="comment">//开启Swagger2自动配置</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//配置类 @Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="comment">//配置API分组</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Swagger的Docket的bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="comment">//设置swagger显示的环境</span></span><br><span class="line"><span class="comment">//        Profiles profiles = Profiles.of(&quot;dev&quot;, &quot;test&quot;);</span></span><br><span class="line"><span class="comment">//        //通过 environment.acceptsProfiles判断是否处于自己设定的环境当中</span></span><br><span class="line"><span class="comment">//        boolean flag = environment.acceptsProfiles(profiles);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;yang&quot;</span>)</span><br><span class="line">                .enable(<span class="literal">true</span>)   <span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.yang.blog.controller&quot;</span>))</span><br><span class="line">                <span class="comment">//过滤什么路径</span></span><br><span class="line">                <span class="comment">//.paths(PathSelectors.ant(&quot;/yang/**&quot;))</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Swagger信息--apiInfo</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//作者信息</span></span><br><span class="line">        <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;yl&quot;</span>, <span class="string">&quot;https://y-orangecat.github.io/&quot;</span>, <span class="string">&quot;1249650491@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfo</span>(</span><br><span class="line">                <span class="string">&quot;yang的Swagger Api文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;以梦为马，不负韶华！&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;https://y-orangecat.github.io/&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayList</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件下载</title>
      <link href="/2022/10/31/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/10/31/%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>软件下载</p><p>阿里云盘：<a href="https://www.aliyundrive.com/s/5Cr4EsigJUh">https://www.aliyundrive.com/s/5Cr4EsigJUh</a><br>提取码：8l5d</p>]]></content>
      
      
      <categories>
          
          <category> 资料 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity新版2.7+用法</title>
      <link href="/2022/10/30/SpringSecurity%20%E6%96%B0%E7%89%882.7+%E7%94%A8%E6%B3%95/"/>
      <url>/2022/10/30/SpringSecurity%20%E6%96%B0%E7%89%882.7+%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p><strong>1、导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2、测试三种权限</strong></p><p>2.7以前的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mhy.security.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OldSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//请求的规则</span></span><br><span class="line">        http.authorizeHttpRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有权限跳到login页</span></span><br><span class="line">        http.formLogin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication().passwordEncoder(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>())</span><br><span class="line">                .withUser(<span class="string">&quot;shuisanya&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;root&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">&quot;haha&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;123456&quot;</span>)).roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.7以后的版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.factory.PasswordEncoderFactories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.provisioning.InMemoryUserDetailsManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.SecurityFilterChain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringSecurity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Yang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        <span class="comment">// 首页所有人都可以访问，功能也只有对应有权限的人才能访问到</span></span><br><span class="line">        <span class="comment">// 请求授权的规则</span></span><br><span class="line">        <span class="keyword">return</span> http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">//首页所有人可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                <span class="comment">//特定权限访问页</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//无权限默认跳转登录页</span></span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//注销，开启注销功能，跳转到首页</span></span><br><span class="line">                .logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//密码加密</span></span><br><span class="line">        PasswordEncoder encoder= PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">        <span class="comment">//设置用户</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user1</span> <span class="operator">=</span> User.builder()</span><br><span class="line">                .username(<span class="string">&quot;lailai&quot;</span>)</span><br><span class="line">                .password(encoder.encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                <span class="comment">//用户权限</span></span><br><span class="line">                .roles(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        UserDetails user2=User.builder()</span><br><span class="line">                .username(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                .password(encoder.encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user1,user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3、测试自己设置加密</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user1</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;shuisanya&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user2</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user3</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">        .passwordEncoder(<span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>()::encode)</span><br><span class="line">        .password(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(userDetails,user1,user2,user3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接数据库使用"><a href="#连接数据库使用" class="headerlink" title="连接数据库使用"></a>连接数据库使用</h2><p><strong>导入依赖，这里使用mybatisPlus</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>编写配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 配置日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"><span class="comment"># 开启逻辑删除</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-field</span>=<span class="string">deleted</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><p><strong>实现UserDetailsService接口的编写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userDetailsServiceImpl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserMapper</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        QueryWrapper&lt;com.mhy.security.pojo.User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">        com.mhy.security.pojo.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;该用户不存在!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;GrantedAuthority&gt; vip2 = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;vip2&quot;</span>); <span class="comment">//权限 一般是从数据库来实现</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,PasswordEncoderUtils.encode(user.getPassword()),vip2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种授权的配置"><a href="#三种授权的配置" class="headerlink" title="三种授权的配置"></a>三种授权的配置</h2><h2 id="三种授权的配置-1"><a href="#三种授权的配置-1" class="headerlink" title="三种授权的配置"></a>三种授权的配置</h2><p><strong>首页</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Y-OrangeCat/picodemo/img/security01.png" alt="首页"></p><p><strong>第一种 hasAuthority</strong></p><p>这个参数只能配置一种授权</p><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有只能是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有只能是vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有只能是vip3才可以访问</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasAuthority(<span class="string">&quot;vip1&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasAuthority(<span class="string">&quot;vip2&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasAuthority(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line"></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种 hasRole</strong></p><p>这个参数只能配置一种授权，但它会默认给你配置的授权名称前加一个<strong>ROLE_</strong></p><p><strong>AuthorityAuthorizationManager</strong>类中的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROLE_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;ROLE_&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; AuthorityAuthorizationManager&lt;T&gt; <span class="title function_">hasRole</span><span class="params">(String role)</span> &#123;</span><br><span class="line">    Assert.notNull(role, <span class="string">&quot;role cannot be null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> hasAuthority(ROLE_PREFIX + role);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有只能是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有只能是vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有只能是vip3才可以访问</li></ul><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasRole(<span class="string">&quot;vip1&quot;</span>) <span class="comment">// 这里实际上是ROLE_vip1</span></span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasRole(<span class="string">&quot;vip2&quot;</span>) <span class="comment">// 这里实际上是ROLE_vip1</span></span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasRole(<span class="string">&quot;vip3&quot;</span>);<span class="comment">// 这里实际上是ROLE_vip3</span></span><br><span class="line">        &#125;);</span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line"></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用在编写实现UserDetailsService时候需要注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">QueryWrapper&lt;com.mhy.security.pojo.User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">wrapper.eq(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">com.mhy.security.pojo.<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;该用户不存在!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;GrantedAuthority&gt; vip2 = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;ROLE_vip2&quot;</span>);  <span class="comment">//注意</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,PasswordEncoderUtils.encode(user.getPassword()),vip2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种 hasAnyAuthority</strong></p><p>配置多个参数</p><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有是vip1，vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有是vip1，vip2，vip3才可以访问</li></ul><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasAnyAuthority(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasAnyAuthority(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasAnyAuthority(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四种 hasAnyAuthority</strong></p><p>配置多个参数</p><p>这个参数只能配置一种授权，但它会默认给你配置的授权名称前加一个<strong>ROLE_</strong></p><p>场景：</p><ul><li>访问&#x2F;level1&#x2F;**这个下面的所有是vip1才可以访问</li><li>访问&#x2F;level2&#x2F;**这个下面的所有是vip1，vip2才可以访问</li><li>访问&#x2F;level3&#x2F;**这个下面的所有是vip1，vip2，vip3才可以访问</li></ul><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewSecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests((authorize) -&gt; &#123;</span><br><span class="line">            authorize</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/&quot;</span>).permitAll()</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level1/**&quot;</span>).hasAnyRole(<span class="string">&quot;vip1&quot;</span>,<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level2/**&quot;</span>).hasAnyRole(<span class="string">&quot;vip2&quot;</span>,<span class="string">&quot;vip3&quot;</span>)</span><br><span class="line">                    .antMatchers(<span class="string">&quot;/level3/**&quot;</span>).hasAnyRole(<span class="string">&quot;vip3&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .formLogin() <span class="comment">//开启登入功能</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/toLogin&quot;</span>) <span class="comment">//开启等去去的页面，去自己的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">//登录请求的方法，这个是spring security帮你做</span></span><br><span class="line"></span><br><span class="line">        http.csrf().disable(); <span class="comment">//关闭csrf防火墙</span></span><br><span class="line"></span><br><span class="line">        http.logout().logoutSuccessUrl(<span class="string">&quot;/&quot;</span>); <span class="comment">//退出登录的页面</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pbkdf2PasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题设置</title>
      <link href="/2022/10/19/hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"/>
      <url>/2022/10/19/hexo%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p><strong>Front-matter 是 markdown 文件最上方以 — 分隔的区域，用于指定个别档案的变数。</strong></p><ul><li>Page Front-matter 用于页面配置</li><li>Post Front-matter 用于文章页配置</li></ul><hr><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line"><span class="attr">updated:</span></span><br><span class="line"><span class="attr">type:</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line"><span class="attr">aside:</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">highlight_shrink:</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th align="center">写法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">【必需】页面标题</td></tr><tr><td align="center">date</td><td align="center">【必需】页面创建日期</td></tr><tr><td align="center">type</td><td align="center">【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td align="center">updated</td><td align="center">【可选】页面更新日期</td></tr><tr><td align="center">description</td><td align="center">【可选】页面描述</td></tr><tr><td align="center">keywords</td><td align="center">【可选】页面关键字</td></tr><tr><td align="center">comments</td><td align="center">【可选】显示页面评论模块(默认 true)</td></tr><tr><td align="center">top_img</td><td align="center">【可选】页面顶部图片</td></tr><tr><td align="center">mathjax</td><td align="center">【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="center">katex</td><td align="center">【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="center">aside</td><td align="center">【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="center">aplayer</td><td align="center">【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td align="center">highlight_shrink</td><td align="center">【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><hr><h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line"><span class="attr">updated:</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">top_img:</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line"><span class="attr">cover:</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line"><span class="attr">toc_number:</span></span><br><span class="line"><span class="attr">toc_style_simple:</span></span><br><span class="line"><span class="attr">copyright:</span></span><br><span class="line"><span class="attr">copyright_author:</span></span><br><span class="line"><span class="attr">copyright_author_href:</span></span><br><span class="line"><span class="attr">copyright_url:</span></span><br><span class="line"><span class="attr">copyright_info:</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">katex:</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">highlight_shrink:</span></span><br><span class="line"><span class="attr">aside:</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated【可选】文章更新日期</td><td></td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/19/hello-world/"/>
      <url>/2022/10/19/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合容器面试题（2022版）</title>
      <link href="/2022/06/01/javaInterviewQuestions/2.%20Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/06/01/javaInterviewQuestions/2.%20Java%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java集合容器面试题（2022版）"><a href="#Java集合容器面试题（2022版）" class="headerlink" title="Java集合容器面试题（2022版）"></a>Java集合容器面试题（2022版）</h1><table><thead><tr><th>序列号</th><th>内容</th><th>链接</th></tr></thead><tbody><tr><td>1</td><td>Java基础知识面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124023797">https://blog.csdn.net/qq_43061290/article/details/124023797</a></td></tr><tr><td>2</td><td>Java集合容器面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124043363">https://blog.csdn.net/qq_43061290/article/details/124043363</a></td></tr><tr><td>3</td><td>Java异常面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124078378">https://blog.csdn.net/qq_43061290/article/details/124078378</a></td></tr><tr><td>4</td><td>并发编程面试题 （2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104563">https://blog.csdn.net/qq_43061290/article/details/124104563</a></td></tr><tr><td>5</td><td>JVM面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104514">https://blog.csdn.net/qq_43061290/article/details/124104514</a></td></tr><tr><td>6</td><td>Spring面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124227864">https://blog.csdn.net/qq_43061290/article/details/124227864</a></td></tr><tr><td>7</td><td>Spring MVC面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124337927">https://blog.csdn.net/qq_43061290/article/details/124337927</a></td></tr><tr><td>8</td><td>Spring Boot面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124339493">https://blog.csdn.net/qq_43061290/article/details/124339493</a></td></tr><tr><td>9</td><td>Spring Cloud面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124341152">https://blog.csdn.net/qq_43061290/article/details/124341152</a></td></tr><tr><td>10</td><td>MyBatis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124468306">https://blog.csdn.net/qq_43061290/article/details/124468306</a></td></tr><tr><td>11</td><td>Redis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124473691">https://blog.csdn.net/qq_43061290/article/details/124473691</a></td></tr><tr><td>12</td><td>MySQL数据库面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124427311">https://blog.csdn.net/qq_43061290/article/details/124427311</a></td></tr><tr><td>13</td><td>消息中间件MQ知识点（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124542376">https://blog.csdn.net/qq_43061290/article/details/124542376</a></td></tr><tr><td>14</td><td>ZooKeeper面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124548428">https://blog.csdn.net/qq_43061290/article/details/124548428</a></td></tr><tr><td>15</td><td>架构设计&amp;分布式&amp;数据结构与算法面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124624540">https://blog.csdn.net/qq_43061290/article/details/124624540</a></td></tr><tr><td>16</td><td>计算机网络编程面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124041420">https://blog.csdn.net/qq_43061290/article/details/124041420</a></td></tr></tbody></table><h1 id="1-集合容器概述"><a href="#1-集合容器概述" class="headerlink" title="1 集合容器概述"></a>1 集合容器概述</h1><h2 id="1-1-什么是集合"><a href="#1-1-什么是集合" class="headerlink" title="1.1 什么是集合"></a>1.1 什么是集合</h2><p><strong>集合框架：用于存储数据的容器。</strong></p><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。<br>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p><p><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p><p><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</p><p><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。<br>它减少了程序设计的辛劳。</p><p>集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。</p><p>通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。</p><h2 id="1-2-集合的特点"><a href="#1-2-集合的特点" class="headerlink" title="1.2 集合的特点"></a>1.2 集合的特点</h2><p><strong>集合的特点主要有如下两点：</strong></p><ul><li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li><li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li></ul><h2 id="1-3-集合和数组的区别"><a href="#1-3-集合和数组的区别" class="headerlink" title="1.3 集合和数组的区别"></a>1.3 集合和数组的区别</h2><ul><li>1、数组是固定长度的；集合可变长度的。</li><li>2、数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>3、数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><p><strong>数据结构：就是容器中存储数据的方式。</strong></p><p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p><p>集合容器在不断向上抽取过程中，出现了集合体系。在使用一个体系的原则：参阅顶层内容。建立底层对象。</p><h2 id="1-4-使用集合框架的好处"><a href="#1-4-使用集合框架的好处" class="headerlink" title="1.4 使用集合框架的好处"></a>1.4 使用集合框架的好处</h2><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h2 id="1-5-常用的集合类有哪些？"><a href="#1-5-常用的集合类有哪些？" class="headerlink" title="1.5 常用的集合类有哪些？"></a>1.5 常用的集合类有哪些？</h2><p><strong>Map接口和Collection接口是所有集合框架的父接口：</strong></p><ul><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ul><h2 id="1-6-List、Set、Map三者的区别？"><a href="#1-6-List、Set、Map三者的区别？" class="headerlink" title="1.6 List、Set、Map三者的区别？"></a>1.6 List、Set、Map三者的区别？</h2><p><strong>List，Set，Map三者的区别？List、Set、Map 是否继承自 Collection 接口？List、Map、Set 三个接口存取元素时，各有什么特点？</strong><br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;61e1d2e9373f4843b25b88855f76ed38.png)</p><p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p><p>Collection集合主要有List和Set两大接口</p><ul><li><strong>List</strong>：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li><strong>Set</strong>：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li></ul><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p><p><strong>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</strong></p><h2 id="1-7-集合框架底层数据结构"><a href="#1-7-集合框架底层数据结构" class="headerlink" title="1.7 集合框架底层数据结构"></a>1.7 集合框架底层数据结构</h2><p><strong>Collection</strong><br>1、List</p><ul><li>Arraylist： Object数组</li><li>Vector： Object数组</li><li>LinkedList： 双向循环链表</li></ul><p>2、Set</p><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul><p>3、Map</p><ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h2 id="1-8-哪些集合类是线程安全？"><a href="#1-8-哪些集合类是线程安全？" class="headerlink" title="1.8 哪些集合类是线程安全？"></a>1.8 哪些集合类是线程安全？</h2><ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul><h2 id="1-9-java集合的快速失败机制“fail-fast”"><a href="#1-9-java集合的快速失败机制“fail-fast”" class="headerlink" title="1.9 java集合的快速失败机制“fail-fast”"></a>1.9 java集合的快速失败机制“fail-fast”</h2><p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</p><p><strong>例如</strong>：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><p><strong>原因</strong>：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>解决办法</strong>：<br>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。<br>使用CopyOnWriteArrayList来替换ArrayList</p><h2 id="1-10-怎么确保一个集合不能被修改"><a href="#1-10-怎么确保一个集合不能被修改" class="headerlink" title="1.10 怎么确保一个集合不能被修改"></a>1.10 怎么确保一个集合不能被修改</h2><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。<br>实例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">&quot;y&quot;</span>); // 运行时此行报错</span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure><h1 id="2-Collection接口"><a href="#2-Collection接口" class="headerlink" title="2 Collection接口"></a>2 Collection接口</h1><h2 id="2-1-List接口"><a href="#2-1-List接口" class="headerlink" title="2.1 List接口"></a>2.1 List接口</h2><p><strong>迭代器 Iterator 是什么？</strong></p><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><p><strong>Iterator 怎么使用？有什么特点？</strong></p><p>Iterator 使用代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><p><strong>如何边遍历边移除 Collection 中的元素？</strong></p><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">   *// <span class="keyword">do</span> something*</span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种最常见的错误代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</p><p><strong>Iterator 和 ListIterator 有什么区别？</strong></p><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><p><strong>遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</strong><br>遍历方式有以下几种：</p><ul><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ul><p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。</p><ul><li>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li></ul><p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</p><p><strong>说一下 ArrayList 的优缺点</strong></p><p><strong>ArrayList的优点如下：</strong></p><ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul><p><strong>ArrayList 的缺点如下：</strong></p><ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li><li>ArrayList 比较适合顺序添加、随机访问的场景。</li></ul><p><strong>如何实现数组和 List 之间的转换？</strong></p><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换。</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li><li></li></ul><p><strong>代码示例如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// list to array</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">list.toArray();</span><br><span class="line"></span><br><span class="line">// array to list</span><br><span class="line">String[] array = new String[]&#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>&#125;;</span><br><span class="line">Arrays.asList(array);</span><br></pre></td></tr></table></figure><p><strong>ArrayList 和 LinkedList 的区别是什么？</strong></p><ul><li><strong>数据结构实现</strong>：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li><li><strong>随机访问效率</strong>：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li><strong>增加和删除效率</strong>：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li><li><strong>内存空间占用</strong>：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li><strong>线程安全</strong>：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li></ul><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p><p><strong>补充</strong>：数据结构基础之双向链表</p><p><strong>双向链表也叫双链表</strong>，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><p><strong>ArrayList 和 Vector 的区别是什么？</strong></p><p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合</p><ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><p><strong>插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</strong></p><p>ArrayList、LinkedList、Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</p><p>Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。</p><p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。</p><p><strong>多线程场景下如何使用 ArrayList？</strong></p><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">synchronizedList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; synchronizedList.size(); i++) &#123;</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么 ArrayList 的 elementData 加上 transient 修饰？</strong></p><p>ArrayList 中的数组定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] elementData;</span><br></pre></td></tr></table></figure><p>再看一下 ArrayList 的定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123;</span><br><span class="line">    *// Write out element count, and any hidden stuff*</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    *// Write out array length*</span><br><span class="line">        s.writeInt(elementData.length);</span><br><span class="line">    *// Write out all elements <span class="keyword">in</span> the proper order.*</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;size; i++)</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p><p><strong>List 和 Set 的区别</strong><br>List , Set 都是继承自Collection 接口</p><p>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p><p>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p><p>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</p><p><strong>Set和List对比</strong></p><ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li></ul><h2 id="2-2-Set接口"><a href="#2-2-Set接口" class="headerlink" title="2.2 Set接口"></a>2.2 Set接口</h2><p><strong>说一下 HashSet 的实现原理？</strong></p><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><p><strong>HashSet如何检查重复？HashSet是如何保证数据不可重复的？</strong></p><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p><p><strong>以下是HashSet 部分源码：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static final Object PRESENT = new Object();</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    // 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span><br><span class="line"><span class="built_in">return</span> map.put(e, PRESENT)==null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ul><p><strong>&#x3D;&#x3D;与equals的区别</strong></p><ol><li>&#x3D;&#x3D;是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>&#x3D;&#x3D;是指对内存地址进行比较 equals()是对字符串的内容进行比较3.&#x3D;&#x3D;指引用是否相同 equals()指的是值是否相同</li></ol><p><strong>HashSet与HashMap的区别</strong><br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;f76425287cb94784b9d8fc3b8a53d2c6.png)</p><h2 id="2-3-队列"><a href="#2-3-队列" class="headerlink" title="2.3 队列"></a>2.3 队列</h2><p><strong>BlockingQueue是什么？</strong><br>Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。</p><p>BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><p><strong>在 Queue 中 poll()和 remove()有什么区别？</strong></p><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><p>代码示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">&quot;string&quot;</span>); // add</span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure><h1 id="3-Map接口"><a href="#3-Map接口" class="headerlink" title="3 Map接口"></a>3 Map接口</h1><h2 id="3-1-HashMap的实现原理"><a href="#3-1-HashMap的实现原理" class="headerlink" title="3.1 HashMap的实现原理"></a>3.1 HashMap的实现原理</h2><p><strong>HashMap概述</strong>： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p><strong>HashMap的数据结构</strong>： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p><strong>HashMap 基于 Hash 算法实现的</strong></p><ul><li>当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标<br>存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中</li><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li><li>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</li></ul><p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p><h2 id="3-2-HashMap在JDK1-7和1-8中有哪些区别？HashMap的底层实现"><a href="#3-2-HashMap在JDK1-7和1-8中有哪些区别？HashMap的底层实现" class="headerlink" title="3.2 HashMap在JDK1.7和1.8中有哪些区别？HashMap的底层实现"></a>3.2 HashMap在JDK1.7和1.8中有哪些区别？HashMap的底层实现</h2><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。</p><p><strong>JDK1.8之前</strong><br>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可<br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;b227cb9097f745fa88db699aa0deb4d8.png)</p><p><strong>JDK1.8之后</strong></p><p>JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</p><p><strong>补充</strong>：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64。此时并不会将链表变为红黑树。而是选择进行数组扩容。</p><p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考</p><p>treeifysin方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int <span class="built_in">hash</span>) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    // 如果表的长度小于 64 会先扩容！！！ 否则 扩容</span><br><span class="line">    // MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line">    <span class="keyword">if</span> (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - 1) &amp; <span class="built_in">hash</span>]) != null) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">            <span class="keyword">if</span> (tl == null)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != null);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != null)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。![在这里插入图片描述](2. Java集合容器.assets&#x2F;de1c489156fe4a31b2608069b5565c6f.png)</p><p><strong>JDK1.7 VS JDK1.8 比较</strong></p><p>JDK1.8主要解决或优化了一下问题：</p><ol><li>resize 扩容优化</li><li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol><p>![在这里插入图片描述](2. Java集合容器.assets&#x2F;be40f3366bbb4ee49e8a735c876d6569.png)</p><p><strong>补充：</strong></p><h2 id="3-3-HashMap的PUT方法的具体流程"><a href="#3-3-HashMap的PUT方法的具体流程" class="headerlink" title="3.3 HashMap的PUT方法的具体流程"></a>3.3 HashMap的PUT方法的具体流程</h2><p>当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()&gt;&gt;&gt;16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index &#x3D; (table.length - 1) &amp; hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p><p><strong>putVal方法执行流程图</strong><br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;1788d9e2b2f84fb1b6e9b084031cf830.png)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    <span class="built_in">return</span> putVal(<span class="built_in">hash</span>(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final int <span class="built_in">hash</span>(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    <span class="built_in">return</span> (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现Map.put和相关方法</span><br><span class="line">final V putVal(int <span class="built_in">hash</span>, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 步骤①：tab为空则创建 </span><br><span class="line">    // table未初始化或者长度为0，进行扩容</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 步骤②：计算index，并对null做处理  </span><br><span class="line">    // (n - 1) &amp; <span class="built_in">hash</span> 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - 1) &amp; <span class="built_in">hash</span>]) == null)</span><br><span class="line">        tab[i] = newNode(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">    // 桶中已经存在元素</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 步骤③：节点key存在，直接覆盖value </span><br><span class="line">        // 比较桶中第一个元素(数组中的结点)的<span class="built_in">hash</span>值相等，key相等</span><br><span class="line">        <span class="keyword">if</span> (p.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                // 将第一个元素赋值给e，用e来记录</span><br><span class="line">                e = p;</span><br><span class="line">        // 步骤④：判断该链为红黑树 </span><br><span class="line">        // <span class="built_in">hash</span>值不相等，即key不相等；为红黑树结点</span><br><span class="line">        // 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">            // 放入树中</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, <span class="built_in">hash</span>, key, value);</span><br><span class="line">        // 步骤⑤：该链为链表 </span><br><span class="line">        // 为链表结点</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            // 在链表最末插入结点</span><br><span class="line">            <span class="keyword">for</span> (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 到达链表的尾部</span><br><span class="line">                </span><br><span class="line">                //判断该链表尾部指针是不是空的</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == null) &#123;</span><br><span class="line">                    // 在尾部插入新结点</span><br><span class="line">                    p.next = newNode(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">                    //判断链表的长度是否达到转化红黑树的临界值，临界值为8</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 <span class="keyword">for</span> 1st</span><br><span class="line">                        //链表结构转树形结构</span><br><span class="line">                        treeifyBin(tab, <span class="built_in">hash</span>);</span><br><span class="line">                    // 跳出循环</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                // 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">                <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    // 相等，跳出循环</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前的key已经存在的情况下，再来一个相同的<span class="built_in">hash</span>值、key值时，返回新来的value这个值</span><br><span class="line">        <span class="keyword">if</span> (e != null) &#123; </span><br><span class="line">            // 记录e的value</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            // onlyIfAbsent为<span class="literal">false</span>或者旧值为null</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                //用新值替换旧值</span><br><span class="line">                e.value = value;</span><br><span class="line">            // 访问后回调</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            // 返回旧值</span><br><span class="line">            <span class="built_in">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构性修改</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 步骤⑥：超过最大容量就扩容 </span><br><span class="line">    // 实际大小大于阈值则扩容</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    // 插入后回调</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；<br>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><h2 id="3-4-HashMap的扩容操作及原理"><a href="#3-4-HashMap的扩容操作及原理" class="headerlink" title="3.4 HashMap的扩容操作及原理"></a>3.4 HashMap的扩容操作及原理</h2><p>①.在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p><p>②.每次扩展的时候，都是扩展2倍；</p><p>③.扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</p><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] <span class="function"><span class="title">resize</span></span>() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;//oldTab指向<span class="built_in">hash</span>桶数组</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; 0) &#123;//如果oldCap不为空的话，就是<span class="built_in">hash</span>桶数组不为空</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//如果大于最大容量了，就赋值为整数最大的阀值</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="built_in">return</span> oldTab;//返回</span><br><span class="line">        &#125;//如果当前<span class="built_in">hash</span>桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="string">1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span></span><br><span class="line"><span class="string">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span></span><br><span class="line"><span class="string">            newThr = oldThr &lt;&lt; 1</span>; // double threshold 双倍扩容阀值threshold</span><br><span class="line">    &#125;</span><br><span class="line">    // 旧的容量为0，但threshold大于零，代表有参构造有<span class="built_in">cap</span>传入，threshold已经被初始化成最小2的n次幂</span><br><span class="line">    // 直接将该值赋给新的容量</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; 0) // initial capacity was placed <span class="keyword">in</span> threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    // 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span><br><span class="line">    <span class="keyword">else</span> &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 新的threshold = 新的<span class="built_in">cap</span> * 0.75</span><br><span class="line">    <span class="keyword">if</span> (newThr == 0) &#123;</span><br><span class="line">        <span class="built_in">float</span> ft = (<span class="built_in">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="built_in">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    // 计算出新的数组长度后赋给当前成员变量table</span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">&quot;rawtypes&quot;</span>,<span class="string">&quot;unchecked&quot;</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//新建<span class="built_in">hash</span>桶数组</span><br><span class="line">    table = newTab;//将新数组的值复制给旧的<span class="built_in">hash</span>桶数组</span><br><span class="line">    // 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span><br><span class="line">    <span class="keyword">if</span> (oldTab != null) &#123;</span><br><span class="line">        // 遍历新数组的所有桶下标</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                // 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span><br><span class="line">                <span class="keyword">if</span> (e.next == null)</span><br><span class="line">                    // 用同样的<span class="built_in">hash</span>映射算法把该元素加入新的数组</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).<span class="built_in">split</span>(this, newTab, j, oldCap);</span><br><span class="line">                // e是链表的头并且e.next!=null，那么处理链表中元素重排</span><br><span class="line">                <span class="keyword">else</span> &#123; // preserve order</span><br><span class="line">                    // loHead,loTail 代表扩容后不用变换下标，见注1</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    // hiHead,hiTail 代表扩容后变换下标，见注1</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    // 遍历链表</span><br><span class="line">                    <span class="keyword">do</span> &#123;             </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == null)</span><br><span class="line">                                // 初始化<span class="built_in">head</span>指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span><br><span class="line">                                // 代表下标保持不变的链表的头元素</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>                                </span><br><span class="line">                                // loTail.next指向当前e</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            // loTail指向当前的元素e</span><br><span class="line">                            // 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span><br><span class="line">                            // 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span><br><span class="line">                            // 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span><br><span class="line">                            loTail = e;                           </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == null)</span><br><span class="line">                                // 初始化<span class="built_in">head</span>指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != null);</span><br><span class="line">                    // 遍历结束, 将<span class="built_in">tail</span>指向null，并把链表头放入新数组的相应下标，形成新的映射。</span><br><span class="line">                    <span class="keyword">if</span> (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的table的容量如何确定?loadFactor是什么?该容量如何变化?这种变化会带来什么问题?</strong></p><p>初始容量为16，达到阈值扩容，阈值等于最大容量*负载因子，扩容每次2倍，总是2的n次方。<br>①、table数组大小是由capacity这个参数确定的,默认是16,也可以构造时传入,最大限制是1&lt;&lt;30;</p><p>②、loadFactor是装载因子,主要目的是用来确认table数组是否需要动态扩展,默认值是0.75,比如table数组大小为16,装载因子为0.75时,threshold就是12,当table的实际大小超过12时,table就需要动态扩容;</p><p>③、扩容时,调用resize()方法,将table长度变为原来的两倍(注意是table长度,而不是threshold)</p><p>④、如果数据很大的情况下,扩展时将会带来性能的损失,在性能要求很高的地方,这种损失很可能很致命。</p><h2 id="3-5-HashMap是如何解决哈希冲突的？"><a href="#3-5-HashMap是如何解决哈希冲突的？" class="headerlink" title="3.5 HashMap是如何解决哈希冲突的？"></a>3.5 HashMap是如何解决哈希冲突的？</h2><p>答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；</p><p><strong>什么是哈希？</strong></p><p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>所有散列函数都有如下一个基本特性<strong>：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同</strong>。</p><p><strong>什么是哈希冲突？</strong></p><p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p><p><strong>HashMap的数据结构</strong></p><p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做链地址法的方式可以解决哈希冲突：<br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;65ad1427c1914d248381d3b4dfd05982.png)</p><p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</p><p><strong>hash()函数</strong></p><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int <span class="built_in">hash</span>(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    <span class="built_in">return</span> (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p><p><strong>Jdk1.8新增红黑树</strong><br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;ab7779a6d8c04638b49947439a0d5fb0.png)</p><p>通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p><p><strong>总结</strong></p><p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p><ol><li>使用链地址法（使用散列表）来链接拥有相同hash值的数据；</li><li>使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</li><li>引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</li></ol><h2 id="3-6-能否使用任何类作为Map的key"><a href="#3-6-能否使用任何类作为Map的key" class="headerlink" title="3.6 能否使用任何类作为Map的key?"></a>3.6 能否使用任何类作为Map的key?</h2><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h2 id="3-7-为什么HashMap中的String、Integer这样的包装类适合作为K"><a href="#3-7-为什么HashMap中的String、Integer这样的包装类适合作为K" class="headerlink" title="3.7 为什么HashMap中的String、Integer这样的包装类适合作为K"></a>3.7 为什么HashMap中的String、Integer这样的包装类适合作为K</h2><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p><ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul><h2 id="3-8-如果使用Object作为HashMap的Key，应该怎么办呢？"><a href="#3-8-如果使用Object作为HashMap的Key，应该怎么办呢？" class="headerlink" title="3.8 如果使用Object作为HashMap的Key，应该怎么办呢？"></a>3.8 如果使用Object作为HashMap的Key，应该怎么办呢？</h2><p>答：重写hashCode()和equals()方法</p><ul><li>重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li>重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li></ul><h2 id="3-9-HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#3-9-HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="3.9 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>3.9 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><p>答：hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p><p><strong>那怎么解决呢？</strong></p><ul><li>HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ul><h2 id="3-10-HashMap-的长度为什么是2的幂次方"><a href="#3-10-HashMap-的长度为什么是2的幂次方" class="headerlink" title="3.10 HashMap 的长度为什么是2的幂次方"></a>3.10 HashMap 的长度为什么是2的幂次方</h2><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>那为什么是两次扰动呢？</strong></p><p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p><h2 id="3-11-HashMap-与-HashTable-有什么区别？"><a href="#3-11-HashMap-与-HashTable-有什么区别？" class="headerlink" title="3.11 HashMap 与 HashTable 有什么区别？"></a>3.11 HashMap 与 HashTable 有什么区别？</h2><ul><li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li><li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li><li>初始容量大小和每次扩充容量大小的不同 ： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li><li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ul><h2 id="3-12-如何决定使用-HashMap-还是-TreeMap？"><a href="#3-12-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="3.12 如何决定使用 HashMap 还是 TreeMap？"></a>3.12 如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p><h2 id="3-13-HashMap-和-ConcurrentHashMap-的区别"><a href="#3-13-HashMap-和-ConcurrentHashMap-的区别" class="headerlink" title="3.13 HashMap 和 ConcurrentHashMap 的区别"></a>3.13 HashMap 和 ConcurrentHashMap 的区别</h2><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h2 id="3-14-ConcurrentHashMap-和-Hashtable-的区别？"><a href="#3-14-ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="3.14 ConcurrentHashMap 和 Hashtable 的区别？"></a>3.14 ConcurrentHashMap 和 Hashtable 的区别？</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要</strong>）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p><strong>HashTable:</strong>![在这里插入图片描述](2. Java集合容器.assets&#x2F;f711d9418fe749aba0ea85a215d52dea.png)</p><p>JDK1.7的ConcurrentHashMap<br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;12e94bfa9ca14efdb566713bd7f2d4f3.png)</p><p>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）<br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;684c23d4e4cc40129f086eff1e75fbc0.png)</p><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p><h2 id="3-15-ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？"><a href="#3-15-ConcurrentHashMap-底层具体实现知道吗？实现原理是什么？" class="headerlink" title="3.15 ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？"></a>3.15 ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2><p><strong>JDK1.7</strong></p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。<br>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。<br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;f5082fc79274497ba9e1ecbb7d5952d3.png)</p><p>1、该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</p><p>2、Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</p><p><strong>JDK1.8</strong></p><p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。<br>结构如下：<br>![在这里插入图片描述](2. Java集合容器.assets&#x2F;ca4d3f14421446eb9dcf272aad90ee44.png)</p><p>附加源码，有需要的可以看看<br>插入元素过程（建议去看看源码）：<br>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - 1) &amp; <span class="built_in">hash</span>)) == null) &#123;</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, null, new Node&lt;K,V&gt;(<span class="built_in">hash</span>, key, value, null)))</span><br><span class="line">        <span class="built_in">break</span>;                   // no lock when adding to empty bin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= 0) &#123;</span><br><span class="line">    binCount = 1;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == <span class="built_in">hash</span> &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == null) &#123;</span><br><span class="line">            pred.next = new Node&lt;K,V&gt;(<span class="built_in">hash</span>, key, value, null);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p><p>2、如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p><h1 id="4-辅助工具类"><a href="#4-辅助工具类" class="headerlink" title="4 辅助工具类"></a>4 辅助工具类</h1><h2 id="4-1-Array-和-ArrayList-有何区别？"><a href="#4-1-Array-和-ArrayList-有何区别？" class="headerlink" title="4.1 Array 和 ArrayList 有何区别？"></a>4.1 Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h2 id="4-2-如何实现-Array-和-List-之间的转换？"><a href="#4-2-如何实现-Array-和-List-之间的转换？" class="headerlink" title="4.2 如何实现 Array 和 List 之间的转换？"></a>4.2 如何实现 Array 和 List 之间的转换？</h2><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h2 id="4-3-comparable-和-comparator的区别？"><a href="#4-3-comparable-和-comparator的区别？" class="headerlink" title="4.3 comparable 和 comparator的区别？"></a>4.3 comparable 和 comparator的区别？</h2><ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p><h2 id="4-4-Collection-和-Collections-有什么区别？"><a href="#4-4-Collection-和-Collections-有什么区别？" class="headerlink" title="4.4 Collection 和 Collections 有什么区别？"></a>4.4 Collection 和 Collections 有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="4-5-TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？"><a href="#4-5-TreeMap-和-TreeSet-在排序时如何比较元素？Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="4.5 TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？"></a>4.5 TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</p><p>Collections 工具类的 sort 方法有两种重载的形式，</p><p>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</p><p>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识面试题（2022版）</title>
      <link href="/2022/06/01/1.%20Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/06/01/1.%20Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java基础知识面试题（2022版）"><a href="#Java基础知识面试题（2022版）" class="headerlink" title="Java基础知识面试题（2022版）"></a>Java基础知识面试题（2022版）</h1><table><thead><tr><th>序列号</th><th>内容</th><th>链接</th></tr></thead><tbody><tr><td>1</td><td>Java基础知识面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124023797">https://blog.csdn.net/qq_43061290/article/details/124023797</a></td></tr><tr><td>2</td><td>Java集合容器面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124043363">https://blog.csdn.net/qq_43061290/article/details/124043363</a></td></tr><tr><td>3</td><td>Java异常面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124078378">https://blog.csdn.net/qq_43061290/article/details/124078378</a></td></tr><tr><td>4</td><td>并发编程面试题 （2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104563">https://blog.csdn.net/qq_43061290/article/details/124104563</a></td></tr><tr><td>5</td><td>JVM面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124104514">https://blog.csdn.net/qq_43061290/article/details/124104514</a></td></tr><tr><td>6</td><td>Spring面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124227864">https://blog.csdn.net/qq_43061290/article/details/124227864</a></td></tr><tr><td>7</td><td>Spring MVC面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124337927">https://blog.csdn.net/qq_43061290/article/details/124337927</a></td></tr><tr><td>8</td><td>Spring Boot面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124339493">https://blog.csdn.net/qq_43061290/article/details/124339493</a></td></tr><tr><td>9</td><td>Spring Cloud面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124341152">https://blog.csdn.net/qq_43061290/article/details/124341152</a></td></tr><tr><td>10</td><td>MyBatis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124468306">https://blog.csdn.net/qq_43061290/article/details/124468306</a></td></tr><tr><td>11</td><td>Redis面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124473691">https://blog.csdn.net/qq_43061290/article/details/124473691</a></td></tr><tr><td>12</td><td>MySQL数据库面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124427311">https://blog.csdn.net/qq_43061290/article/details/124427311</a></td></tr><tr><td>13</td><td>消息中间件MQ知识点（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124542376">https://blog.csdn.net/qq_43061290/article/details/124542376</a></td></tr><tr><td>14</td><td>ZooKeeper面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124548428">https://blog.csdn.net/qq_43061290/article/details/124548428</a></td></tr><tr><td>15</td><td>架构设计&amp;分布式&amp;数据结构与算法面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124624540">https://blog.csdn.net/qq_43061290/article/details/124624540</a></td></tr><tr><td>16</td><td>计算机网络编程面试题（2022版）</td><td><a href="https://blog.csdn.net/qq_43061290/article/details/124041420">https://blog.csdn.net/qq_43061290/article/details/124041420</a></td></tr></tbody></table><h1 id="1-1-Java概述"><a href="#1-1-Java概述" class="headerlink" title="1.1 Java概述"></a>1.1 Java概述</h1><h2 id="1-1-1-何为编程"><a href="#1-1-1-何为编程" class="headerlink" title="1.1.1 何为编程"></a>1.1.1 何为编程</h2><p>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</p><h2 id="1-1-2-什么是Java"><a href="#1-1-2-什么是Java" class="headerlink" title="1.1.2 什么是Java"></a>1.1.2 什么是Java</h2><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程<br>。除此之外，还有目前比较流行的Python、Go等语言，适用于不同的处理场景。</p><h2 id="1-1-3-jdk1-5之后的三大版本"><a href="#1-1-3-jdk1-5之后的三大版本" class="headerlink" title="1.1.3 jdk1.5之后的三大版本"></a>1.1.3 jdk1.5之后的三大版本</h2><ul><li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的<br>Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li><li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java<br>应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信<br>API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将<br>JavaEE 更名为 JakartaEEJava ME（J2ME，Java 2 Platform Micro Edition，微型版）Java ME 以前称为 J2ME。</li><li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）Java ME 以前称为 J2ME。Java ME<br>为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME<br>包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME<br>规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul><h2 id="1-1-4-JVM、JRE和JDK的关系"><a href="#1-1-4-JVM、JRE和JDK的关系" class="headerlink" title="1.1.4 JVM、JRE和JDK的关系"></a>1.1.4 JVM、JRE和JDK的关系</h2><ul><li>JVM<br>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li><li>JRE<br>Java Runtime<br>Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包<br>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li><li>JDK<br>Java Development<br>Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(<br>javac.exe)，打包工具(jar.exe)等</li></ul><p><code>**JDK&gt;JRE&gt;JVM**</code><br>JDK&gt;JRE&gt;JVM</p><p><strong>JVM&amp;JRE&amp;JDK关系图</strong></p><p>![在这里插入图片描述](1. Java基础知识.assets&#x2F;A01.png)</p><h2 id="1-1-5-什么是JAVA跨平台性，其原理是什么"><a href="#1-1-5-什么是JAVA跨平台性，其原理是什么" class="headerlink" title="1.1.5 什么是JAVA跨平台性，其原理是什么"></a>1.1.5 什么是JAVA跨平台性，其原理是什么</h2><p>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。<br>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</p><h2 id="1-1-6-Java语言有哪些特点"><a href="#1-1-6-Java语言有哪些特点" class="headerlink" title="1.1.6 Java语言有哪些特点"></a>1.1.6 Java语言有哪些特点</h2><ul><li>简单易学（Java语言的语法与C语言和C++语言很接近）</li><li>面向对象（封装，继承，多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li><li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li><li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li><li>安全性</li></ul><h2 id="1-1-7-什么是字节码？采用字节码的最大好处是什么"><a href="#1-1-7-什么是字节码？采用字节码的最大好处是什么" class="headerlink" title="1.1.7 什么是字节码？采用字节码的最大好处是什么"></a>1.1.7 什么是字节码？采用字节码的最大好处是什么</h2><ul><li>字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</li><li></li></ul><p><strong>采用字节码的好处：</strong></p><ul><li>Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</li></ul><p><strong>先看下java中的编译器和解释器：</strong></p><ul><li>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</li></ul><p><strong>Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;<br>程序运行。</strong></p><h2 id="1-1-8-什么是java程序的主类？应用程序和小程序的主类有何不同？"><a href="#1-1-8-什么是java程序的主类？应用程序和小程序的主类有何不同？" class="headerlink" title="1.1.8 什么是java程序的主类？应用程序和小程序的主类有何不同？"></a>1.1.8 什么是java程序的主类？应用程序和小程序的主类有何不同？</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()<br>方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p><h2 id="1-1-9-java应用程序和小程序之间的差别"><a href="#1-1-9-java应用程序和小程序之间的差别" class="headerlink" title="1.1.9 java应用程序和小程序之间的差别"></a>1.1.9 java应用程序和小程序之间的差别</h2><p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()<br>线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p><h2 id="1-1-10-java与C-的区别"><a href="#1-1-10-java与C-的区别" class="headerlink" title="1.1.10 java与C++的区别"></a>1.1.10 java与C++的区别</h2><p>我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</p><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h2 id="1-1-11-Oracle-jDK-和OpenJdk的对比"><a href="#1-1-11-Oracle-jDK-和OpenJdk的对比" class="headerlink" title="1.1.11 Oracle jDK 和OpenJdk的对比"></a>1.1.11 Oracle jDK 和OpenJdk的对比</h2><p>（1）Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；<br>（2）OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；<br>（3）Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle<br>JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle<br>JDK就可以解决问题；<br>（4）在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；<br>（5）Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；<br>（6）Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</p><h1 id="1-2-Java基础语法"><a href="#1-2-Java基础语法" class="headerlink" title="1.2 Java基础语法"></a>1.2 Java基础语法</h1><h2 id="1-2-1-数据类型"><a href="#1-2-1-数据类型" class="headerlink" title="1.2.1 数据类型"></a>1.2.1 数据类型</h2><p><strong>Java有哪些数据类型</strong><br>定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><p><strong>分类</strong><br><strong>基本数据类型</strong></p><ul><li>数值型</li><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li><li>字符型(char)</li><li>布尔型(boolean)</li></ul><p><strong>引用数据类型</strong></p><ul><li>类(class)</li><li>接口(interface)</li><li>数组([])<br>Java基本数据类型图</li></ul><p>![在这里插入图片描述](1. Java基础知识.assets&#x2F;A02.png)</p><p>switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上<br>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum<br>类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><p><strong>用最有效率的方法计算 2 乘以 8</strong><br>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p><p>Math.round(11.5) 等于多少？Math.round(-11.5)等于多少<br>Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</p><p><strong>float f&#x3D;3.4;是否正确</strong><br>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float<br>f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。</p><p><strong>short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗</strong><br>对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。</p><p>而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。</p><p><strong>装箱和拆箱</strong><br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比 如：把 int 转化成 Integer，double 转化成<br>Double，等等。<br>反之就是自动拆箱。 原始类型: boolean，char，byte，short，int，long，float，double<br>封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double<br>String 转出 int 型，判断能不能转？如何转？<br>答：可以转，得处理异常 Integer.parseInt(s) 主要为 NumberFormatException：1）当 你输入为字母时，也就是内容不是数字时，如 abcd<br>2）当你输入为空时<br>3）当你输入超出 int 上限时 Long.parseLong(“123”)转换为 long</p><h2 id="1-2-2-java-基本类型与引用类型的区别"><a href="#1-2-2-java-基本类型与引用类型的区别" class="headerlink" title="1.2.2 java 基本类型与引用类型的区别"></a>1.2.2 java 基本类型与引用类型的区别</h2><p>基本类型保存原始值，引用类型保存的是引用值（引用值就是指对象在堆中所 处的位置&#x2F;地址）</p><p><strong>int和Integer的区别</strong></p><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p><p><strong>延伸：</strong><br><strong>关于Integer和int的比较</strong><br>1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = new Integer(100);</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">int j = 100；</span><br><span class="line">System.out.print(i == j); //true</span><br></pre></td></tr></table></figure><p>3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为 ①当变量值在-128~<br>127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()<br>生成的变量指向堆中新建的对象，两者在内存中的地址不同；②当变量值不在-128~127之间时，非new生成Integer变量时，java API中最终会按照new<br>Integer(i)进行处理（参考下面第4条），最终两个Interger的地址同样是不相同的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br><span class="line">Integer i = 128;</span><br><span class="line">Integer j = 128;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>对于第4条的原因：<br>java在编译Integer i &#x3D; 100 ;时，会翻译成为Integer i &#x3D; Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="built_in">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127进行缓存，下次再写Integer j &#x3D; 127时，就会直接从缓存中取，就不会new了</p><h2 id="1-2-3-编码及注释"><a href="#1-2-3-编码及注释" class="headerlink" title="1.2.3 编码及注释"></a>1.2.3 编码及注释</h2><p><strong>Java语言采用何种编码方案？有何特点？</strong><br>Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。</p><p>定义：用于解释说明程序的文字<br>分类<br>单行注释<br>格式： &#x2F;&#x2F; 注释文字<br>多行注释<br>格式： &#x2F;* 注释文字 <em>&#x2F;文档注释格式：&#x2F;</em>* 注释文字 *&#x2F;</p><p><strong>作用</strong><br>在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。<br>注意事项：多行和文档注释都不能嵌套使用。</p><h2 id="1-2-4-访问修饰符"><a href="#1-2-4-访问修饰符" class="headerlink" title="1.2.4 访问修饰符"></a>1.2.4 访问修饰符</h2><p>访问修饰符 public,private,protected,以及不写（默认）时的区别<br>定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。<br><strong>分类</strong></p><ul><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li><li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li><li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li><li>public : 对所有类可见。使用对象：类、接口、变量、方法<br>访问修饰符图<br>![在这里插入图片描述](1. Java基础知识.assets&#x2F;e2d9363da9a04733aa6da1b0377382ba.png)</li></ul><h2 id="1-2-5-运算符"><a href="#1-2-5-运算符" class="headerlink" title="1.2.5 运算符"></a>1.2.5 运算符</h2><ul><li><p>&amp;和&amp;&amp;的区别</p><p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是<br>true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</p><ul><li>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</li></ul></li></ul><h2 id="1-2-6-关键字"><a href="#1-2-6-关键字" class="headerlink" title="1.2.6 关键字"></a>1.2.6 关键字</h2><p><strong>Java 有没有 goto</strong><br>goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</p><p><strong>final 有什么用？</strong></p><ul><li>用于修饰类、属性和方法；</li><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><p><strong>Final、 finally 、finalize区别</strong></p><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表<br>示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc()<br>方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li></ul><p><strong>this关键字的用法</strong><br>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p>this的用法在java中大体可以分为3种：</p><ol><li>普通的直接引用，this相当于是指向当前对象本身。</li><li>形参与成员名字重名，用this来区分：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, int age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>引用本类的构造函数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public <span class="function"><span class="title">Person</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>super关键字的用法</strong><br>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p><strong>super也有三种用法：</strong></p><ol><li>普通的直接引用</li></ol><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p><ol><li>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1class Person&#123;</span><br><span class="line">2.    protected String name;</span><br><span class="line">3. </span><br><span class="line">4.    public Person(String name) &#123;</span><br><span class="line">5.        this.name = name;</span><br><span class="line">6.    &#125;</span><br><span class="line">7. </span><br><span class="line">8.&#125;</span><br><span class="line">9. </span><br><span class="line">10.class Student extends Person&#123;</span><br><span class="line">11.    private String name;</span><br><span class="line">12. </span><br><span class="line">13.    public Student(String name, String name1) &#123;</span><br><span class="line">14.        super(name);</span><br><span class="line">15.        this.name = name1;</span><br><span class="line">16.    &#125;</span><br><span class="line">17. </span><br><span class="line">18.    public void <span class="function"><span class="title">getInfo</span></span>()&#123;</span><br><span class="line">19.        System.out.println(this.name);      //Child</span><br><span class="line">20.        System.out.println(super.name);     //Father</span><br><span class="line">21.    &#125;</span><br><span class="line">22. </span><br><span class="line">23.&#125;</span><br><span class="line">24.</span><br><span class="line">25.public class Test &#123;</span><br><span class="line">26.    public static void main(String[] args) &#123;</span><br><span class="line">27.       Student s1 = new Student(<span class="string">&quot;Father&quot;</span>,<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">28.       s1.getInfo();</span><br><span class="line">29. </span><br><span class="line">30.    &#125;</span><br><span class="line">31.&#125;</span><br></pre></td></tr></table></figure><p>3、引用父类构造函数</p><p>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><p><strong>this与super的区别</strong></p><ul><li>super:它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名<br>super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调<br>用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><p><strong>static存在的主要意义</strong></p><ul><li>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</li><li>static关键字还有一个比较关键的作用就是<br>用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li></ul><p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><p><strong>static的独特之处</strong></p><p>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</p><blockquote><p>怎么理解 “被类的实例对象所共享”<br>这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p></blockquote><p>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。<br>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！<br>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><p><strong>static应用场景</strong></p><p>因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。<br>因此比较常见的static应用场景有：<br>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p><p><strong>static注意事项</strong></p><p>1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p><h2 id="1-2-7-流程控制语句"><a href="#1-2-7-流程控制语句" class="headerlink" title="1.2.7 流程控制语句"></a>1.2.7 流程控制语句</h2><p><strong>break ,continue ,return 的区别及作用</strong></p><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)<br>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p><p><strong>在 Java 中，如何跳出当前的多重嵌套循环</strong></p><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;,j=&quot;</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == 5) &#123;</span><br><span class="line">                <span class="built_in">break</span> ok;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-3-面向对象"><a href="#1-3-面向对象" class="headerlink" title="1.3 面向对象"></a>1.3 面向对象</h1><h2 id="1-3-1-面向对象概述"><a href="#1-3-1-面向对象概述" class="headerlink" title="1.3.1 面向对象概述"></a>1.3.1 面向对象概述</h2><p><strong>面向对象和面向过程的区别</strong><br><strong>面向过程：</strong></p><ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul><p><strong>面向对象：</strong></p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul><p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p><p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p><p>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</p><h2 id="1-3-2-面向对象三大特性"><a href="#1-3-2-面向对象三大特性" class="headerlink" title="1.3.2 面向对象三大特性"></a>1.3.2 面向对象三大特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象的特征主要有以下几个方面：抽象、封装、继承。</span><br></pre></td></tr></table></figure><ul><li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li><li>封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</li><li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于继承如下 3 点请记住：</span><br></pre></td></tr></table></figure><ol><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><p><strong>多态</strong></p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中Java 面向对象编程三大特性：封装 继承 多态</span><br></pre></td></tr></table></figure><ul><li>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</li><li>继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。</li></ul><p><strong>关于继承如下 3 点请记住：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.子类拥有父类非 private 的属性和方法。</span><br><span class="line"></span><br><span class="line">2子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</span><br><span class="line"></span><br><span class="line">3子类可以用自己的方式实现父类的方法。</span><br></pre></td></tr></table></figure><ul><li>多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</li></ul><p>在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。</span><br></pre></td></tr></table></figure><p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ul><p><strong>什么是多态机制？Java语言是如何实现多态的？</strong></p><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><p>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。<br><strong>多态的实现</strong></p><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul><p>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><p>对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p><p><strong>面向对象五大基本原则是什么（可选）</strong></p><p><strong>1 单一职责原则SRP(Single Responsibility Principle)</strong><br>类的功能要单一，不能包罗万象，跟杂货铺似的。<br><strong>2 开放封闭原则OCP(Open－Close Principle)</strong><br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。<br><strong>3 里式替换原则LSP(the Liskov Substitution Principle LSP)</strong><br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~<br><strong>4 依赖倒置原则DIP(the Dependency Inversion Principle DIP)</strong><br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。<br><strong>5 接口分离原则ISP(the Interface Segregation Principle ISP)</strong><br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p><p><strong>Java创建对象的方式</strong></p><p>1、<strong>使用new关键字</strong>：比如：Student student &#x3D; new Student();</p><p>2、<strong>使用Class类的newInstance方法</strong>：可以使用Class类的newInstance方法创建对象，这个newInstance方法调用无参的构造器创建对象，如：Student<br>student2 &#x3D; (Student)Class.forName(“根路径.Student”).newInstance(); 或者：Student stu &#x3D; Student.class.newInstance();</p><p>3、<strong>使用Constructor类的newInstance方法</strong><br>：本方法和Class类的newInstance方法很像，java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象。我们可以通过这个newInstance方法调用有参数的和私有的构造函数。如：<br>Constructor constructor &#x3D; Student.class.getInstance(); Student stu &#x3D; constructor.newInstance();<br>这两种newInstance的方法就是大家所说的反射，事实上Class的newInstance方法内部调用Constructor的newInstance方法。这也是众多框架Spring、Hibernate、Struts等使用后者的原因。</p><p>4、<strong>使用Clone的方法</strong><br>：无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去，用clone方法创建对象并不会调用任何构造函数。要使用clone方法，我们必须先实现Cloneable接口并实现其定义的clone方法。如：Student<br>stu2 &#x3D; stu.clone();这也是原型模式的应用。</p><p>5、<strong>使用反序列化</strong><br>：序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。如：ObjectInputStream<br>in &#x3D; new ObjectInputStream (new FileInputStream(“data.obj”)); Student stu3 &#x3D; (Student)in.readObject();</p><h2 id="1-3-3-类与接口"><a href="#1-3-3-类与接口" class="headerlink" title="1.3.3 类与接口"></a>1.3.3 类与接口</h2><p><strong>抽象类和接口的对比</strong></p><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。<br>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br><strong>相同点</strong></p><ul><li><p>接口和抽象类都不能实例化</p></li><li><p>都位于继承的顶端，用于被其他实现或继承</p></li><li><p>都包含抽象方法，其子类都必须覆写这些抽象方法</p><p><strong>不同点</strong><br>![在这里插入图片描述](1. Java基础知识.assets&#x2F;d6394bee66364d38a80f176ec9563c48.png)</p></li></ul><p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。<br>现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</p><p><strong>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：</strong></p><p>1.行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。<br>2.选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</p><p><strong>普通类和抽象类有哪些区别？</strong></p><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><p><strong>抽象类能使用 final 修饰吗？</strong><br>答：不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><p><strong>创建一个对象用什么关键字？对象实例与对象引用有何不同？</strong><br>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</p><h2 id="1-3-4-变量与方法"><a href="#1-3-4-变量与方法" class="headerlink" title="1.3.4 变量与方法"></a>1.3.4 变量与方法</h2><p><strong>成员变量与局部变量的区别有哪些</strong></p><ul><li>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li><li>成员变量：方法外部，类内部定义的变量</li><li>局部变量：类的方法中的变量。</li></ul><p>成员变量和局部变量的区别<br><strong>作用域</strong></p><ul><li>成员变量：针对整个类有效。</li><li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)<br><strong>存储位置</strong></li><li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li><li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。<br><strong>生命周期</strong></li><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：当方法调用完，或者语句结束后，就自动释放。<br><strong>初始值</strong></li><li>成员变量：有默认初始值。</li><li>局部变量：没有默认初始值，使用前必须赋值。<br><strong>使用原则</strong></li><li>在使用变量时需要遵循的原则为：就近原则</li><li>首先在局部范围找，有就使用；接着在成员位置找。</li></ul><p><strong>在Java中定义一个不做事且没有参数的构造方法的作用</strong></p><p>Java程序在执行子类的构造方法之前，如果没有用super()<br>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()<br>来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><p><strong>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</strong></p><p>帮助子类做初始化工作。<br><strong>一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</strong></p><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。<br><strong>构造方法有哪些特性？</strong></p><ul><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ul><p><strong>静态变量和实例变量区别</strong></p><ul><li>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li><li>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</li></ul><p><strong>静态变量与普通变量区别</strong><br>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<br>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</p><p><strong>静态方法和实例方法有何不同？</strong><br>静态方法和实例方法的区别主要体现在两个方面：</p><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ul><p><strong>在一个静态方法内调用一个非静态成员为什么是非法的？</strong></p><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><p><strong>什么是方法的返回值？返回值的作用是什么？</strong></p><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:<br>接收出结果，使得它可以用于其他的操作！</p><h2 id="1-3-5-内部类"><a href="#1-3-5-内部类" class="headerlink" title="1.3.5 内部类"></a>1.3.5 内部类</h2><p><strong>什么是内部类？</strong></p><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</p><p><strong>内部类的分类有哪些</strong></p><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类。</strong><br>静态内部类<br>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"></span><br><span class="line">    private static int radius = 1;</span><br><span class="line"></span><br><span class="line">    static class StaticInner &#123;</span><br><span class="line">        public void <span class="function"><span class="title">visit</span></span>() &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><p><strong>成员内部类</strong><br>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private static  int radius = 1;</span><br><span class="line">    private int count =2;</span><br><span class="line">     class Inner &#123;</span><br><span class="line">        public void <span class="function"><span class="title">visit</span></span>() &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer static  variable:&quot;</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">&quot;visit outer   variable:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new<br>内部类()，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new Outer();</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure><p><strong>局部内部类</strong><br>定义在方法中的内部类，就是局部内部类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private  int out_a = 1;</span><br><span class="line">    private static int STATIC_b = 2;</span><br><span class="line">    public void <span class="function"><span class="title">testFunctionClass</span></span>()&#123;</span><br><span class="line">        int inner_c =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void <span class="function"><span class="title">testStaticFunctionClass</span></span>()&#123;</span><br><span class="line">        int d =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">                // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new<br>内部类()，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void <span class="function"><span class="title">testStaticFunctionClass</span></span>()&#123;</span><br><span class="line">    class Inner &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner  inner = new Inner();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>匿名内部类</strong><br>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private void <span class="built_in">test</span>(final int i) &#123;</span><br><span class="line">        new <span class="function"><span class="title">Service</span></span>() &#123;</span><br><span class="line">            public void <span class="function"><span class="title">method</span></span>() &#123;</span><br><span class="line">                <span class="keyword">for</span> (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;匿名内部类&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line"> interface Service&#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>除了没有名字，匿名内部类还有以下特点：</strong></p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><p><strong>匿名内部类创建方式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类/接口&#123; </span><br><span class="line">  //匿名内部类实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内部类的优点</strong><br><strong>我们为什么要使用内部类呢？因为它有以下优点：</strong></p><p>1一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</p><p>2内部类不为同一包的其他类所见，具有很好的封装性；</p><p>3内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</p><p>4匿名内部类可以很方便的定义回调。</p><p><strong>内部类有哪些应用场景</strong></p><ul><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ul><p><strong>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</strong></p><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？<br>先看这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    void <span class="function"><span class="title">outMethod</span></span>()&#123;</span><br><span class="line">        final int a =10;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            void <span class="function"><span class="title">innerMethod</span></span>()&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子，为什么要加final呢？是因为生命周期不一致，<br>局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。<br>内部类相关，看程序说出运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    private int age = 12;</span><br><span class="line">    class Inner &#123;</span><br><span class="line">        private int age = 13;</span><br><span class="line">        public void <span class="function"><span class="title">print</span></span>() &#123;</span><br><span class="line">            int age = 14;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部变量：&quot;</span> + age);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + this.age);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outer.this.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer.Inner <span class="keyword">in</span> = new Outer().new Inner();</span><br><span class="line">        in.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br>局部变量：14<br>内部类变量：13<br>外部类变量：12</p><h2 id="1-3-6-重写与重载、多态"><a href="#1-3-6-重写与重载、多态" class="headerlink" title="1.3.6 重写与重载、多态"></a>1.3.6 重写与重载、多态</h2><p><strong>构造器（constructor）是否可被重写（override）？</strong></p><p>答：构造器不能被继承，因此不能被重写，但可以被重载。</p><p><strong>Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？</strong></p><p>答：Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法 是编译时静态绑定的。static<br>方法跟类的任何实例都不相关，所以概念上不适用。 java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用，<br>如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。</p><p><strong>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</strong></p><p>答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分，即：</p><p>1.可以在一个类中也可以在继承关系的类中；<br>2.名相同；<br>3.参数列表不同（个数，顺序，类型） 和方法的返回值类型无关。</p><p><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。即：</p><p>1.不能存在同一个类中，在继承或实现关系的类中；<br>\2. 名相同，参数列表相同，方法返回值相同，<br>3.子类方法的访问修饰符要大于父类的。<br>4.子类的检查异常类型要小于父类的检查异常</p><p><strong>多态在实际中的应用：</strong></p><p>答：在实际开发工作中，常常遇到一个功能有多种实现方式，比如支付方式，有分微信支付、京东支付、支付宝、银联等支付方式，不同支付方式的大概流程大抵相似，实现细节有所区别。这个时候就可以用到java的多态机制，先定义一个公共接口，接口定义支付流程的各个方法，具体的支付方式实现该接口的方法。在控制层，利用spring的注入获取支付类型和支付方式实现类的引用映射，根据请求需要的支付类型就可以调用对应支付方式的方法，以此实现业务的解耦和拓展。后期需要增加支付方式，只需要实现共同接口即可。</p><h2 id="1-3-7-对象相等判断"><a href="#1-3-7-对象相等判断" class="headerlink" title="1.3.7 对象相等判断"></a>1.3.7 对象相等判断</h2><p><strong>&#x3D;&#x3D;和 equals 的区别是什么</strong></p><p><strong>&#x3D;&#x3D;</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。<br>基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址。</p><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><p><strong>情况1</strong>：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D; ” 比较这两个对象。</p><p><strong>情况2</strong>：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (<br>即，认为这两个对象相等)。<br>举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = new String(<span class="string">&quot;ab&quot;</span>); // a 为一个引用</span><br><span class="line">        String b = new String(<span class="string">&quot;ab&quot;</span>); // b为另一个引用,对象的内容一样</span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; // 放在常量池中</span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; // 从常量池中查找</span><br><span class="line">        <span class="keyword">if</span> (aa == bb) // <span class="literal">true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) // <span class="literal">false</span>，非同一对象</span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) // <span class="literal">true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (42 == 42.0) &#123; // <span class="literal">true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。<br>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。<br><strong>hashCode 与 equals (重要)</strong></p><p>HashSet如何检查重复<br>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？<br>hashCode和equals方法的关系<br>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p><p><strong>hashCode()介绍</strong><br>hashCode()<br>的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()<br>定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>为什么要有 hashCode</strong></p><p>我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：<br>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode<br>值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()<br>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head<br>first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p><strong>hashCode()与equals()的相关规定</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等，对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li></ul><p><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></p><p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p><p><strong>对象的相等与指向他们的引用相等，两者有什么不同？</strong></p><p>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</p><h2 id="1-3-8-值传递"><a href="#1-3-8-值传递" class="headerlink" title="1.3.8 值传递"></a>1.3.8 值传递</h2><p>**<br>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递**</p><p>答：是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</p><p><strong>为什么 Java 中只有值传递</strong></p><p>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)<br>表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。<br>它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。<br>下面通过 3 个例子来给大家说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example 1</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = 20;</span><br><span class="line">    swap(num1, num2);</span><br><span class="line">    System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line">public static void swap(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">a = 20</span><br><span class="line">b = 10</span><br><span class="line">num1 = 10</span><br><span class="line">num2 = 20</span><br></pre></td></tr></table></figure><p><strong>解析：</strong><br>![在这里插入图片描述](1. Java基础知识.assets&#x2F;d1a0bf6484ca4e458d226abffc79e917.png)</p><p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2<br>的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p><p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">example 2</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">        System.out.println(arr[0]);</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void change(int[] array) &#123;</span><br><span class="line">        // 将数组的第一个元素变为0</span><br><span class="line">        array[0] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>解析：<br>![在这里插入图片描述](1. Java基础知识.assets&#x2F;e6f58274f7154ed585496ece750827e9.png)</p><p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><p>通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。<br>很多程序设计语言（特别是，C++和Pascal)<br>提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">example 3</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Student s1 = new Student(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">        Student s2 = new Student(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    public static void swap(Student x, Student y) &#123;</span><br><span class="line">        Student temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;x:&quot;</span> + x.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;y:&quot;</span> + y.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p>解析：<br>交换之前：<br>![在这里插入图片描述](1. Java基础知识.assets&#x2F;8bc04abd4cf045b6ab3a14965beff5c6.png)</p><p>交换之后：<br>![在这里插入图片描述](1. Java基础知识.assets&#x2F;c2228c3e856f4be8b78d32b17b1c2dce.png)</p><p>通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p><p><strong>总结</strong></p><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。<br>下面再总结一下Java中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p><strong>值传递和引用传递有什么区别</strong></p><p><strong>值传递</strong>：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p><p><strong>引用传递</strong>：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p><h2 id="1-3-9-Java包"><a href="#1-3-9-Java包" class="headerlink" title="1.3.9 Java包"></a>1.3.9 Java包</h2><p>JDK 中常用的包有哪些<br>java.lang：这个是系统的基础类；<br>java.io：这里面是所有输入输出有关的类，比如文件操作等；<br>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；<br>java.net：这里面是与网络有关的类；<br>java.util：这个是系统辅助类，特别是集合类；<br>java.sql：这个是数据库操作的类。</p><p><strong>import java和javax有什么区别</strong></p><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为<br>Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax<br>包将成为标准API的一部分。</p><p>所以，实际上java和javax没有区别。这都是一个名字。</p><h1 id="1-4-IO流"><a href="#1-4-IO流" class="headerlink" title="1.4 IO流"></a>1.4 IO流</h1><h2 id="1-4-1-Java中-IO-流分为几种"><a href="#1-4-1-Java中-IO-流分为几种" class="headerlink" title="1.4.1 Java中 IO 流分为几种?"></a>1.4.1 Java中 IO 流分为几种?</h2><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java<br>I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p><ul><li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。<br>按操作方式分类结构图：<br>![在这里插入图片描述](1. Java基础知识.assets&#x2F;fb0b75a5f4254021a8fe7a67d29b975e.png)</li></ul><p>按操作对象分类结构图：</p><p>![在这里插入图片描述](1. Java基础知识.assets&#x2F;1a680c3f06c348f5a87f699592a34ed0.png)</p><h2 id="1-4-2-BIO-NIO-AIO-有什么区别"><a href="#1-4-2-BIO-NIO-AIO-有什么区别" class="headerlink" title="1.4.2 BIO,NIO,AIO 有什么区别?"></a>1.4.2 BIO,NIO,AIO 有什么区别?</h2><p>简答</p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><p><strong>详细回答</strong></p><ul><li><strong>BIO (Blocking I&#x2F;O)</strong>: 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的<br>I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的<br>BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I&#x2F;O)</strong>: NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel ,<br>Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。<br>NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel<br>两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用<br>NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I&#x2F;O)</strong>: AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO<br>是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO<br>是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在<br>IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO<br>的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul><h2 id="1-4-3-Files的常用方法都有哪些？"><a href="#1-4-3-Files的常用方法都有哪些？" class="headerlink" title="1.4.3 Files的常用方法都有哪些？"></a>1.4.3 Files的常用方法都有哪些？</h2><p>Files. exists()：检测文件路径是否存在。<br>Files. createFile()：创建文件。<br>Files. createDirectory()：创建文件夹。<br>Files. delete()：删除一个文件或目录。<br>Files. copy()：复制文件。<br>Files. move()：移动文件。<br>Files. size()：查看文件个数。<br>Files. read()：读取文件。<br>Files. write()：写入文件。</p><h1 id="1-5-反射"><a href="#1-5-反射" class="headerlink" title="1.5 反射"></a>1.5 反射</h1><h2 id="1-5-1-什么是反射机制"><a href="#1-5-1-什么是反射机制" class="headerlink" title="1.5.1 什么是反射机制"></a>1.5.1 什么是反射机制</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p><strong>静态编译和动态编译</strong></p><ul><li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li><li><strong>动态编译：</strong>运行时确定类型，绑定对象</li></ul><h2 id="1-5-2-反射机制优缺点"><a href="#1-5-2-反射机制优缺点" class="headerlink" title="1.5.2 反射机制优缺点"></a>1.5.2 反射机制优缺点</h2><p>• 优点： 运行期类型的判断，动态加载类，提高代码灵活度。</p><p>• 缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</p><h2 id="1-5-3-反射机制的应用场景"><a href="#1-5-3-反射机制的应用场景" class="headerlink" title="1.5.3 反射机制的应用场景"></a>1.5.3 反射机制的应用场景</h2><p><strong>反射是框架设计的灵魂。</strong></p><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的<br>Spring／Hibernate 等框架也大量使用到了反射机制。</p><p>举例：<br>①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。</p><p><strong>Spring 通过 XML 配置模式装载 Bean 的过程：</strong></p><p>1)将程序内所有 XML 或 Properties 配置文件加载入内存中;</p><p>2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</p><p>3)使用反射机制，根据这个字符串获得某个类的Class实例;</p><p>4)动态配置实例的属性</p><h2 id="1-5-4-Java获取反射的三种方法"><a href="#1-5-4-Java获取反射的三种方法" class="headerlink" title="1.5.4 Java获取反射的三种方法"></a>1.5.4 Java获取反射的三种方法</h2><p><strong>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private int <span class="built_in">id</span>;</span><br><span class="line">    String name;</span><br><span class="line">    protected boolean sex;</span><br><span class="line">    public <span class="built_in">float</span> score;</span><br><span class="line">&#125;</span><br><span class="line">public class Get &#123;</span><br><span class="line">    //获取反射机制三种方式</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        //方式一(通过建立对象)</span><br><span class="line">        Student stu = new Student();</span><br><span class="line">        Class classobj1 = stu.getClass();</span><br><span class="line">        System.out.println(classobj1.getName());</span><br><span class="line">        //方式二（所在通过路径-相对路径）</span><br><span class="line">        Class classobj2 = Class.forName(<span class="string">&quot;fanshe.Student&quot;</span>);</span><br><span class="line">        System.out.println(classobj2.getName());</span><br><span class="line">        //方式三（通过类名）</span><br><span class="line">        Class classobj3 = Student.class;</span><br><span class="line">        System.out.println(classobj3.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>反射机制详细介绍</code><br>包括：获取Class对象的方式、获取成员变量、获取构造方法等等。参考：<a href="https://blog.csdn.net/qq_43061290/article/details/105064453">https://blog.csdn.net/qq_43061290/article/details/105064453</a></p><h1 id="1-6-网络编程"><a href="#1-6-网络编程" class="headerlink" title="1.6 网络编程"></a>1.6 网络编程</h1><p><a href="https://blog.csdn.net/qq_43061290/article/details/124041420">网络编程的面试题</a><br>重学TCP&#x2F;IP协议和三次握手四次挥手，包括TCP&#x2F;IP协议和三次握手四次挥手的知识，计算机网络体系结构，HTTP协议，get请求和post请求区别，session和cookie的区别等。<br>欢迎大家阅读第14章：<a href="https://blog.csdn.net/qq_43061290/article/details/124041420">https://blog.csdn.net/qq_43061290/article/details/124041420</a></p><h1 id="1-7-常用API"><a href="#1-7-常用API" class="headerlink" title="1.7 常用API"></a>1.7 常用API</h1><h2 id="1-7-1-String-相关-StringBuffer、StringBuilde"><a href="#1-7-1-String-相关-StringBuffer、StringBuilde" class="headerlink" title="1.7.1 String 相关:StringBuffer、StringBuilde"></a>1.7.1 String 相关:StringBuffer、StringBuilde</h2><p><strong>字符型常量和字符串常量的区别</strong></p><ul><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占两个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ul><p><strong>什么是字符串常量池？</strong></p><p>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM<br>会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</p><p><strong>String 是最基本的数据类型吗</strong></p><p>答：不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive<br>type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</p><p>这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是<br>char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char<br>类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};</p><p>但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</p><p><strong>String有哪些特性</strong></p><ul><li>1、不变性：String 是只读字符串，是一个典型的 immutable<br>对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>2、常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>3、final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><p><strong>String为什么是不可变的吗？</strong></p><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** The value is used <span class="keyword">for</span> character storage. */</span><br><span class="line">private final char value[];</span><br></pre></td></tr></table></figure><p><strong>String真的是不可变的吗？</strong></p><p>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：<br>1）String不可变但不代表引用不可以变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = str + <span class="string">&quot; World&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span> + str);</span><br><span class="line">结果：</span><br><span class="line">str=Hello World</span><br></pre></td></tr></table></figure><p>解析：<br>实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”<br>的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。</p><ol><li>通过反射是可以修改所谓的“不可变”对象</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建字符串<span class="string">&quot;Hello World&quot;</span>， 并赋给引用s</span><br><span class="line">String s = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); // Hello World</span><br><span class="line">// 获取String类中的value字段</span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">// 改变value属性的访问权限</span><br><span class="line">valueFieldOfString.setAccessible(<span class="literal">true</span>);</span><br><span class="line">// 获取s对象上的value属性的值</span><br><span class="line">char[] value = (char[]) valueFieldOfString.get(s);</span><br><span class="line">// 改变value所引用的数组中的第5个字符</span><br><span class="line">value[5] = <span class="string">&#x27;_&#x27;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s); // Hello_World</span><br><span class="line">结果：</span><br><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br></pre></td></tr></table></figure><p><strong>解析：</strong></p><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p><p><strong>是否可以继承 String 类</strong></p><p>答：String 类是 final 类，不可以被继承。</p><p><strong>String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</strong></p><p>答：不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”)<br>则会被分到堆内存中。</p><p><strong>String s &#x3D; new String(“xyz”);创建了几个字符串对象</strong></p><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>; //str1指向静态区</span><br><span class="line">String str2 = new String(<span class="string">&quot;hello&quot;</span>);  //str2指向堆上的对象</span><br><span class="line">String str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str4 = new String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)); //true</span><br><span class="line">System.out.println(str2.equals(str4)); //true</span><br><span class="line">System.out.println(str1 == str3); //true</span><br><span class="line">System.out.println(str1 == str2); //false</span><br><span class="line">System.out.println(str2 == str4); //false</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); //false</span><br><span class="line">str2 = str1;</span><br><span class="line">System.out.println(str2 == <span class="string">&quot;hello&quot;</span>); //true</span><br></pre></td></tr></table></figure><p><strong>如何将字符串反转？</strong></p><p>答：使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba</span><br><span class="line">// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><p><strong>数组有没有 length()方法？String 有没有 length()方法</strong></p><p>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和<br>Java 混淆。</p><p><strong>String 类的常用方法都有那些？</strong></p><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p><p><strong>在使用 HashMap 的时候，用 String 做 key 有什么好处？</strong></p><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode<br>被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><p><strong>String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</strong></p><ul><li>1、可变性<br>String类中使用字符数组保存字符串，private final char value[]<br>，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]<br>value，这两种对象都是可变的。</li><li>2、线程安全性<br>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li><li>3、性能<br>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String<br>对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder<br>相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><p><strong>对于三者使用的总结</strong></p><p>如果要操作少量的数据用 &#x3D; String<br>单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p><p><strong>String，是否可以继承，“+”怎样实现，与 StringBuffer 区别</strong></p><p>答：在Java中，使用“+”来串联字符串的时候，实际上底层是通过StirngBuilder实例的append()实现的。</p><p><strong>String有重写Object的 hashcode和toString吗？如果重写Equals不重写hashcode会出现什么问题？</strong></p><p>答：String重写了Object类的hashcode和toString方法。<br>当equals方法被重写时，通常有必要重写hashcode方法，以维护hashCode方法的常规协定，该协定声明相等的俩个对象必须有相同的hashcode.<br>Object1.euqal(object2)为true，Object1.hashCode()&#x3D;&#x3D;Object2.hashCode()则为true。<br>Object1.hashCode()&#x3D;&#x3D;Object2.hashCode()为false，Object1.euqal(object2)必定为false。<br>Object1.hashCode()&#x3D;&#x3D;Object2.hashCode()为true，Object1.euqal(object2)不一定为true。</p><h2 id="1-7-2-Date相关"><a href="#1-7-2-Date相关" class="headerlink" title="1.7.2 Date相关"></a>1.7.2 Date相关</h2><h2 id="1-7-3-包装类相关"><a href="#1-7-3-包装类相关" class="headerlink" title="1.7.3 包装类相关"></a>1.7.3 包装类相关</h2><p><strong>自动装箱与拆箱</strong></p><ul><li>装箱：将基本类型用它们对应的引用类型包装起来；</li><li>拆箱：将包装类型转换为基本数据类型；</li></ul><p><strong>int 和 Integer 有什么区别</strong></p><p>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java<br>为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。</p><p><strong>Java 为每个原始类型提供了包装类型：</strong></p><p>原始类型: boolean，char，byte，short，int，long，float，double<br>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</p><p><strong>int与Integer的基本使用对比</strong></p><p>• Integer是int的包装类；int是基本数据类型；<br>• Integer变量必须实例化后才能使用；int变量不需要；<br>• Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；<br>• Integer的默认值是null；int的默认值是0。</p><p><strong>int与Integer的深入对比</strong><br>（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</span><br><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = new Integer(100);</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">int j = 100；</span><br><span class="line">System.out.print(i == j); //true</span><br></pre></td></tr></table></figure><p>（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new<br>Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>（4）对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br><span class="line">Integer i = 128;</span><br><span class="line">Integer j = 128;</span><br><span class="line">System.out.print(i == j); //false</span><br></pre></td></tr></table></figure><p>对于第4条的原因： java在编译Integer i &#x3D; 100 ;时，会翻译成为Integer i &#x3D; Integer.valueOf(100)。而java<br>API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127这个Integer对象进行缓存，下次再写Integer<br>j &#x3D; 127时，就会直接从缓存中取，就不会new了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="built_in">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-8-常用的工具类库"><a href="#1-8-常用的工具类库" class="headerlink" title="1.8 常用的工具类库"></a>1.8 常用的工具类库</h1><h1 id="1-9-栈、堆、方法区存储的内容"><a href="#1-9-栈、堆、方法区存储的内容" class="headerlink" title="1.9 栈、堆、方法区存储的内容"></a>1.9 栈、堆、方法区存储的内容</h1><p><strong>堆区:</strong></p><p>1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)</p><p>2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。</p><p><strong>栈区:</strong></p><p>1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用<br>2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。<br>3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p><p><strong>方法区:</strong></p><p>1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。<br>2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>]]></content>
      
      
      <categories>
          
          <category> Java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
